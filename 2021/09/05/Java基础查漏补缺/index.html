<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础查漏补缺 | Liyou's Blog</title><meta name="keywords" content="J2SE"><meta name="author" content="Liyou"><meta name="copyright" content="Liyou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="大纲Java概述 变量 运算符 控制结构 数组 面向对象编程 枚举和注解 异常 常用类 集合 泛型 线程 IO Mysql基础 JDBC和连接池 正则表达式 Java8和Java11新特性 Java概述如何快速学习新技术 需求 工作需要 跳槽 技术控   看看能否使用传统技术解决 能解决，但是不完美 解决不了   引出我们学习的新技术和知识点 学习新技术或者知识点的基本原理和基本语法（不要考虑细节">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础查漏补缺">
<meta property="og:url" content="http://hualala-2.github.io/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/index.html">
<meta property="og:site_name" content="Liyou&#39;s Blog">
<meta property="og:description" content="大纲Java概述 变量 运算符 控制结构 数组 面向对象编程 枚举和注解 异常 常用类 集合 泛型 线程 IO Mysql基础 JDBC和连接池 正则表达式 Java8和Java11新特性 Java概述如何快速学习新技术 需求 工作需要 跳槽 技术控   看看能否使用传统技术解决 能解决，但是不完美 解决不了   引出我们学习的新技术和知识点 学习新技术或者知识点的基本原理和基本语法（不要考虑细节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hualala-2.github.io/img/cover5.jpg">
<meta property="article:published_time" content="2021-09-05T12:29:24.000Z">
<meta property="article:modified_time" content="2022-11-15T09:59:49.660Z">
<meta property="article:author" content="Liyou">
<meta property="article:tag" content="J2SE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hualala-2.github.io/img/cover5.jpg"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="http://hualala-2.github.io/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础查漏补缺',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-15 17:59:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Liyou's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/lazyload1.gif" data-lazy-src="/img/tit.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-feather-alt"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 优链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Liyou's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-feather-alt"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 优链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础查漏补缺</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-05T12:29:24.000Z" title="发表于 2021-09-05 20:29:24">2021-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-15T09:59:49.660Z" title="更新于 2022-11-15 17:59:49">2022-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/J2SE/">J2SE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础查漏补缺"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><a href="#Java%E6%A6%82%E8%BF%B0">Java概述</a></p>
<p><a href="#%E5%8F%98%E9%87%8F">变量</a></p>
<p><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></p>
<p><a href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">控制结构</a></p>
<p><a href="#%E6%95%B0%E7%BB%84">数组</a></p>
<p><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a></p>
<p><a href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3">枚举和注解</a></p>
<p><a href="#%E5%BC%82%E5%B8%B8">异常</a></p>
<p><a href="#%E5%B8%B8%E7%94%A8%E7%B1%BB">常用类</a></p>
<p><a href="#%E9%9B%86%E5%90%88">集合</a></p>
<p><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></p>
<p><a href="#%E7%BA%BF%E7%A8%8B">线程</a></p>
<p><a href="#IO">IO</a></p>
<p><a href="#Mysql%E5%9F%BA%E7%A1%80">Mysql基础</a></p>
<p><a href="#JDBC%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0">JDBC和连接池</a></p>
<p><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></p>
<p><a href="#Java8%E5%92%8CJava11%E6%96%B0%E7%89%B9%E6%80%A7">Java8和Java11新特性</a></p>
<h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="如何快速学习新技术"><a href="#如何快速学习新技术" class="headerlink" title="如何快速学习新技术"></a>如何快速学习新技术</h2><ol>
<li>需求<ul>
<li>工作需要</li>
<li>跳槽</li>
<li>技术控</li>
</ul>
</li>
<li>看看能否使用传统技术解决<ul>
<li>能解决，但是不完美</li>
<li>解决不了</li>
</ul>
</li>
<li>引出我们学习的新技术和知识点</li>
<li>学习新技术或者知识点的基本原理和基本语法（不要考虑细节）</li>
<li>快速入门（基本程序，crud）</li>
<li>开始研究技术的注意事项，使用细节，使用规范，如何优化——&gt;没有止境，技术魅力</li>
</ol>
<h2 id="Java的应用领域"><a href="#Java的应用领域" class="headerlink" title="Java的应用领域"></a>Java的应用领域</h2><ul>
<li><p>企业级应用</p>
<p>主要指复杂的大企业的软件系统、各种类型的网站。应用领域包括金融、电信、交通、电子商务等</p>
</li>
<li><p>Android平台应用</p>
<p>Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实</p>
</li>
<li><p>移动领域应用</p>
<p>主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括机顶盒、车载的大屏影音娱乐设备、汽车通信设备、扫码的pos机等</p>
</li>
</ul>
<h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><p>程序：计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p>
<p>举例说明：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\什么是程序.png"/>

<h2 id="Java历史"><a href="#Java历史" class="headerlink" title="Java历史"></a>Java历史</h2><ul>
<li>1990sun公司启动绿色计划</li>
<li>1992创建oak（橡树）语言——&gt;Java</li>
<li>1994gosling参加硅谷大会演示Java功能，震惊世界</li>
<li>1995sun正式发布Java第一个版本</li>
<li>2009年，甲骨文公司宣布收购sun，2011年，发布Java7</li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">其他Java版本发布详情</a></li>
</ul>
<h2 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h2><ul>
<li><p>Java SE（Java Standard Edition）标准版</p>
<p>支持面向桌面级应用（如windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</p>
</li>
<li><p>Java EE（Java Enterprise Edition）企业版</p>
<p>是为开发企业环境下的应用程序提供的一套解决方案，该技术体系种包含的技术如：servlet、Jsp等，主要针对于web应用程序开发，版本以前称为J2EE</p>
</li>
<li><p>Java ME（Java Micro Edition）小型版</p>
<p>支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME</p>
</li>
</ul>
<h2 id="Java重要特点"><a href="#Java重要特点" class="headerlink" title="Java重要特点"></a>Java重要特点</h2><ol>
<li><p>Java语言是面向对象的（oop）</p>
</li>
<li><p>Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证</p>
</li>
<li><p>Java语言是跨平台性的</p>
<p>即一个编译好的.class文件可以在多个系统下运行，这种特性称为跨平台性</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\跨平台性.png"/></li>
<li><p>Java语言是解释型的【了解】</p>
<p>解释型语言：Javascript、PHP、Java    编译型语言：C/C++</p>
<p>区别是：</p>
<p>解释型语言：解释后的代码不能直接被机器执行，需要解释器来执行</p>
<p>编译型语言：编译后的代码可以直接被机器执行</p>
</li>
</ol>
<h2 id="Java的开发工具"><a href="#Java的开发工具" class="headerlink" title="Java的开发工具"></a>Java的开发工具</h2><ul>
<li>editplus、notepad++</li>
<li>sublime Text</li>
<li>IDEA</li>
<li>eclipse</li>
</ul>
<h2 id="Java运行机制及运行过程"><a href="#Java运行机制及运行过程" class="headerlink" title="Java运行机制及运行过程"></a>Java运行机制及运行过程</h2><ul>
<li><p>Java语言的特点：跨平台性</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\Java语言的特点.png"/>

<p>说明：因为有了JVM，同一个Java程序在三个不同的操作系统种都可以执行，这样就实现了Java程序的跨平台性</p>
</li>
<li><p>Java核心机制——Java虚拟机（java virtual machine）</p>
<ol>
<li>基本介绍<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令、管理数据、内存、寄存器，包含在JDK中</li>
<li>对于不同的平台，有不同的虚拟机</li>
<li>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="什么是JDK，JRE"><a href="#什么是JDK，JRE" class="headerlink" title="什么是JDK，JRE"></a>什么是JDK，JRE</h2><ul>
<li><p>JDK基本介绍</p>
<ol>
<li><p>JDK的全程（Java Development Kit Java开发工具包）</p>
<p>JDK = JRE + Java的开发工具【java，javac，javadoc，javap等】</p>
</li>
<li><p>JDK是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE，所以安装了JDK，就不用再单独安装JRE了</p>
</li>
</ol>
</li>
<li><p>JRE基本介绍</p>
<ol>
<li>JRE（Java Runtime Environment Java运行时环境）</li>
<li>包括Java虚拟机（JVM Java Virtual Machine）和Java程序所需的核心类库等。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可</li>
</ol>
</li>
<li><p>JDK、JRE和JVM的包含关系</p>
<ol>
<li>JDK = JRE + 开发工具集（例如Javac、Java编译工具等）</li>
<li>JRE = JVM + Java SE标准类库（Java核心类库）</li>
<li>JDK = JVM + Java SE标准类库 + 开发工具集</li>
<li>如果只想运行开发好的.class文件只需要JRE</li>
</ol>
</li>
</ul>
<h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>歪比巴布</p>
<h2 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h2><ul>
<li><p>Java执行流程分析</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\Java执行流程.png"/></li>
<li><p>什么是编译</p>
<p><code>javac Hello.java</code></p>
<ol>
<li>有了Java源文件，通过编译将其编译成JVM可以识别的字节码文件</li>
<li>在该文件目录下，通过javac编译工具对Hello.java文件进行编译</li>
<li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Hello.class文件，该文件称为字节码文件，也是可以执行的java的程序</li>
</ol>
</li>
<li><p>什么是运行</p>
<ol>
<li>有了可执行的java程序（Hello.class字节码文件）</li>
<li>通过运行工具java.exe对字节码文件进行执行，本质就是将.class文件装在到JVM上执行</li>
</ol>
</li>
<li><p>java程序开发注意事项</p>
<p>对修改后的Hello.java源文件需要重新编译，生成新的class文件后，再进行执行，才能生效</p>
</li>
</ul>
<h2 id="Java开发注意事项和细节说明"><a href="#Java开发注意事项和细节说明" class="headerlink" title="Java开发注意事项和细节说明"></a>Java开发注意事项和细节说明</h2><ol>
<li><p>Java源文件以.class为扩展名。该文件的基本组成部分是类（class），如本类中的Hello类</p>
</li>
<li><p>Java应用程序的执行入口是main（）方法，它有固定的书写格式：</p>
<p><code>public static void main(String[] args)&#123;……&#125;</code></p>
</li>
<li><p>Java语言严格区分大小写</p>
</li>
<li><p>Java方法由一条条语言构成，每个语句以“；”结束。</p>
</li>
<li><p>大括号都是成对出现的，缺一不可。【习惯：先写{}再写代码】</p>
</li>
<li><p>一个源文件中最多只能有一个public类。其他类的个数不限</p>
</li>
<li><p>如果源文件中包含一个public类。则文件名必须按该类名命名</p>
</li>
<li><p>一个源文件中最多只能有一个public类，其他类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        ((UserServiceImpl)userService).setUserDao(<span class="keyword">new</span> UserDaoImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,小狗狗！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Java转义字符"><a href="#Java转义字符" class="headerlink" title="Java转义字符"></a>Java转义字符</h2><ul>
<li><p>Java常用的转义字符</p>
<ol>
<li><p>\t：一个制表位，实现对齐的功能</p>
</li>
<li><p>\n：换行符</p>
</li>
<li><p>\\：一个\</p>
</li>
<li><p>\“：一个“</p>
</li>
<li><p>\‘：一个‘</p>
</li>
<li><p>\r：一个回车</p>
<p><code>System.out.println(&quot;韩顺平教育\r北京&quot;);</code></p>
</li>
</ol>
<p>回车与换行：<br>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，<strong>告诉打字机把打印头定位在左边界</strong>；另一个叫做“换行”，<strong>告诉打字机把纸向下移一行</strong>。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；<br>Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车&gt;”，即“\n\r”；<br>Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。<br>\r回车是将光标移到一行的前面<br>\n是移到下一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">转义字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,小\n狗狗！！！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;世界真大\r，我想去看看！！！&quot;</span>);<span class="comment">//回车符会使得之后的内容输出在同一行第一个位置</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;\\&quot;</span>+<span class="string">&quot;\&quot;&quot;</span>+<span class="string">&quot;\&#x27;&quot;</span>+<span class="string">&quot;hualala-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">Hello,小</span></span><br><span class="line"><span class="comment">狗狗！！！</span></span><br><span class="line"><span class="comment">，我想看看</span></span><br><span class="line"><span class="comment">Hello	\&quot;&#x27;hualala-2</span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注释（comment）"><a href="#注释（comment）" class="headerlink" title="注释（comment）"></a>注释（comment）</h2><ul>
<li><p>介绍：</p>
<p>用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性），注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现</p>
</li>
<li><p>Java中的注释类型</p>
<ol>
<li><p>单行注释</p>
</li>
<li><p>多行注释</p>
</li>
<li><p>文档注释</p>
</li>
</ol>
<ul>
<li><p>单行注释</p>
<p>基本格式：</p>
<p>//注释文字</p>
</li>
<li><p>多行注释</p>
<p>基本格式：</p>
<p>/* 注释文字 */</p>
</li>
<li><p>使用细节</p>
<ol>
<li>被注释的文字不会被JVM（java虚拟机）解释执行</li>
<li>多行注释里面不允许有多行注释嵌套</li>
</ol>
</li>
<li><p>文档注释：</p>
<p>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类</p>
<ul>
<li><p>基本格式</p>
</li>
<li><p>如何生成对应的文档注释</p>
</li>
<li><p>应用实例</p>
<p><code>javadoc -d 文件夹名 -xx -yy Demo.java</code></p>
<p><code>javadoc -d d:\\temp -author -version Comment02.java</code></p>
</li>
<li><p>javadoc标签</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ol>
<li>类、方法的注释要以javadoc的方式来写</li>
<li>非Java Doc的注释，往往是给代码的维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等</li>
<li>使用tab操作，实现缩进，默认整体向右移动；用shift+tab整体向左移动</li>
<li>运算符和 = 两边习惯性各加一个空格</li>
<li>源文件使用utf-8编码</li>
<li>行宽度不要超过80字符</li>
<li>代码编写次行风格（大括号位置：下一行起始）和尾行风格（大括号位置：行尾）</li>
</ol>
<h2 id="DOS命令（了解）"><a href="#DOS命令（了解）" class="headerlink" title="DOS命令（了解）"></a>DOS命令（了解）</h2><ul>
<li><p>DOS介绍</p>
<p>DOS：Disk Operating System 磁盘路径系统，简单说一下windows的目录结构</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\dos的基本原理.png"/></li>
<li><p>相关的只是补充：相对路径，绝对路径</p>
<p>相对路径：从当前目录开始定位，形成的一个路径<br>绝对路径：从顶级目录开始定位，形成的路径</p>
</li>
<li><p>常用的dos命令</p>
<ol>
<li><p>查看当前目录有什么</p>
<p><code>dir d:\abc2\test200</code></p>
</li>
<li><p>切换到其他盘下：盘符号（cd）</p>
<p>切换到c盘：<code>cd /D c</code></p>
</li>
<li><p>切换到当前盘的其他目录下（使用相对论路径和绝对路径演示）</p>
<p><code>cd d:\abc2\test200</code></p>
<p><code>cd ..\..\abc2\abc2\test200</code></p>
</li>
<li><p>切换到上一级</p>
<p><code>cd ..</code></p>
</li>
<li><p>切换到根目录</p>
<p><code>cd \</code></p>
</li>
<li><p>查看指定的目录下所有的子级目录</p>
<p><code>tree</code></p>
</li>
<li><p>清屏</p>
<p><code>cls</code></p>
</li>
<li><p>退出</p>
<p><code>exit</code></p>
</li>
<li><p>说明：因为小伙伴后面使用dos非常少，所以下面的几个指令，大家了解即可（md、rd、copy、del、echo、type、move）</p>
</li>
</ol>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java概述讲了什么呢？<br>首先Java是由一个叫高斯林的人在95年推出的，Java的运行机制；jvm、jre、jdk三者的关系；写代码的一些注意事项；基础的dos命令；转义字符；jdk的安装</p>
<p>tips：先完成功能，再优化细节。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>为什么需要变量？</p>
<p>一个程序就是一个世界</p>
<p>变量是程序的基本组成单位</p>
<p>不论是使用哪种高级程序语言编写程序，变量都是其程序的基本组成单位</p>
<p>变量有三个基本要素（类型+名称+值）</p>
<ul>
<li><p>概念</p>
<p>变量相当于内存中的一个数据存储空间的表示，你可以把变量看作是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量（值）</p>
</li>
<li><p>变量使用的基本步骤</p>
<ol>
<li><p>声明变量</p>
<p>int a;</p>
</li>
<li><p>赋值</p>
<p>a = 60;</p>
</li>
<li><p>使用System.out.println(a);</p>
<p>也可以一步到位    int a = 60;</p>
</li>
</ol>
</li>
<li><p>变量使用注意事项</p>
<ol>
<li>变量表示内存中的一个存储区域【不同的变量，类型不同】</li>
<li>该区域有自己的名称【变量名】和类型【数据类型】</li>
<li>变量必须先声明，后使用，即有顺序</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量在同一个作用域内不能重名</li>
<li>变量=数据类型+名称+值，这一点请大家注意，变量的三要素</li>
</ol>
</li>
</ul>
<h2 id="号的使用"><a href="#号的使用" class="headerlink" title="+号的使用"></a>+号的使用</h2><ol>
<li>当左右两边都是数值型，则做加法运算</li>
<li>当左右两边有一方为字符串，则做拼接运算</li>
<li>运算顺序是从左到右的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="number">100</span>+<span class="number">99</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;100&quot;</span>+<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//100+2先正常执行变为102，遇到字符串后，变为字符串，运算顺序从左到右</span></span><br><span class="line">		System.out.println(<span class="number">100</span>+<span class="number">2</span>+<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello&quot;</span>+<span class="number">100</span>+<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">199</span></span><br><span class="line"><span class="comment">10099</span></span><br><span class="line"><span class="comment">102Hello</span></span><br><span class="line"><span class="comment">Hello1002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\数据类型.png"/>

<p>然后就是数据类型介绍，分为基本数据类型和引用数据类型，</p>
<p>基本数据类型：byte（-128 ~ 127）、short（-32768 ~ 32767）（-2^15~ 2^ 15-1）、int(-2^31 <del>2^ 31-1)、long(-2^ 63</del>2^ 63-1)、float（4字节）、double（8字节）、boolean(1个字节)、char（2字节）；引用数据类型：类、接口、数组等。</p>
<ul>
<li><p>整数类型</p>
<p>Java的整数类型就是用于存放整数值的，比如12，2，2345等</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\整数类型.png"/>

<p>万一需要表示比long类型最大的值都要大的数，咋表示呢，有常用类中的BigInteger和BigDecimal可以使用。</p>
<ul>
<li>整数类型的使用细节<ol>
<li>Java各整数类型有固定的范围和字段长度，不受具体OS【操作系统】的影响，以保证Java程序的可移植性</li>
<li>Java的整型常量默认为int型，声明long型常量须在后面加‘l’或‘L’</li>
<li>Java程序中变量常声明为int型，除非不足以表示大数，才使用long</li>
<li>bit：计算机中的最小存储单位，byte：计算机中基本存储单位，1byte=8bit</li>
</ol>
</li>
</ul>
</li>
<li><p>浮点类型</p>
<p>Java的浮点型可以表示一个小数不如123.4，7.8，0.12等</p>
<p>使用long型时，加上“l”或“L”，如int id = 1L；编译器先看到1L确定给它分配8个字节，然后再进行赋值操作。</p>
<p>然后就浮点数嘛，单精度4字节和双精度8字节，浮点数=符号位+指数位+尾数位。小数都是近似值。</p>
<p>float num1 = .002；报错，.002没啥问题，但小数默认double双精度，使用float类型，加上“f”或“F”。</p>
<p>float类型保留小数点后7位。double保留小数点后16位左右。</p>
<p>科学计数法：5.12e2表示5.12*（10^2）；e不是2.7。</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\浮点型.png"/>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    浮点型数值使用陷阱：2.7和8.1/3是否相等（小数比较）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> num1 = <span class="number">1.12345678901F</span>;</span><br><span class="line">        <span class="keyword">double</span> num2 = <span class="number">1.123456789012121211232323123231</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> num3 = <span class="number">2.7</span>;</span><br><span class="line">        <span class="keyword">double</span> num4 = <span class="number">8.1</span>/<span class="number">3</span>;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(num4);</span><br><span class="line"></span><br><span class="line">        System.out.println(num3-num4);</span><br><span class="line">        <span class="comment">//那如何比较两个小数是否相等呢？</span></span><br><span class="line">        <span class="comment">//显然if(num3==num4)肯定是不可取的</span></span><br><span class="line">        <span class="comment">//当比较的两小数的绝对值在默认相等的范围内，即可认为两数相等</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(num3-num4)&lt;<span class="number">0.000001</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;差值在默认范围内，可以认为相等！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1.1234568</span></span><br><span class="line"><span class="comment">    1.1234567890121212</span></span><br><span class="line"><span class="comment">    2.7</span></span><br><span class="line"><span class="comment">    2.6999999999999997</span></span><br><span class="line"><span class="comment">    4.440892098500626E-16</span></span><br><span class="line"><span class="comment">    差值在默认范围内，可以认为相等！！！</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符类型</p>
<p>字符型可以表示单个字符，字符类型是char，两个字节（可以存放汉字），多个字符我们用字符串String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;韩&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c4 = <span class="number">97</span>;<span class="comment">//当输出c4时，会输出97表示的字符</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符类型使用细节</p>
<ol>
<li>字符常量是用单引号（‘’）括起来的单个字符</li>
<li>Java中还允许使用转义字符‘ \ ‘来将其后的字符转变为特殊字符型常量</li>
<li>在Java中，char的本质是一个整数，在输出时，是unicode码对应的字符</li>
<li>可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</li>
<li>char类型是可以进行运算的，相当于一个整数，因为它都对应有unicode码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> char1 = <span class="string">&#x27;b&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)char1);<span class="comment">//99</span></span><br><span class="line">        System.out.println(char1);<span class="comment">//c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符类型本质探讨</p>
<p>字符型存储到计算机中，需要将字符对应的码值（整数）找出来，比如‘a’</p>
<p>存储：‘a’——&gt;码值97——&gt;二进制——&gt;存储</p>
<p>读取：二进制——&gt;97——&gt;’a’——&gt;显示</p>
<p>字符和码值的对应关系是通过字符编码集决定的</p>
</li>
<li><p>介绍一下字符编码集</p>
<p>ASCII编码集（一个字节表示，一共128个字符，实际上一个字符可以表示256个字符，只用128个）</p>
<ul>
<li>ASCII码：上世纪60年代，美国制定了一套字符编码（是用一个字节），对英语字符与二进制之间的关系做了统一规范，这被称为ASCII码，ASCII码一共规定了128个字符的编码，只占用了一个字节的后面7位，最前面的1位统一规定为0</li>
<li>缺点：不能表示所有字符</li>
</ul>
<p>unicode（固定大小的编码，使用两个字节来表示字符，字母和汉字统一占用两个字节，这样浪费空间）</p>
<p>utf-8（编码表，大小可变的编码，字母是用一个字节，汉字是用三个字节）</p>
<p>gbk（可以表示汉字，而且范围广，字母是用一个字节，汉字两个字节）</p>
<p>gb2312（可以表示汉字，gb2312&lt;gbk）</p>
<p>big5码（繁体中文，台湾，香港）</p>
</li>
</ul>
</li>
<li><p>布尔类型：boolean</p>
<ol>
<li><p>布尔类型也叫boolean类型，boolean类型只允许取值true和false，无null</p>
</li>
<li><p>boolean类型占一个字节</p>
</li>
<li><p>boolean类型适于逻辑运算，一般用于程序流程控制：</p>
<p>if条件控制语句；</p>
<p>while循环控制语句；</p>
<p>do-while循环控制语句；</p>
<p>for循环控制语句</p>
</li>
</ol>
<ul>
<li><p>使用细节说明</p>
<p>不可以用0或非0的整数替代false和true，这点和C语言不同</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul>
<li><p>自动类型转换</p>
<p>当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这就是自动类型转换</p>
<p>数据类型按精度（容量）大小排序为（背，规则）：</p>
<p>byte——&gt;short——&gt;int——&gt;long——&gt;float——&gt;double</p>
<p>char——&gt;int——&gt;long——&gt;float——&gt;double</p>
</li>
<li><p>自动类型转换注意和细节</p>
<ol>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行运算</p>
</li>
<li><p>当我们把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换</p>
</li>
<li><p>（byte、short）和char之间不会相互自动转换</p>
</li>
<li><p>byte、short、char他们三者可以计算，在计算时首先转换为int类型</p>
</li>
<li><p>boolean不参与运算</p>
</li>
<li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当把具体数赋给byte时，先判断该数是否在byte范围内，如果是就可以</span></span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">10</span>;</span><br><span class="line">======================</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//错，b2 + s1 =&gt; int</span></span><br><span class="line"><span class="keyword">short</span> = b2 + s1;</span><br><span class="line">======================</span><br><span class="line"><span class="keyword">byte</span> b3 = <span class="number">2</span>; </span><br><span class="line"><span class="comment">//错，b2 + b3 =&gt; int</span></span><br><span class="line"><span class="keyword">byte</span> b4 = b2 + b3;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>强制类型转换</p>
<p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符（），但可能造成精度降低或溢出，格外要注意。</p>
</li>
<li><p>强制类型转换细节说明</p>
<ol>
<li><p>当进行数据的大小    从大——&gt;小，就需要使用强制转换</p>
</li>
<li><p>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int x = (int)10*3.5+6*1.5;</span></span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>)(<span class="number">10</span>*<span class="number">3.5</span>+<span class="number">6</span>*<span class="number">1.5</span>);</span><br><span class="line">System.out.println(y);</span><br></pre></td></tr></table></figure></li>
<li><p>char类型可以保存int的常量值，但不能保存int的变量值，需要强转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = m;<span class="comment">//错</span></span><br><span class="line"><span class="keyword">char</span> c3 = (<span class="keyword">int</span>)m;</span><br><span class="line">System.out.println(c3);<span class="comment">//100对应的字符</span></span><br></pre></td></tr></table></figure></li>
<li><p>byte和short类型在进行运算时，当做int类型处理</p>
</li>
</ol>
</li>
<li><p>基本数据类型和String类型的转换</p>
<ul>
<li><p>介绍</p>
<p>在程序开发中，我们经常需要将基本数据类型转成String类型，或者将String类型转成基本数据类型</p>
</li>
<li><p>基本类型转String类型</p>
<p>语法：将基本类型的值+“”即可</p>
</li>
<li><p>String类型转基本数据类型</p>
<p>语法：通过基本数据类型的包装类用parseXX方法即可</p>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如我们可以把“123”，转成一个整数，但是不能把“hello”转成一个整数</li>
<li>如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理</li>
</ul>
</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符是对数值类型的变量进行运算的，在Java程序中使用的非常多</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\算术运算符.png"/>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	讲解以下除号/和取模%和自增++</span></span><br><span class="line">System.out.println(<span class="number">10</span>/<span class="number">4</span>);<span class="comment">//2</span></span><br><span class="line">System.out.println(<span class="number">10.0</span>/<span class="number">4</span>);<span class="comment">//2.5</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10</span> / <span class="number">4</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取模的本质：a%b = a-a/b*b</span></span><br><span class="line"><span class="comment">//当a是小数时：a%b = a-(int)a/b*b;</span></span><br><span class="line"><span class="comment">//注意：有小数参与运算，得到的结果是近似值</span></span><br><span class="line">System.out.println(<span class="number">10</span>%<span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span>%<span class="number">3</span>);<span class="comment">//-1</span></span><br><span class="line">System.out.println(<span class="number">10</span>%-<span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span>%-<span class="number">3</span>);<span class="comment">//-1</span></span><br><span class="line">System.out.println(-<span class="number">10.5</span>%<span class="number">3</span>);<span class="comment">//-1.5    </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">作为独立的语句使用：</span></span><br><span class="line"><span class="comment">前++和后++完全等价于i=i+1</span></span><br><span class="line"><span class="comment">作为表达式使用</span></span><br><span class="line"><span class="comment">前++：++i先自增后赋值</span></span><br><span class="line"><span class="comment">后++：i++先赋值后自增</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、面试题1</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = i++;<span class="comment">//规则使用临时变量——&gt;1)temp = i 2)i = i+1 3)i = temp;</span></span><br><span class="line">System.out.println(i);<span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、面试题2</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = ++i;<span class="comment">//i=i+1;temp=i;i=temp;</span></span><br><span class="line">System.out.println(i);<span class="comment">//输出2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、题三</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">66</span>；</span><br><span class="line">System.out.println(++i+i);<span class="comment">//134</span></span><br></pre></td></tr></table></figure>

<h2 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h2><ul>
<li><p>介绍</p>
<ul>
<li><p>关系运算符的结果都是boolean型，也就是要么是true，要么是false</p>
</li>
<li><p>关系表达式经常用在if结构的条件中或循环结构的条件中</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\关系运算符.png"/></li>
</ul>
</li>
<li><p>细节说明</p>
<ul>
<li>关系运算符的结果都是boolean型，也就是要么是true，要么是false</li>
<li>关系运算符组成的表达式，我们称为关系表达式，如：a&gt;b</li>
<li>比较运算符“==”不能误写成“=”</li>
</ul>
</li>
</ul>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>用于连接多个条件（多个表达式），最终的结果也是一个boolean值</p>
<ul>
<li><p>逻辑运算符一览</p>
<ul>
<li><p>短路与&amp;&amp;，短路或||，取反！</p>
</li>
<li><p>逻辑与&amp;，逻辑或|，逻辑异或^</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\逻辑运算符.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\逻辑运算规则.png"/></li>
</ul>
</li>
<li><p>&amp;&amp;和&amp;使用区别</p>
<ul>
<li>&amp;&amp;短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高</li>
<li>&amp;逻辑与：不管第一个条件是否为false，第二个条件都会判断，效率低</li>
<li>开发中，我们使用的基本是短路与&amp;&amp;，效率高</li>
</ul>
</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li><p>介绍</p>
<p>赋值运算符就是将某个运算后的值，赋给指定的变量</p>
</li>
<li><p>赋值运算符的分类</p>
<ul>
<li><p>基本赋值运算符</p>
<p>=</p>
<p>int a = 1；</p>
</li>
<li><p>复合赋值运算符</p>
<p>+=    -=    /=    *=    %=等，重点讲解一个+=，其他的使用是一个道理</p>
<p>a += b;等价于a = a+b;</p>
</li>
</ul>
</li>
<li><p>案例演示</p>
<p>外皮巴普</p>
</li>
<li><p>赋值运算符特点</p>
<ul>
<li><p>运算顺序从右往左 int num = a+b+c；</p>
</li>
<li><p>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值</p>
</li>
<li><p>复合赋值运算符等价于下面的效果</p>
<p>a += 3;等价于a = a+3;</p>
</li>
<li><p>复合赋值运算符会进行类型转换</p>
<p>byte b = 2；b += 3；b++；</p>
<p>其中b += 3；没有问题，等价于b = (byte)(b+3)；</p>
<p>b++；等价于b = (byte)(b+1);</p>
</li>
</ul>
</li>
</ul>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ul>
<li><p>基本语法</p>
<p>条件表达式？表达式1：表达式2；</p>
<ol>
<li>如果条件表达式为true，运算后的结果是表达式1；</li>
<li>如果条件表达式为false，运算后的结果是表达式2</li>
</ol>
</li>
<li><p>案例演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> res = a&gt;b?a++:b--;</span><br><span class="line">System.out.println(res);<span class="comment">//99</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用细节</p>
<ul>
<li>表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转型）</li>
<li>三元运算符可以转换成if–else语句</li>
</ul>
</li>
</ul>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ol>
<li><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优于下一行</p>
</li>
<li><p>只有单目运算符、赋值运算符是从右向左运算的</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\优先级.png"/>

<ul>
<li>（）, {}等</li>
<li>单目运算符 ++ –</li>
<li>算术运算符</li>
<li>位移运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>三元运算符</li>
<li>赋值运算符</li>
</ul>
</li>
</ol>
<h2 id="标识符的命名规则和规范"><a href="#标识符的命名规则和规范" class="headerlink" title="标识符的命名规则和规范"></a>标识符的命名规则和规范</h2><ul>
<li><p>标识符概念</p>
<ol>
<li>Java对各种变量、方法和类等命名时使用的字符序列称为标识符</li>
<li>凡是自己可以起名字的地方都叫标识符</li>
</ol>
</li>
<li><p>标识符的命名规则（必须遵守）</p>
<ol>
<li>由26个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>Java中严格区分大小写，长度无限制</li>
<li>标识符不能包含空格</li>
</ol>
</li>
<li><p>标识符命名规范（更加专业）</p>
<ol>
<li><p>包名：多单词组成时，所有字母都小写</p>
</li>
<li><p>类名、接口名：多单词组成时，所有单词的首字母大写【大驼峰法】</p>
</li>
<li><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写【小驼峰法、驼峰法】</p>
</li>
<li><p>常量名：所有字母都大写。多单词时每个单词用下划线连接</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\关键字.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\关键字2.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\保留字.png"/></li>
</ol>
</li>
<li><p>键盘输入语句</p>
<ul>
<li><p>介绍</p>
<p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取</p>
</li>
<li><p>步骤</p>
<ol>
<li>导入该类的所在包，java.util.*</li>
<li>创建该类对象（声明变量）</li>
<li>调用里面的功能</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\进制介绍.png"/>

<ul>
<li>原码、反码、补码（重点 难点）<ol>
<li>二进制的最高位是符号位：0表示正数，1表示负数</li>
<li>正数的原码、反码、补码都一样（三码合一）</li>
<li>负数的反码 等价于  它的原码符号位不变，其他位取反</li>
<li>负数的补码  等价于  它的反码+1</li>
<li>0的反码、补码都是0</li>
<li>Java没有无符号数，换言之，Java中的数都是有符号的</li>
<li>在计算机运行时，都是以补码的方式来运算的</li>
<li>当我们看运算结果的时候，要看他的原码（重点）</li>
</ol>
</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java中有7个位运算符（&amp;、|、^、~、&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;）</p>
<p>按位异或：两位一个为0，一个为1，结果为1，否则为0（不同为true，C语言中的非0）</p>
<p>计算题：2&amp;3、~-2、 ~2、2|3、2^3</p>
<p>整型2:</p>
<p>原补反：00000000 00000000 00000000 00000010</p>
<p>整型3：</p>
<p>原补反：00000000 00000000 00000000 00000011</p>
<p>2&amp;3：</p>
<p>00000000 00000000 00000000 00000010（2）</p>
<p>2|3：</p>
<p>00000000 00000000 00000000 00000011（3）</p>
<p>2^3：</p>
<p>00000000 00000000 00000000 00000001（1）</p>
<p>整型-2：</p>
<p>原码：10000000 00000000 00000000 00000010</p>
<p>反码：11111111 11111111 11111111 11111101</p>
<p>补码：11111111 11111111 11111111 11111110</p>
<p>运算：00000000 00000000 00000000 00000001</p>
<p>原补反合一，故    ~-2 == 1</p>
<p>2：</p>
<p>原补反：00000000 00000000 00000000 0010</p>
<p>​    取反：11111111 11111111 11111111 1101</p>
<p>结果补码：11111111 11111111 11111111 1101</p>
<p>结果反码：11111111 11111111 11111111 1100</p>
<p>结果原码：10000000 00000000 00000000 0011（-3）</p>
<p>故（~2）== -3</p>
<ul>
<li>还有三个位运算符&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;，运算规则：<ol>
<li>算术右移&gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位</li>
<li>算术左移&lt;&lt;：符号位不变，低位补0</li>
<li>逻辑右移&gt;&gt;&gt;：也叫无符号右移，运算规则是：低位溢出，高位补0</li>
<li>特别说明：没有&lt;&lt;&lt;符号</li>
</ol>
</li>
</ul>
<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><p>在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程</p>
<ol>
<li>顺序控制</li>
<li>分支控制</li>
<li>循环控制</li>
</ol>
<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>程序从上到下逐行地执行，中间没有任何判断和跳转</p>
<h2 id="分支（if-else-switch）"><a href="#分支（if-else-switch）" class="headerlink" title="分支（if else switch）"></a>分支（if else switch）</h2><ul>
<li><p>分支控制if-else介绍</p>
<p>让程序有选择的执行，分支控制有三种</p>
<ol>
<li>单分支</li>
<li>双分支</li>
<li>多分支</li>
</ol>
</li>
<li><p>单分支</p>
<p>基本语法</p>
<p>if(条件表达式){</p>
<p>​        执行代码块；（可以有多条语句）</p>
<p>}</p>
<p>说明：当条件表达式为true时，就会执行{}的代码块，如果为false，就不执行，特别说明，如果{}中只有一条语句，则可以不用{}，建议写上{}</p>
</li>
<li><p>双分支</p>
<p>基本语法</p>
<p>if（条件表达式）{</p>
<p>​    执行代码块1；</p>
<p>}else{</p>
<p>​    执行代码块2；</p>
<p>}</p>
<p>说明：当条件表达式成立，即执行代码块1，否则执行代码块2，如果执行代码块只有一条语句，则{}可以省略，否则，不能省略</p>
</li>
<li><p>多分支</p>
<p>基本语法</p>
<p>if（条件表达式1）{</p>
<p>​    执行代码块1；</p>
<p>}else if{</p>
<p>​    执行代码块2；</p>
<p>}</p>
<p>…………</p>
<p>else{</p>
<p>​    执行代码块n；</p>
<p>}</p>
<ul>
<li><p>嵌套分支</p>
<ul>
<li><p>基本介绍</p>
<p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支，外面的分支结构称为外层分支。规范：不要超过3层（可读性不好）</p>
</li>
<li><p>基本语法</p>
<p>if(){</p>
<p>​    if(){</p>
<p>​    }else{</p>
<p>​    }</p>
<p>}</p>
</li>
</ul>
</li>
</ul>
<p>示意图：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\多分支.png"/></li>
<li><p>switch分支结构</p>
<ul>
<li><p>基本语法</p>
<p>switch（表达式）{</p>
<p>​    case 常量1：</p>
<p>​        语句块1；</p>
<p>​        break；</p>
<p>​    case 常量2：</p>
<p>​        语句块2；</p>
<p>​        break；    </p>
<p>​    ………………</p>
<p>​    default:</p>
<p>​        default语句块；</p>
<p>​        break；</p>
<p>}</p>
</li>
</ul>
<ol>
<li>switch关键字，表示switch分支</li>
<li>表达式对应一个值</li>
<li>case 常量1：当表达式的值等于常量1，就执行语句块1</li>
<li>break：表示退出switch</li>
<li>如果和case常量1匹配。就执行语句块1，如果没有匹配，就继续匹配case常量2</li>
<li>如果一个都没有匹配上，执行default</li>
</ol>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\switch.png"/></li>
<li><p>switch注意事项和使用细节</p>
<ol>
<li>表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是int</li>
<li>switch（表达式）中表达式的返回值必须是：（byte、short、int、char、enum、String）</li>
<li>case子句中的值必须是常量，而不能是变量</li>
<li>default子句是可选的，当没有匹配的case时，执行default</li>
<li>break语句用来执行完一个case分支后，使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾</li>
</ol>
</li>
<li><p>switch和if的比较</p>
<ol>
<li>如果判断的具体数值不多，而且符合byte、short、int、char、enum、String这6这类型。虽然两个语句都可以使用，建议使用switch</li>
<li>其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更加广</li>
</ol>
</li>
</ul>
<h2 id="循环（for，while，do-while）"><a href="#循环（for，while，do-while）" class="headerlink" title="循环（for，while，do while）"></a>循环（for，while，do while）</h2><ul>
<li><p>for循环控制</p>
<p>基本介绍：听其名而知其意，就是让你的代码可以循环的执行</p>
<p>基本语法：</p>
<p>for（循环变量初始化；循环条件；循环变量迭代）{</p>
<p>​    循环操作（语句）；</p>
<p>}</p>
<p>说明：</p>
<ol>
<li>for关键字，表示循环控制</li>
<li>for有四要素：1）循环变量初始化2）循环条件3）循环操作4）循环变量迭代</li>
<li>循环操作，这里可以有多条语句，也就是我们要循环执行的代码</li>
<li>如果循环操作（语句）只有一句语句，可以省略{}，建议不要省略</li>
</ol>
<p>注意事项和细节说明：</p>
<ol>
<li>循环条件是返回一个布尔值的表达式</li>
<li>for（；循环判断条件；）中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略</li>
<li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for的死循环写法</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>while循环控制</p>
<p>循环变量初始化；</p>
<p>while（循环条件）{</p>
<p>​    循环体（语句）；</p>
<p>​    循环变量迭代；</p>
<p>}</p>
<p>说明：</p>
<ol>
<li>while循环也有四个要素</li>
<li>只是四要素放的位置不一样</li>
</ol>
</li>
<li><p>do……while循环控制</p>
<p>循环变量初始化；</p>
<p>do{</p>
<p>​    循环体（语句）；</p>
<p>​    循环变量迭代；</p>
<p>}while（循环条件）；</p>
<p>说明：</p>
<ol>
<li>do while是关键字</li>
<li>也有循环四要素。只是位置不一样</li>
<li>最后有一个分号</li>
<li>while和do……while区别，举例：要账</li>
</ol>
</li>
</ul>
<h2 id="跳转控制语句-break"><a href="#跳转控制语句-break" class="headerlink" title="跳转控制语句-break"></a>跳转控制语句-break</h2><ul>
<li><p>基本介绍</p>
<p>break语句用于终止某个语句块的执行，一般使用在switch或者循环【for、while、do-while】中</p>
</li>
<li><p>基本语法</p>
<p>{</p>
<p>​    ……</p>
<p>​    break；</p>
<p>​    ……</p>
<p>}</p>
</li>
<li><p>注意事项和使用细节</p>
<ol>
<li><p>break语句出现在多次嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</p>
</li>
<li><p>标签的基本使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    label2:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> label1;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>break语句可以指定退出哪层</li>
<li>label1是标签，由程序员指定</li>
<li>break后指定哪个label就退出哪里</li>
<li>在实际的开发中，尽量不要使用标签</li>
<li>如果没有指定break，默认推出最近的循环体</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句-continue"></a>跳转控制语句-continue</h2><ul>
<li><p>基本介绍</p>
<ol>
<li>continue语句用于结束本次循环，继续执行下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的使用规则一样</li>
</ol>
</li>
<li><p>基本语法：</p>
<p>{</p>
<p>​    ……</p>
<p>​    continue;</p>
<p>​    ……</p>
<p>}</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\continue例题.png"/></li>
</ul>
<h2 id="跳转控制语句-return"><a href="#跳转控制语句-return" class="headerlink" title="跳转控制语句-return"></a>跳转控制语句-return</h2><p>return使用在方法里，表示跳出所在的方法，在讲解方法的时候，会详细讲解</p>
<p>注意：return写在main方法里，退出程序</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h2><p>数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用数据类型，即数组就是一组数据</p>
<h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><ul>
<li><p>使用方式1-动态初始化</p>
<ol>
<li><p>数组的定义</p>
<p>数据类型    数组名【】 = new    数据类型【大小】</p>
<p>int    a[]    =    new    int[5]；//创建了一个数组，名字a，存放了5个int类型的数据</p>
</li>
<li><p>数组的引用（使用）</p>
<p>数组名【下标/索引】</p>
</li>
<li><p>快速入门</p>
<p>外皮巴普</p>
</li>
</ol>
</li>
<li><p>使用方式2-动态初始化</p>
<ol>
<li><p>先声明数组</p>
<p>语法：数组类型    数组名【】；也可以    数组类型【】 数组名；</p>
</li>
<li><p>创建数组</p>
<p>语法：数组名    =    new    数组类型【大小】；</p>
</li>
</ol>
</li>
<li><p>使用方式3-静态初始化</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\数组静态初始化.png"/></li>
<li><p>数组使用注意事项和使用细节</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\数组使用细节.png"/></li>
<li><p>数组的赋值机制</p>
<ol>
<li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</li>
<li>数组在默认情况下是引用传递，赋的是地址</li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4c80a972aedb">图解Java数组的内存分配 - 简书 (jianshu.com)</a></p>
<h2 id="数组的拷贝、反转、扩容、缩减"><a href="#数组的拷贝、反转、扩容、缩减" class="headerlink" title="数组的拷贝、反转、扩容、缩减"></a>数组的拷贝、反转、扩容、缩减</h2><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li><p>使用方式1：动态初始化</p>
<ol>
<li>语法：类型【】【】    数组名 = new 类型【大小】【大小】；</li>
<li>二维数组在内存中的存在形式</li>
</ol>
</li>
<li><p>使用方式2：动态初始化</p>
<p>先声明再定义赋值</p>
</li>
</ul>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\二维数组的内存分析.png"/>

<ul>
<li><p>使用方式3：动态初始化-列数不确定</p>
<p>二维数组即“数组数组”，一个存放数组的数组，当列数不确定时，数组也是对象嘛，里面的数组默认为null，抛开列数的概念，里面存放的数组的长度是可以不同的</p>
</li>
<li><p>使用方式4：静态初始化</p>
<p>直接对二维数组赋值即可</p>
</li>
<li><p>二维数组的使用细节和注意事项</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\二维数组的使用细节.png"/></li>
</ul>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>一个程序就是一个世界，有很多事物</p>
<ol>
<li>类就是数据类型，比如Cat</li>
<li>对象就是一个具体的实例</li>
</ol>
<ul>
<li><p>对象在内存中的存在形式（重要的）</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\对象在内存中的形式.png"/></li>
<li><p>属性/成员变量</p>
<ul>
<li><p>基本介绍</p>
<ol>
<li>从概念或叫法上看：成员变量 = 属性 = field</li>
<li>属性是类的一个组成部分，一般是基本数据类型，也可以是引用数据类型（对象，数组）。</li>
</ol>
</li>
<li><p>注意事项和细节说明</p>
<ol>
<li>属性的定义语法同变量，示例：访问修饰符    属性类型    属性名；</li>
<li>属性的定义类型可以为任意类型，包含基本类型或引用类型</li>
<li>属性如果不赋值，有默认值，规则和数组一致。具体而言：byte 0，short 0，int 0，long 0，float 0.0，double 0.0，boolean false，char \u0000，String null</li>
</ol>
</li>
</ul>
</li>
<li><p>如何创建对象</p>
<ol>
<li><p>先声明再创建</p>
<p>Cat cat；</p>
<p>cat = new Cat（）；</p>
</li>
<li><p>直接创建</p>
<p>Cat cat = new Cat();</p>
</li>
</ol>
</li>
<li><p>如何访问属性</p>
<p>基本语法：对象名.属性名；</p>
</li>
<li><p>类与对象的分配机制（重要）</p>
<ul>
<li><p>Java内存的结构分析</p>
<ol>
<li><p>栈：一般存放基本数据类型（局部变量）</p>
</li>
<li><p>堆：存放对象（Cat cat，数组等）</p>
</li>
<li><p>方法区：常量池（常量，比如字符串），类加载信息</p>
</li>
<li><p>示意图</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\对象的内存分析.png"/></li>
</ol>
</li>
<li><p>Java创建对象的简单流程分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先加载Person类信息（属性和方法信息，只加载一次）</li>
<li>在堆中分配空间，进行默认初始化（看规则）、显式初始化、构造器初始化</li>
<li>把地址赋给person，person指向对象</li>
<li>进行指定初始化，比如p.name = “Jack” p.age = 10</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p>基本介绍</p>
<p>在某些情况下，我们定义成员方法（简称方法）。比如人类：除了一些属性外，我们人类还有一些行为：可以说话，跑步等</p>
</li>
<li><p>成员方法快速入门</p>
<p>在Person类中添加方法</p>
</li>
<li><p>方法调用机制原理【重要】</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\方法的调用机制.png"/>

<ol>
<li>当程序执行到方法时，就会开辟一个独立的栈空间，执行方法</li>
<li>当方法执行结束或者遇到return时，就会返回</li>
<li>返回到调用方法的地方</li>
<li>返回后，继续执行方法后面的代码</li>
<li>当main方法（栈）执行完毕后，整个程序也就结束</li>
</ol>
</li>
<li><p>为什么需要成员方法（好处）</p>
<ol>
<li>提高代码的复用性</li>
<li>可以将实现的细节封装起来，然后供其他用户来调用即可。</li>
</ol>
</li>
<li><p>成员方法的定义</p>
<ol>
<li>形参列表：表示成员方法输入</li>
<li>数据类型（返回类型）：表示成员方法输出，void表示没有返回值</li>
<li>方法主体：表示为了实现某一功能代码块</li>
<li>return语句不是必须的</li>
</ol>
</li>
<li><p>注意事项和使用细节</p>
<ol>
<li><p>修饰符（作用是控制方法使用的范围）</p>
</li>
<li><p>返回类型</p>
<ul>
<li>一个方法最多有一个返回值</li>
<li>返回类型可以为任意类型，包含基本类型或引用类型（数组、对象）</li>
<li>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return值；而且要求返回类型必须和return的值类型一致或兼容</li>
<li>如果方法是void，则方法体中可以没有return语句，或者只写return；</li>
</ul>
</li>
<li><p>方法名</p>
<p>遵循驼峰命名法，最好见名知义，表达出该功能的意思即可</p>
</li>
<li><p>参数列表</p>
<ul>
<li>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开</li>
<li>参数类型可以为任意类型，包含基本类型或引出类型</li>
<li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li>
<li>方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致</li>
</ul>
</li>
<li><p>方法体</p>
<p>里面写完成功能的具体语句，可以为输出、输入、变量、运算、分支、循环、方法调用，但是不能再定义方法！即方法不能嵌套定义。</p>
</li>
<li><p>方法调用细节说明</p>
<ul>
<li>同一个类中的方法调用：直接调用即可</li>
<li>跨类中的方法调用：需要通过对象名调用</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h3><p>方法的传参机制对我们今后的编程非常重要，一定要搞的清清楚楚</p>
<ul>
<li><p>基本数据类型的传参机制</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\传参有效范围测试.png"/>

<p>结论：基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！</p>
</li>
<li><p>引用数据类型的传参机制</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\方法形参传递.png"/>

<p>结论：引用数据类型传递的是地址（传递的也是值，但是值是地址），可以通过形参影响实参！</p>
</li>
</ul>
<h3 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h3><ul>
<li><p>基本介绍</p>
<p>Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致</p>
</li>
<li><p>重载的好处</p>
<ol>
<li>减轻了起名的麻烦</li>
<li>减轻了记名的麻烦</li>
</ol>
</li>
<li><p>注意事项和使用细节</p>
<ol>
<li>方法名：必须相同</li>
<li>参数列表：必须不同（参数类型或个数顺序，至少有一样不同，参数名无要求）</li>
<li>返回类型：无要求</li>
</ol>
</li>
</ul>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li><p>基本概念</p>
<p>Java允许将同一个类中的多个同名功能但参数个数不同的方法封装成一个方法</p>
</li>
<li><p>基本语法</p>
<p>访问修饰符    返回值    方法名（数据类型**…**    形参名）{</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVariablePar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VariablePar variablePar = <span class="keyword">new</span> VariablePar();</span><br><span class="line">        <span class="keyword">int</span> res = variablePar.sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariablePar</span></span>&#123;</span><br><span class="line">    <span class="comment">//int... 表示接收的是可变参数，类型是int，即可以接受多个int（0~n）</span></span><br><span class="line">    <span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以当作数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项和使用细节</p>
<ol>
<li>可变参数的实参可以为0个或任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li>
<li>一个形参列表中只能出现一个可变参数</li>
</ol>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><p>基本使用</p>
<p>面向对象中，变量作用域是非常重要的知识点</p>
<ol>
<li><p>在Java编程中，主要的变量就是属性（成员变量）和局部变量。</p>
</li>
<li><p>我们说的局部变量一般是指成员方法中定义的变量</p>
</li>
<li><p>Java中作用域的分类</p>
<p>全局变量：也就是属性，作用域为整个类体</p>
<p>局部变量：也就是除了属性之外的其他变量，作用域为定义他的代码块中！</p>
</li>
<li><p>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</p>
</li>
</ol>
</li>
<li><p>注意事项和细节使用</p>
<ol>
<li><p>属性和局部变量可以重名，访问时遵循就近原则</p>
</li>
<li><p>在同一个作用域中，比如在同一个成员方法中，两个局部变量不能重名</p>
</li>
<li><p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的消亡而消亡，局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。</p>
</li>
<li><p>作用域范围不同</p>
<p>全局变量/属性：可以被本类使用，或其它类使用（通过对象调用）</p>
<p>局部变量：只能在本类中对应的方法中使用</p>
</li>
<li><p>修饰符不同</p>
<p>全局变量/属性可以加修饰符</p>
<p>局部变量不可以加修饰符</p>
</li>
</ol>
</li>
</ul>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li><p>引入</p>
<p>我们来看一个需求：在创建人类对象时，就直接指定这个对象的年龄和姓名，该怎么做？这时就可以使用构造器</p>
</li>
<li><p>基本介绍</p>
<p>构造方法又叫构造器（Constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的初始化，它有几个特点：</p>
<ol>
<li>方法名和类名相同</li>
<li>没有返回值</li>
<li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li>
</ol>
</li>
<li><p>基本语法</p>
<p>【修饰符】    方法名（形参列表）{</p>
<p>​            方法体；</p>
<p>}</p>
<p>说明：</p>
<ol>
<li>构造器的修饰符可以默认</li>
<li>构造器没有返回值</li>
<li>方法名和类名必须一样</li>
<li>参数列表和成员方法一样的原则</li>
<li>构造器的调用系统完成</li>
</ol>
</li>
<li><p>注意事项和使用细节</p>
<ol>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器名和类名相同</li>
<li>构造器没有返回值</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>在创建对象时，系统自动的调用该类的构造方法</li>
<li>如果程序员没有定义构造器方法，系统会自动给类生成一个默认无参构造方法（也叫默认构造方法），使用javap指令反编译看看</li>
<li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式地定义一下</li>
</ol>
</li>
<li><p>对象创建的流程分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程分析：</p>
<p>一个堆、栈、方法区、常量池的模型</p>
<p>先在方法区加载Person.class的相关信息，只会加载一次</p>
<p>new的时候在堆中开辟一块空间（地址），创建对象</p>
<p>对属性和方法进行默认初始化    ——&gt;    name = null；age = 0</p>
<p>然后再类里属性的信息进行显式的初始化    ——&gt;    name = null；age = 90</p>
<p>根据构造器进行初始化    ——&gt;    name = “小明”；age = 12</p>
<p>将对象在堆中的地址返回给person（栈中的对象名指向对象）</p>
</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li><p>什么是this</p>
<p>Java虚拟机会给每个对象分配this，代表当前对象</p>
<p>简单地说，哪个对象调用，this就代表哪个对象</p>
</li>
<li><p>this的使用</p>
<p>使用this可以解决构造器中局部变量的问题</p>
</li>
<li><p>this的注意事项和使用细节</p>
<ol>
<li>this关键字可以用来访问本类的属性、构造器和方法</li>
<li>this关键字用来区分当前类的属性和局部变量</li>
<li>访问成员方法的语法：this.方法名（参数列表）</li>
<li>访问构造器语法：this（参数列表）；注意只能在构造器中使用（只能在一个构造器中调用另一个构造器）</li>
<li>this不能再类定义的外部使用，只能在类定义的方法中使用</li>
</ol>
</li>
</ul>
<p>tips：</p>
<ul>
<li>recursive：adj.递归的</li>
<li>invovation：n.调用</li>
</ul>
<h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><ul>
<li>IDEA快捷键<ol>
<li>ctrl+d：删除当前行</li>
<li>ctrl+alt+向下的光标：复制当前行</li>
<li>alt+/：补全代码</li>
<li>ctrl+/：添加注释和取消注释</li>
<li>导入该行需要的类： 先配置auto import，然后使用alt+enter即可</li>
<li>ctrl+shift+L：快速格式化代码</li>
<li>alt+insert：生成构造方法等</li>
<li>ctrl+H：查看一个类的层级关系</li>
<li>ctrl+J：显示所有快捷键</li>
<li>ctrl+B：将光标放在一个方法上，输入ctrl+B，可以选择定位到哪个类的方法</li>
<li>.var：自动的分配变量名，通过在后面.var</li>
<li>ctrl+Alt+t：包裹代码</li>
<li>itit：快速建立迭代器</li>
</ol>
</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul>
<li><p>场景引入</p>
<p>现有两个程序员，小明和小强，共同开发一个Java项目，两人都想定义一个名为Dog的类，两人为此还吵了起来，怎么办呢？</p>
<p>=+=+=+=+====&gt;包</p>
</li>
<li><p>包的三大作用</p>
<ul>
<li>区分相同名字的类</li>
<li>当类很多时，可以很好的管理类【看Java API文档】</li>
<li>控制访问范围</li>
</ul>
</li>
<li><p>包的基本语法</p>
<p>package com.hspedu;</p>
<ul>
<li>pcakage：关键字，表示打包</li>
<li>com.hspedu：表示包名</li>
</ul>
</li>
<li><p>包的本质分析（原理）</p>
<p>包的本质：实际上就是创建不同的文件夹来保存类文件</p>
</li>
<li><p>快速入门</p>
<p>使用打包技术来解决上面的问题，不同包下Dog类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pcakage com.xiaoming;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaoqiang.Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        com.xiaoming.Dog dog1 = <span class="keyword">new</span> com.xiaoming.Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>包的命名</p>
<ul>
<li><p>命名规则</p>
<p>只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</p>
</li>
<li><p>命名规范</p>
<p>一般是小写字母+小圆点</p>
<p>com.公司名.项目名.业务模块名</p>
<p>比如：</p>
<p>com.sina.crm.user    //用户模块</p>
<p>com.sina.crm.order    //订单名</p>
<p>com.sina.crm.utils    //工具类</p>
</li>
</ul>
</li>
<li><p>常用的包</p>
<p>一个包下，包含很多的类。Java中常用的包有：</p>
<p>java.lang.*    //lang包是基本包，默认引入，不需要再引入</p>
<p>java.util.*    //util包，系统提供的工具包，工具类，Scanner</p>
<p>java.net.*    //网络包，网络开发</p>
<p>java.awt.*    //是做Java的界面开发，GUI</p>
</li>
<li><p>如何引入包</p>
<p>语法：import 包；</p>
<p>我们引入一个包的主要目的是要使用该包下的类</p>
<p>比如：import java.util.Scanner;    就是引入一个类Scanner</p>
<p>​            import java.util.*;        表示将java.util所有包都引入</p>
<p>案例：使用系统提供的Arrays完成数组排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">123</span>,<span class="number">33</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		Arrays.sort(arr);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.print(arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项和使用细节</p>
<ul>
<li>package的作用是声明当前类所在的包，需要放在class的最上面，一个类中最多只有一句package</li>
<li>import指令位置放在package下面，在类定义前面，可以有多句且没有顺序要求。</li>
</ul>
</li>
</ul>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li><p>基本介绍</p>
<p>Java提供四种访问控制修饰符号来控制方法和属性（成员变量）的访问权限（范围）：</p>
<ol>
<li>公开级别：用public修饰，对外公开</li>
<li>受保护级别：用protected修饰，对子类和同一包中的类公开</li>
<li>默认级别：没有修饰符号，向同一个包的类公开</li>
<li>私有级别：用private修饰，只有类本身可以访问</li>
</ol>
</li>
<li><p>4种访问修饰符的访问范围</p>
<table>
<thead>
<tr>
<th align="center">访问级别</th>
<th align="center">访问控制修饰符</th>
<th align="center">同类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">不同包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公开</td>
<td align="center">public</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">受保护</td>
<td align="center">protected</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">没有修饰符</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">私有</td>
<td align="center">private</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody></table>
</li>
<li><p>使用的注意事项</p>
<ol>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li>
<li>继承相关</li>
<li>成员方法的访问规则和属性完全一样</li>
</ol>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><p>封装介绍</p>
<p>封装（encapsulation）就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作。</p>
<p>对电视机的操作就是典型封装，输入一个参数返回一个结果</p>
</li>
<li><p>封装的理解和好处</p>
<ol>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
</ol>
</li>
<li><p>封装的步骤</p>
<ol>
<li>将属性进行私有化private【不能直接修改属性】</li>
<li>提供一个公共的（public）Set方法，用于对属性判断并赋值</li>
<li>提供一个公共的（public）Get方法，用于获取属性的值</li>
<li>构造器+Set方法 做预处理</li>
</ol>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>为什么需要继承？</p>
<p>代码复用</p>
</li>
<li><p>继承基本介绍和示意图</p>
<p>继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\继承.png"/></li>
<li><p>继承的基本语法</p>
<p>class 子类 extends 父类{</p>
<p>}</p>
<ol>
<li>子类会自动拥有父类定义的属性和方法</li>
<li>父类又称超类、基类</li>
<li>子类又叫派生类</li>
</ol>
</li>
<li><p>继承给编程带来的便利</p>
<ol>
<li>代码的复用性提高了</li>
<li>代码的扩展性和维护性提高了</li>
</ol>
</li>
<li><p>继承的深入讨论/细节问题</p>
<ol>
<li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问</p>
</li>
<li><p>子类必须调用父类的构造器，完成父类的初始化</p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super()去指定使用父类的哪个构造器完成对父类的初始化，否则编译不会通过。</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)</p>
</li>
<li><p>super只能在构造器中使用，且需要放在构造器的第一行</p>
</li>
<li><p>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>Java所有类都是Object的子类，Object是所有类的基类</p>
<p><strong>CTRL+h：可以看到类的继承关系</strong></p>
</li>
<li><p>父类构造器的调用不限于直接父类！可以一直往上追溯到Object类（顶级父类）</p>
</li>
<li><p>子类最多只能继承一个父类（指直接继承），即Java中是单继承机制</p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p>
</li>
</ol>
</li>
<li><p>继承的本质分析（重要）</p>
<p>案例：当子类继承父类，创建子类对象时，内存中到底发生了什么？提示：当子类对象建造好后，建立查找关系</p>
</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li><p>基本介绍</p>
<p>super代表父类的引用，用于访问父类的属性、方法、构造器</p>
</li>
<li><p>基本语法</p>
<ol>
<li><p>访问父类的属性，但不能访问父类的private属性</p>
<p>super.属性名；</p>
</li>
<li><p>访问父类的方法，不能访问父类的private方法</p>
<p>super.方法名（参数列表）；</p>
</li>
<li><p>访问父类的构造器：</p>
<p>super（参数列表）；只能放在构造器的第一句，只能出现一句！</p>
</li>
</ol>
</li>
<li><p>super给编程带来的便利/细节</p>
<ol>
<li>调用父类的构造器的好处（分工明确，父类属性有父类初始化，子类的属性由子类初始化）</li>
<li>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！</li>
<li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。A&gt;B&gt;C</li>
</ol>
</li>
<li><p>super和this的比较</p>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">访问属性</td>
<td align="center">访问本类中的属性，如果本类没有此属性，则从父类中继续查找</td>
<td align="center">从父类中查找有无该属性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">调用方法</td>
<td align="center">访问本类中的方法，如果本类没有此方法，则从父类中继续查找</td>
<td align="center">从父类中查找有无该方法</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">调用构造器</td>
<td align="center">调用本类构造器，必须放在构造器的首行</td>
<td align="center">调用父类构造器，必须放在子类构造器的首行</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">特殊</td>
<td align="center">表示当前对象</td>
<td align="center">子类中访问父类对象</td>
</tr>
</tbody></table>
<p>tips：</p>
<p>一个类是如何找调用的方法的：</p>
<ol>
<li><p>先找本类，如果有，则直接调用</p>
</li>
<li><p>如果没有则找父类（如果有，并可以调用，则调用）</p>
</li>
<li><p>如果父类没有，则继续找父类的父类，整个规则，就是一样的，直到Object类</p>
</li>
<li><p>如果查找方法的过程中，找到了，但不能访问，则报错，cannot access</p>
</li>
<li><p>如果最终没有找到，则提示方法不存在</p>
</li>
<li><p>cal（）== this.cal（）</p>
</li>
<li><p>super.cal()：直接从父类开始找</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\继承的内存布局.png"/></li>
</ol>
</li>
</ul>
<h3 id="override（覆盖）"><a href="#override（覆盖）" class="headerlink" title="override（覆盖）"></a>override（覆盖）</h3><ul>
<li><p>基本介绍</p>
<p>简单的说：方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法</p>
</li>
<li><p>注意事项和使用细节</p>
<p>方法重写也叫方法覆盖，需要满足下面的条件</p>
<ol>
<li>子类的方法的参数、方法名称，要和父类方法的参数、方法名称完全一样</li>
<li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回类型是Object，子类方法返回类型是String</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ol>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><p>多态基本介绍</p>
<p>方法或者对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的</p>
</li>
<li><p>多态的具体体现</p>
<ol>
<li><p>方法的多态</p>
<p>重载和覆盖就体现多态</p>
</li>
<li><p>对象的多态（核心、困难、重点）</p>
<ul>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的</li>
<li>编译类型看定义时 = 号的左边，运行类型看 = 号的右边</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();<span class="comment">//animal编译类型是Animal，运行类型Dog</span></span><br><span class="line">animal = <span class="keyword">new</span> Cat();<span class="comment">//animal的运行类型变成了Cat，但编译类型仍然是Animal</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>多态注意事项和细节讨论</p>
<p>多态的前提：两个对象（类）存在继承关系</p>
<p>多态的向上转型</p>
<ol>
<li><p>本质：父类的引用指向了子类的对象</p>
</li>
<li><p>语法：父类类型   引用名 =  new     子类类型（）；</p>
</li>
<li><p>特点：编译类型看左边，运行类型看右边</p>
<p>可以调用父类中的所有成员（需遵守访问权限）</p>
<p>不能调用子类中特有成员</p>
<p>最终效果看子类的具体实现！</p>
</li>
</ol>
<p>多态的向下转型</p>
<ol>
<li>语法：子类类型    引用名    =    （子类类型）父类引用；</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>可以调用子类类型中所有的成员</li>
</ol>
<p>属性的值看编译类型</p>
<p>instanceof比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</p>
</li>
<li><p><strong>Java的动态绑定机制（非常非常重要）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="comment">//问：</span></span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(a.sum());<span class="comment">//?——&gt;40</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//?——&gt;30</span></span><br><span class="line"><span class="comment">//问：B类中的方法sum()注销后</span></span><br><span class="line"><span class="comment">//a.sum()调用到父类A的方法sum(),此时在A中有方法getI(),该方法指向哪儿呢？</span></span><br><span class="line"><span class="comment">//引出动态绑定机制：</span></span><br><span class="line"><span class="comment">//1.当调用对象方法的时候，该方法会和对象的内存地址/运行类型绑定</span></span><br><span class="line"><span class="comment">//2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</span></span><br><span class="line"><span class="comment">//getI（）指向运行类型，也就是B类的方法</span></span><br><span class="line"><span class="comment">//则有结果</span></span><br><span class="line">System.out.println(a.sum());<span class="comment">//?——&gt;20+10=30</span></span><br><span class="line"><span class="comment">//问：而注销B类中的sum1（）后</span></span><br><span class="line"><span class="comment">//属性的调用没有动态绑定机制，则有结果</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//?——&gt;10+10=20</span></span><br></pre></td></tr></table></figure></li>
<li><p>多态的应用</p>
<ol>
<li><p>多态数组</p>
<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
</li>
<li><p>多态参数</p>
<p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p>
</li>
</ol>
</li>
</ul>
<h3 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h3><ul>
<li><p>equals方法</p>
<ol>
<li><p>==：既可以判断基本类型，又可以判断引用类型</p>
</li>
<li><p>==：如果判断基本类型，判断的是值是否相等</p>
</li>
<li><p>==：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象</p>
</li>
<li><p>equals：是Objects类中的方法，只能判断引用类型</p>
</li>
<li><p>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，比如：Integer、String</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\question1.png"/></li>
</ol>
</li>
<li><p>hashCode方法</p>
<ol>
<li>提高具有哈希结构的容器效率</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li>
<li>两个引用，如果指向的是不同的对象，则哈希值是不一样的</li>
<li>哈希值主要根据地址号来的，不能完全将哈希值等价于地址</li>
<li>后面在集合中的hashCode（）如果需要的话，也会重写</li>
</ol>
</li>
<li><p>toString方法</p>
<ul>
<li><p>基本介绍：</p>
<p>默认返回：全类名+@+哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息</p>
</li>
<li><p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</p>
</li>
<li><p>当直接输出一个对象时，toString方法会被默认的调用</p>
</li>
</ul>
</li>
<li><p>finalize方法</p>
<ul>
<li><p>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，贼JVM就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法</p>
</li>
<li><p>垃圾回收机制的调用是由系统决定的，也可以通过System.gc()主动触发垃圾回收机制</p>
</li>
<li><p>老韩提示：我们在实际开发中几乎不会运用finalize方法，为了应付面试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalize_</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Car car = <span class="keyword">new</span> Car();</span><br><span class="line">		car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		System.gc();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;程序结束。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;回收就车辆。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="断点调试（debug）"><a href="#断点调试（debug）" class="headerlink" title="断点调试（debug）"></a>断点调试（debug）</h3><ul>
<li><p>一个实际需求</p>
<ol>
<li>在开发中，新手程序员在查找错误时，老程序员会温馨提示，可以用断电调试，一步步看源码执行过程，从而发现错误所在。</li>
<li>重要提示：在断点调试过程中，是运行状态，是以对象的运行类型执行的。</li>
</ol>
</li>
<li><p>断点调试介绍</p>
<ol>
<li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停止，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下，进行分析从而找到这个Bug</li>
<li>断点调试也是程序员必须掌握的技能。</li>
<li>断点调试也能帮助我们查看Java底层源代码的执行过程，提高程序员的Java水平。</li>
</ol>
</li>
<li><p>断点调试的快捷键：</p>
<p>F7（跳入）    F8（跳过）    shift+F8（跳出）    F9（resume，执行到下一个断点）</p>
<p>F7：跳入方法内</p>
<p>F8：逐行执行代码</p>
<p>shift+F8：跳出方法</p>
</li>
<li><p>断点调试应用案例</p>
<p>巴拉巴拉，歪比巴卜</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\断点调试.png"/>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjd_hycf_space/p/7483471.html">IDEA调试总结（设置断点进行调试） - fcyh - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="类变量与类方法"><a href="#类变量与类方法" class="headerlink" title="类变量与类方法"></a>类变量与类方法</h3><ul>
<li><p>什么是变量</p>
<p>类变量也叫静态变量、静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量</p>
</li>
<li><p>如何定义变量</p>
<p>定义语法：</p>
<p>访问修饰符    static    数据类型    变量名；【推荐】</p>
<p>static    访问修饰符    数据类型    变量名；</p>
</li>
<li><p>如何访问类变量</p>
<p>类名.类变量【类变量是随着类加载而创建的，所以即使没有创建对象实例也可以访问】</p>
<p>或者对象名.类变量名【静态变量的访问修饰符的访问权限和范围华人普通属性是一样的】</p>
<p>推荐使用：类名.类变量名</p>
</li>
<li><p>类变量的内存布局</p>
<p>有些书上说在方法区，…………jdk版本有关系，</p>
<p>记住一点：static变量是对象共享，不管static变量在哪里，</p>
<p>共识1、static变量是同一个类所有对象共享</p>
<p>共识2、static变量在类加载的时候就生成了</p>
</li>
<li><p>类变量使用注意事项和细节讨论</p>
<ol>
<li><p>什么时候需要用类变量</p>
<p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p>
</li>
<li><p>类变量与实例变量的区别</p>
<p>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</p>
</li>
<li><p>加上static称为类变量或静态变量，否则称为实例变量、普通变量、非静态变量</p>
</li>
<li><p>类变量的生命周期随着类的加载开始，随着类消亡而销毁</p>
</li>
</ol>
</li>
</ul>
<p>类方法同理</p>
<ul>
<li><p>类方法经典的使用场景</p>
<p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率</p>
<p>比如：工具类的方法utils、Maths类、Arrays类、Collections集合类</p>
<p>小结：在程序员实际开发时，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象，就可以使用了，比如打印一维数组，排序算法等</p>
</li>
<li><p>类方法使用注意事项和细节讨论</p>
<ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区，类方法中无this参数，普通方法中隐含this的参数</li>
<li>类方法可以通过类名调用。也可以通过对象名调用</li>
<li>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</li>
<li>类方法中不允许使用和对象有关的关键字，比如this和super，普通方法（成员方法）可以</li>
<li>类方法（静态方法）中只能访问静态变量或静态方法</li>
<li>普通成员方法，既可以访问普通变量（方法），也可以访问静态变量（方法）</li>
</ol>
<p>小结：静态方法，只能访问静态的成员；非静态的方法，可以访问静态成员和非静态成员。（必须遵守访问权限）</p>
</li>
</ul>
<h3 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h3><ul>
<li><p>深入理解main方法</p>
<p>解释main方法的形式：public static void main（String【】 args）{}</p>
<ol>
<li>Java虚拟机需要调用类的main（）方法，所以该方法的访问权限必须是public</li>
<li>Java虚拟机在执行main（）方法时不必创建对象，所以该方法必须是static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数</li>
<li>Java     执行的程序    参数1    参数2     参数3</li>
</ol>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\main方法的参数列表.png"/></li>
<li><p>特别提示</p>
<ol>
<li>在main（）方法中，我们可以直接调用main方法所在类的静态方法或静态属性</li>
<li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li>
</ol>
<p>如何使用IDEA中的main方法的传参列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testmain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			System.out.println(args[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\main加入参数.png"/></li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\代码块.png"/>

<ul>
<li>代码块的好处<ol>
<li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>
<li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>
</ol>
</li>
</ul>
<p>代码块调用的顺序优先于构造器</p>
<ul>
<li><p>代码块的使用细节</p>
<ol>
<li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行</p>
</li>
<li><p>类什么时候被加载【重要】</p>
<ul>
<li>创建对象实例时（new）</li>
<li>创建子类对象实例，父类也会被加载</li>
<li>使用类的静态成员时（静态属性、静态方法）</li>
</ul>
</li>
<li><p>普通的代码块，在创建对象实例时，会被隐式的调用</p>
<p>被创建一次，就会调用一次</p>
<p>如果只是使用类的静态成员时，普通代码块并不会执行</p>
</li>
<li><p>创建一个对象时，在一个类调用顺序是：（重点难点）</p>
<ul>
<li>调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</li>
<li>调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</li>
<li>调用构造方法</li>
</ul>
</li>
<li><p>构造方法的最前面其实隐含了super（）和调用普通代码块</p>
</li>
<li><p>我们看一下创建一个子类时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</p>
<ul>
<li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和成员属性</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和成员属性</li>
<li>子类的构造方法</li>
</ul>
</li>
<li><p>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p>
</li>
</ol>
</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li><p>基本介绍</p>
<p>final：最后的、最终的</p>
<p>final可以修饰类、属性、方法和局部变量</p>
<p>在某些情况下，程序员可能有以下需求，就会使用final：</p>
<ol>
<li>当不希望类被继承时，可以使用final修饰</li>
<li>当不希望父类的某个方法被子类覆盖时，可以用final关键字修饰</li>
<li>当不希望类的某个属性的值被修改，可以用final修饰</li>
<li>当不希望某个局部变量被修改，可以使用final修饰</li>
</ol>
</li>
<li><p>final使用注意事项和细节讨论</p>
<ol>
<li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>
</li>
<li><p>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】：</p>
<ul>
<li><p>定义时：public final double TAX_RATE = 0.08;</p>
</li>
<li><p>在构造器中</p>
</li>
<li><p>在代码块中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE = <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE3;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TAX_RATE3 = <span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果final修饰的属性时静态的，则初始化的位置只能是</p>
<ul>
<li>定义时</li>
<li>在静态代码块可以，不能在构造器中赋值【根据加载顺序，静态属性会被先加载，如果在构造器中才赋初值的话，此时静态常量没有值，故不能在构造器中给静态常量赋值】</li>
</ul>
</li>
<li><p>final类不能继承，但是可以实例化对象</p>
</li>
<li><p>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</p>
</li>
<li><p>一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法</p>
</li>
<li><p>final不能修饰构造方法【即构造器】</p>
</li>
<li><p>final和static往往搭配使用，效率更高，底层编译器做了优化处理【不会导致类的加载】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(AA.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是静态代码块！！！&quot;</span>+num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>包装类（Integer、Double、Float、Boolean等都是final），String也是final类</p>
</li>
</ol>
<p>习题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">something</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//final可以放该位置</span></span><br><span class="line">		<span class="comment">//x++;//不行</span></span><br><span class="line">		<span class="keyword">return</span> x+<span class="number">1</span>;<span class="comment">//可以，常量x的值并没有发生改变</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>当父类的某些方法需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<ul>
<li><p>抽象类的介绍</p>
<ol>
<li><p>用abstract关键字来修饰一个类时，这个类就叫抽象类</p>
<p>访问修饰符    abstract    类名{}</p>
</li>
<li><p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p>
<p>访问修饰符    abstract    返回类型    方法名（参数列表）；//没有方法体</p>
</li>
<li><p>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类（）</p>
</li>
<li><p>抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多</p>
</li>
</ol>
</li>
<li><p>抽象类使用的细节事项和细节讨论</p>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</li>
<li>一旦类包含了abstract方法，则这个类必须声明为abstract</li>
<li>abstract只能修饰类和方法，不能修饰属性和其他的</li>
<li>抽象类可以有任意成员【因为抽象类还是类】，比如：非抽象方法、构造器、静态属性等</li>
<li>抽象方法不能有主体，即不能实现</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明abstract类</li>
<li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li>
</ol>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p>为什么有接口</p>
<p>usb插槽就是现实中的接口</p>
</li>
<li><p>基本介绍</p>
<p>接口就是给出一些没有实现的方法封装在一起，等到某个类要使用时，再根据具体情况把这些方法写出来，语法：</p>
<p>interface    接口名{</p>
<p>​    //属性</p>
<p>​    //方法（1、抽象方法    2、默认实现方法    3、静态方法）</p>
<p>}</p>
<p>class    类名    implements    接口{</p>
<p>​    自己的属性；</p>
<p>​    自己的方法；</p>
<p>​    必须实现的接口的抽象方法</p>
<p>}</p>
<p>在接口中，抽象方法可以省略abstract关键字</p>
<p>小结：</p>
<ol>
<li>在JDK7.0前，接口里的所有方法都没有方法体</li>
<li>JDK8.0后，接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</li>
</ol>
</li>
<li><p>注意事项和使用细节</p>
<ol>
<li><p>接口不能被实例化</p>
</li>
<li><p>接口中所有的方法是public方法，接口中抽象方法可以不用abstract修饰</p>
</li>
<li><p>一个普通抽象类实现接口，就必须将该接口的所有方法实现</p>
</li>
<li><p>抽象类实现接口，可以不用实现接口的方法</p>
</li>
<li><p>一个类同时可以实现多个接口</p>
</li>
<li><p>接口中的属性只能是final的，而且是public static final 修饰符。比如：int a=1；实际上是public static final int a = 1；（必须初始化）</p>
</li>
<li><p>接口中属性的访问形式：接口名.属性名</p>
</li>
<li><p>一个接口不能继承其他的类，但是可以继承多个别的接口</p>
<p>interface A extends B，C{}</p>
</li>
<li><p>接口的修饰符只能是public和默认，这点和类的修饰符是一样的</p>
</li>
</ol>
</li>
<li><p>实现接口VS继承类</p>
<p>接口和继承解决的问题不同</p>
<ul>
<li>继承的价值主要在于：解决代码的复用性和可维护性</li>
<li>接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法</li>
</ul>
<p>接口比继承更加灵活</p>
<ul>
<li>接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系</li>
</ul>
<p>接口在一定程度上实现了代码解耦【即：接口规范性+动态绑定】</p>
</li>
<li><p>接口的多态特性</p>
<ol>
<li>多态参数</li>
<li>多态数组</li>
<li>接口存在多态传递现象</li>
</ol>
</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li><p>基本介绍</p>
<p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
</li>
<li><p>基本语法</p>
<p>class    Outer{//外部类</p>
<p>​    class    Inner{//内部类</p>
<p>​    }</p>
<p>}</p>
<p>class    Other{//外部其他类</p>
<p>}</p>
</li>
<li><p>内部类的分类</p>
<ul>
<li>定义在外部类局部位置上（比如方法内）<ol>
<li>局部内部类（有类名）</li>
<li>匿名内部类（没有类名，重点！！！！！！！！！！！）</li>
</ol>
</li>
<li>定义在外部类的成员位置上<ol>
<li>成员内部类（没用static修饰）</li>
<li>静态内部类（使用static修饰）</li>
</ol>
</li>
</ul>
</li>
<li><p>局部内部类的使用</p>
<p>说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>
<ol>
<li><p>可以直接访问外部类的所有成员，包含私有的</p>
</li>
<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用访问修饰符的。但是可以使用final修饰，因为局部变量也可以使用final</p>
</li>
<li><p>作用域：仅仅在定义它的方法或代码块中</p>
</li>
<li><p>局部内部类——访问——&gt;外部类的成员【访问方式：直接访问】</p>
</li>
<li><p>外部类——访问——&gt;局部内部类的成员</p>
<p>访问方式：创建对象，再访问（注意：必须放在作用域内）</p>
</li>
<li><p>外部其他类——不能访问——&gt;局部内部类（因为局部内部类地位是一个局部变量）</p>
</li>
<li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问【Outer02.this本质就是外部类的对象，即哪个对象调用m1，Outer02.this就是哪个对象】</p>
</li>
</ol>
<p>记住：</p>
<ol>
<li>局部内部类定义在方法中/代码块</li>
<li>作用域在方法体或者代码块中</li>
<li>本质仍然是一个类</li>
</ol>
</li>
<li><p>匿名内部类的使用【重要！！！】</p>
<p>【1、本质是类    2、内部类    3、该类没有名字    4、同时还是一个对象】</p>
<p>说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名</p>
<ol>
<li><p>匿名内部类的基本语法</p>
<p>new 类或接口（参数列表）{</p>
<p>​    类体</p>
<p>};</p>
</li>
<li><p>匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，因此可以直接调用匿名内部类方法。</p>
</li>
<li><p>可以直接访问外部类的所有成员，包括私有的</p>
</li>
<li><p>不能添加访问修饰符，因为它的定位就是一个局部变量</p>
</li>
<li><p>作用域：仅仅在定义他的方法或代码块中</p>
</li>
<li><p>外部其他类不能访问匿名内部类（因为匿名内部类地位是一个局部变量）</p>
</li>
<li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类.this.成员）去访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是局部内部类！！！&quot;</span>+<span class="string">&quot;就近原则访问方法里的属性：&quot;</span>+i+<span class="string">&quot;访问外部类的属性&quot;</span>+Outer.<span class="keyword">this</span>.i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.hi();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="comment">//tiger的编译类型是IA</span></span><br><span class="line">        <span class="comment">//tiger的运行类型是Outer$1</span></span><br><span class="line">        IA tiger = <span class="keyword">new</span> IA()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.shout();</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型：&quot;</span>+tiger.getClass());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> IA()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小狗叫！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.shout();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>匿名内部类的最佳实践</p>
<p>当做实参直接传递，简洁高效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(AA a)</span> </span>&#123;</span><br><span class="line">		a.cry();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		show(<span class="keyword">new</span> AA() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;隔壁王大爷在吃面条~~&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成员内部类的使用</p>
<p>说明：成员内部类是定义在外部类的成员位置，并且没有static修饰</p>
<ol>
<li><p>可以直接访问外部类的所有成员，包含私有的</p>
</li>
<li><p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员。</p>
</li>
<li><p>作用域</p>
<p>和外部类的其他成员一样，为整个类体</p>
</li>
<li><p>成员内部类——访问——&gt;外部类（比如：属性）【访问方式：直接访问】</p>
</li>
<li><p>外部类——访问——&gt;内部类【访问方式：创建对象，再访问】</p>
</li>
<li><p>外部其他类——访问——&gt;成员内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他外部类访问Outer的内部类</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner1 inner1 = outer.<span class="function">new <span class="title">Inner1</span><span class="params">()</span></span>;</span><br><span class="line">inner1.say();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">Outer.Inner1 inner11 = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner1</span><span class="params">()</span></span>;</span><br><span class="line">inner11.say();</span><br><span class="line"><span class="comment">//方式三:使用一个方法来获取，更加简洁</span></span><br><span class="line">Outer.Inner1 inner3 = outer.getInstance();</span><br><span class="line">inner3.say();</span><br></pre></td></tr></table></figure></li>
<li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类.this.成员）去访问</p>
</li>
</ol>
</li>
<li><p>静态内部类</p>
<p>说明：静态内部类是定义再外部类的成员位置，并且有static修饰</p>
<ol>
<li><p>可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问非静态成员</p>
</li>
<li><p>可以添加任意访问修饰符（private、默认、protected、public），因为它的地位就是一个成员</p>
</li>
<li><p>作用域：同其他的成员一样，为整个类体</p>
</li>
<li><p>静态内部类——访问——&gt;外部类（比如：静态属性）【访问方式：直接访问】</p>
</li>
<li><p>外部类——访问——&gt;静态内部类【访问方式：创建对象，再访问】</p>
</li>
<li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问静态内部类</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">Outer.Inner2 inner1 = <span class="keyword">new</span> Outer.Inner2();</span><br><span class="line">inner1.say();</span><br><span class="line"><span class="comment">//方式二:编写一个方法返回静态内部类</span></span><br><span class="line">Outer.Inner2 instance2 = <span class="keyword">new</span> Outer().getInstance2();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><ol>
<li>枚举对应英文（enumeration，简称enum）</li>
<li>枚举是一组常量的集合</li>
<li>可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象</li>
<li>枚举的两种实现方式<ul>
<li>自定义实现枚举</li>
<li>使用enum关键字实现枚举</li>
</ul>
</li>
</ol>
<h2 id="自定义注解实现枚举"><a href="#自定义注解实现枚举" class="headerlink" title="自定义注解实现枚举"></a>自定义注解实现枚举</h2><ol>
<li>不需要提供setXXX方法，因为枚举对象值通常只读</li>
<li>对枚举对象/属性使用final+static共同修饰，实现底层优化。</li>
<li>枚举对象通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Season.SPRING.getSeason()+<span class="string">&quot;:&quot;</span>+Season.SPRING.getDesc());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String season;</span><br><span class="line">	<span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;和煦&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;丰收&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String season, String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.season = season;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> season;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>小结：进行自定义类实现枚举，有如下特点：<ul>
<li>构造器私有化</li>
<li>本类内部创建一组对象</li>
<li>对外暴露对象（通过为对象添加public final static 修饰符）</li>
<li>可以提供get方法，但是不要提供set</li>
</ul>
</li>
</ul>
<h2 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Season2.SPRING);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	SPRING(<span class="string">&quot;春&quot;</span>,<span class="string">&quot;和煦&quot;</span>),</span><br><span class="line">    <span class="comment">//WHAT,</span></span><br><span class="line">	SUMMER(<span class="string">&quot;夏&quot;</span>,<span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">	AUTUMN(<span class="string">&quot;春&quot;</span>,<span class="string">&quot;和煦&quot;</span>),</span><br><span class="line">	WINTER(<span class="string">&quot;春&quot;</span>,<span class="string">&quot;和煦&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String season;</span><br><span class="line">	<span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Season2()&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Season2</span><span class="params">(String season,String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.season = season;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> season;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Season2&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;season=&#x27;&quot;</span> + season + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用关键字enum替代class，当我们使用enum关键字开发一个枚举类时，默认会继承Enum类【如何证明】</p>
<p>反编译javap：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\枚举的继承.png"/></li>
<li><p>语句被简化，直接使用SPRING（”春天”,”温暖”），这里必须知道，它调用的是哪个构造器</p>
</li>
<li><p>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</p>
</li>
<li><p>如果有多个常量（对象），使用逗号（，）间隔即可，最后有一个分号结尾</p>
</li>
<li><p>如果使用enum来实现枚举，要求将定义常量对象，写在行首</p>
</li>
</ol>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\枚举练习.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\枚举练习2.png"/>

<ul>
<li><p>enum常用方法说明</p>
<p>说明：使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\enum常用方法.png"/></li>
<li><p>enum实现接口</p>
<ol>
<li><p>使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum，而Java是单继承机制</p>
</li>
<li><p>枚举类和普通类一样，可以实现接口，如下形式。</p>
<p>enum    类名    implements    接口1，接口2{}</p>
</li>
</ol>
</li>
</ul>
<h2 id="JDK内置的基本注解类型"><a href="#JDK内置的基本注解类型" class="headerlink" title="JDK内置的基本注解类型"></a>JDK内置的基本注解类型</h2><ol>
<li>注解（Annotation）也被称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</li>
<li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等</li>
</ol>
<ul>
<li><p>基本的Annotation介绍</p>
<p>使用Annotation时要在其前面加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素</p>
<p>三个基本的Annotation：</p>
<ul>
<li><p>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</p>
<ul>
<li>@Override表示指定重写父类的方法（从编译层面验证，如果父类没有对应的方法，则会报错）</li>
<li>如果不写@Override注解，而父类仍有对父类方法重写的方法，仍然构成重写</li>
<li>@Override只能修饰方法，不能修饰其他类、包、属性等</li>
<li>查看@Override注解源码为@Target（ElementType.METHOD），说明只能修饰方法</li>
<li>@Target是修饰注解的注解，称为元注解</li>
</ul>
</li>
<li><p>@Deprecated：用于表示某个程序元素（类、方法等）已过时</p>
<ul>
<li><p>可以修饰方法、类、字段、包、参数等</p>
</li>
<li><p>@Deprecated的作用可以做到新旧版本的兼容和过渡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@SuppressWarnings：抑制编译器警告</p>
<ul>
<li>unchecked：忽略没有检查的警告</li>
<li>rawtypes：忽略没有指定泛型的警告（传参时没有指定泛型的警告错误）</li>
<li>unused：忽略没有使用某个变量的警告错误</li>
<li>生成@SuppressWarnings时，不用背，直接点击左侧的黄色提示，就可以选择（注意可以指定生成的位置）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="元注解：对注解进行注解"><a href="#元注解：对注解进行注解" class="headerlink" title="元注解：对注解进行注解"></a>元注解：对注解进行注解</h2><ul>
<li><p>元注解的基本介绍</p>
<p>JDK的元Annotation用于修饰其他Annotation</p>
<p>元注解：本身作用不大，将这个原因是希望同学们看源码时，可以知道它是干什么的</p>
</li>
<li><p>元注解的种类（使用不多，了解，不用深入研究）</p>
<ul>
<li><p>Retention     //指定注解的作用范围，三种SOURCE、CLASS、RUNTIME</p>
<ul>
<li><p>说明</p>
<p>只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间</p>
<p>@Retention包含一个RetentionPolicy类型的成员变量，使用@Retention时，必须为该value成员变量指定值</p>
</li>
<li><p>Retention的三种值</p>
<ol>
<li>RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注解</li>
<li>RetentionPolicy.CLASS：编译器将把注释记录在class文件中，当运行Java程序时，JVM不会保留注解，这是默认值</li>
<li>RetentionPolicy.RUNTIME：编译器将把注释记录在class文件中，当运行Java程序时，JVM会保留注释，程序可以通过反射获取该注释</li>
</ol>
<p>说明：Override的作用域在SOURCE，当编译器编译时生效，不会写入到.class文件，也不会再runtime（运行时）生效</p>
</li>
</ul>
</li>
<li><p>Target        //指定注解可以在哪些地方使用</p>
<p>用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素，@Target也包含一个名为value的成员变量</p>
</li>
<li><p>Documented        //指定该注解是否会在javadoc体现</p>
<p>用于指定被该元注解修饰的Annotation类将被javadoc工具提取成文档，即在生成文档时，可以看到该注解</p>
<p>说明：定义为Documented的注解必须设置Retention值为RUNTIME</p>
</li>
<li><p>Inherited    //子类会继承父类注解</p>
<p>被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p>
<p>说明：实际应用中，使用较少，了解即可</p>
</li>
</ul>
</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h2><ul>
<li><p>基本概念</p>
<p>Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p>
</li>
<li><p>执行过程中所发生的异常事件可分为两类</p>
<ol>
<li>Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError【栈溢出】和OOM（out of memory），Error是严重错误，程序会崩溃。</li>
<li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等，Exception分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】。</li>
</ol>
</li>
</ul>
<h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\异常的继承.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\异常体系图.png"/>

<ul>
<li>异常体系图的小结<ol>
<li>异常分为两大类，运行时异常和编译时异常</li>
<li>运行时异常，编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常</li>
<li>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li>
<li>编译时异常是编译器要求必须处理的异常</li>
</ol>
</li>
</ul>
<h2 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h2><ul>
<li><p>运行时异常</p>
<ol>
<li><p>NullPointerException空指针异常</p>
<p>当应用程序试图在需要对象的地方使用null时</p>
</li>
<li><p>ArithmeticException数学运算异常</p>
<p>当出现异常的运行条件时，抛出异常，例如，一个整数除以零时</p>
</li>
<li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p>
<p>用非法索引访问数组时抛出的异常，如果索引为负或大于等于数组大小，则该索引为非法索引</p>
</li>
<li><p>ClassCastException类型转换异常</p>
<p>当试图将对象强制转换为不是实例的子类时，抛出异常</p>
</li>
<li><p>NumberFormatException数字格式不正确异常</p>
<p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出异常 =&gt; 使用异常我们可以确保输入是满足条件的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">Double d = Double.parseDouble(s);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>编译时异常</p>
<ul>
<li><p>介绍</p>
<p>编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译，一般发生在<strong>网络、数据库、文件操作时</strong></p>
</li>
<li><p>常见的编译异常</p>
<ol>
<li>SQLException     //操作数据库时，查询表可能发生的异常</li>
<li>IOException     //操作文件时，发生的异常</li>
<li>FileNotFoundException     //当操作一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException     //加载类而该类不存在时，异常</li>
<li>EOFException     //操作文件，到文件末尾，发生异常</li>
<li>IllegalArguementException     //参数异常</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>基本介绍</p>
<p>异常处理就是当异常发生时，对异常处理的方式</p>
</li>
<li><p>异常处理的方式</p>
<ol>
<li><p>try-catch-finally</p>
<p>程序员在代码中捕获发生的异常，自行处理</p>
</li>
<li><p>throws</p>
<p>将发生的异常抛出，交给调用者（方法）来处理，最顶尖的处理者就是JVM（将异常抛给上一级处理）</p>
<p>默认采用throws方法</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\throws处理异常的方式.png"/></li>
</ol>
</li>
<li><p>try-catch异常处理</p>
<ol>
<li><p>Java提供try和catch块来处理异常，try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个数量的try·····catch块</p>
</li>
<li><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可疑代码</span></span><br><span class="line">	<span class="comment">//将异常生成对应的异常对象，传递给catch块</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>（异常）&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对异常的处理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</li>
<li>如果异常没有发生，则顺序执行try的代码块，不会进入到catch</li>
<li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用finally{}</li>
</ul>
</li>
</ol>
</li>
<li><p>throws异常处理</p>
<ol>
<li>如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式的声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li>
</ol>
</li>
<li><p>throws注意事项和使用细节</p>
<ol>
<li>对于编译异常，程序中必须处理，比如try-catch或者throws</li>
<li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li>
<li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常的类型的子类型</li>
<li>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</li>
</ol>
</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li><p>基本概念</p>
<p>当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理。这个时候可以自己设计异常类，用于描述该错误信息</p>
</li>
<li><p>自定义异常的步骤</p>
<ol>
<li>定义类：自定义异常类名（程序员自己写）继承Exception或RuntimeException</li>
<li>如果继承Exception，属于编译异常</li>
<li>如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）</li>
</ol>
</li>
</ul>
<h2 id="throw和throws的对比"><a href="#throw和throws的对比" class="headerlink" title="throw和throws的对比"></a>throw和throws的对比</h2><ul>
<li><p>一览表</p>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>包装类的分类</p>
<ol>
<li><p>针对八种基本定义相应的引用类型——包装类(Wrapper)</p>
</li>
<li><p>有了类的特点，就可以调用类中的方法</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
</tbody></table>
<p>包装类的继承体系：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\包装类1.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\包装类2.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\包装类3.png"/></li>
</ol>
</li>
<li><p>包装类和基本数据类型的转换</p>
<ol>
<li><p>jdk5前，手动装箱和拆箱，装箱：基本类型——&gt;包装类型，反之，拆箱</p>
</li>
<li><p>jdk5（含jdk5）后，自动装箱和拆箱方式</p>
</li>
<li><p>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">Integer integer1 = <span class="keyword">new</span> Integer(n1);<span class="comment">//方式一</span></span><br><span class="line">Integer integer2 = Integer.valueOf(n1);<span class="comment">//方式二</span></span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = integer1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">100</span>;</span><br><span class="line">Integer integer3 = n2;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> n3 = integer3;</span><br></pre></td></tr></table></figure>

<p>习题：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\包装类习题1.png"/></li>
</ol>
</li>
<li><p>包装类型和String类型的互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类型——&gt;String类型</span></span><br><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line">String s1 = i.toString();<span class="comment">//方式一</span></span><br><span class="line">String s2 = String.valueOf(i);<span class="comment">//方式二</span></span><br><span class="line">String s3 = i+<span class="string">&quot;&quot;</span>;<span class="comment">//方式三：对i本身的值无影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String类型——&gt;包装类</span></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(s1);<span class="comment">//方式1</span></span><br><span class="line">Integer j2 = Integer.valueOf(s2);<span class="comment">//方式2</span></span><br></pre></td></tr></table></figure></li>
<li><p>Integer和Character类的常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE);</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符包装类Character</span></span><br><span class="line"><span class="comment">//判断是不是字母</span></span><br><span class="line">System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是数字</span></span><br><span class="line">System.out.println(Character.isDigit(<span class="string">&#x27;1&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是大写</span></span><br><span class="line">System.out.println(Character.isUpperCase(<span class="string">&#x27;W&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是小写</span></span><br><span class="line">System.out.println(Character.isLowerCase(<span class="string">&#x27;q&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是空格</span></span><br><span class="line">System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line"><span class="comment">//转成大写</span></span><br><span class="line">System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">//转成小写</span></span><br><span class="line">System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>习题：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\包装类习题2.png"/>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            ······························</span><br><span class="line">            ······························</span><br></pre></td></tr></table></figure>

<p>习题：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\包装类练习3.png"/></li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li><p>String类的理解和创建对象</p>
<ol>
<li><p>String对象用于保存字符串，也就是一组字符序列</p>
</li>
<li><p>字符串常量对象是用双引号括起的字符序列，例如：“你好”、“12.12”、“boy”等</p>
</li>
<li><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p>
</li>
<li><p>String类比较常用的构造方法（其他看手册）：</p>
<ul>
<li>String str1 = new String（）；</li>
<li>String str2 = new String（String original）；</li>
<li>String str3 = new String（char【】 a）；</li>
<li>String str4 = new String（char【】 a，int startIndex，int count）；</li>
<li>String str5 = new String（byte【】 b）；</li>
</ul>
</li>
<li><p>String类实现了接口Serializable【String可以串行化：可以在网络传输】</p>
<p>String类实现了接口Comparable【String对象可以比较大小】</p>
</li>
<li><p>String是final类，不能被其他的类继承</p>
</li>
<li><p>String有属性private final char value【】，用于存放字符串内容，一个字符串对象一旦被分配，其内容是不可变的</p>
</li>
<li><p>一定要注意：value是一个final类型，不可以修改（重点:指向不能被修改）：即value不能指向新的地址，但是单个字符内容是可以变化的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">char</span>[] value = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>[] value2 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">value[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"><span class="comment">//value = value2;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>创建String对象的两种方式</p>
<ol>
<li>方式一：直接赋值   String s = “hsp”；</li>
<li>方式二：调用构造器   String s = new String（“hsp”）；</li>
</ol>
</li>
<li><p>两种创建String对象的区别</p>
<ol>
<li><p>方式一：先从常量池查看是否有“hsp”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p>
</li>
<li><p>方式二：先在堆中创建对象，里面维护了value属性，指向常量池的hsp空间。如果常量池没有“hsp”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\String的内存布局.png"/>

<p>习题：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\String练习3.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\String练习4.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\String练习5-1.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\String练习5.png"/></li>
</ol>
</li>
<li><p>String类的常用方法</p>
<p>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此，Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p>
<p>String类的常见方法一览：</p>
<ul>
<li>equals：区分大小写，判断内容是否相等</li>
<li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li>
<li>length：获取字符的个数，字符串的长度</li>
<li>indexOf：获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到，返回-1</li>
<li>lastIndexOf：获取字符在字符串中最后一次出现的索引，索引从0开始，如找不到，返回-1</li>
<li>substring：截取指定范围的子串</li>
<li>trim：去除前后空格</li>
<li>charAt：获取某索引处字符，注意不能使用Str【index】这种方式</li>
<li>toUpperCase：转换成大写</li>
<li>toLowerCase：转换成小写</li>
<li>concat：拼接字符串</li>
<li>replace：替换字符串中的字符</li>
<li>split：分割字符串，对于某些分割字符，我们需要转义</li>
<li>compareTo：比较两个字符串大小，如果前者大，则返回正数；后者大，则返回负数；相等返回0</li>
<li>toCharArray：将字符串转换成字符数组</li>
<li>format：格式字符串    占位符：%s【字符串】    %c【字符】      %d【整型】      %.2f【浮点型】</li>
</ul>
</li>
</ul>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul>
<li><p>基本介绍</p>
<ul>
<li>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</li>
<li>很多方法与String相同，但StringBuffer是可变长度的</li>
<li>StringBuffer是一个容器</li>
<li>StringBuffer的直接父类是AbstractStringBuilder</li>
<li>StringBuffer实现了Serialzable，即StringBuffer的对象可以串行化</li>
<li>在父类中AbstractStringBuilder有属性char【】 value，不是final</li>
<li>该value数组存放的字符串内容，放在堆中</li>
<li>StringBuffer是一个final类，不能被继承</li>
<li>String   VS   StringBuffer<ul>
<li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低      //private final char value[]</li>
<li>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高      //这个放在堆里</li>
</ul>
</li>
</ul>
</li>
<li><p>String和StringBuffer互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String ——&gt; StringBuffer：返回的才是StringBuffer对象，对str本身没有影响</span></span><br><span class="line">String s = <span class="string">&quot;qwer&quot;</span>;</span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(s);<span class="comment">//方式一</span></span><br><span class="line">StringBuffer stringBuffer1 = <span class="keyword">new</span> StringBuffer();<span class="comment">//方式二</span></span><br><span class="line">stringBuffer1.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer ——&gt; String</span></span><br><span class="line">String s1 = stringBuffer.toString();<span class="comment">//方式一</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(s1);<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li>
<li><p>StringBuffer的常见方法</p>
<ul>
<li>append：增</li>
<li>delete（start，end）：删除</li>
<li>replace（start，end，string）：将start——end间 [start，end）的内容替换掉，不含end</li>
<li>indexOf：查找子串在字符串第一次出现的索引，如果找不到返回-1</li>
<li>insert：插入</li>
<li>length：获取长度</li>
</ul>
</li>
<li><p>练习</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\StringBuffer练习1.png"/></li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><ul>
<li><p>基本介绍</p>
<ul>
<li>一个不是线程安全的、可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步，该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候，如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快</li>
<li>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以便接收任意类型的数据。</li>
<li>StringBuilder继承AbstractStringBuilder类</li>
<li>实现了Serialzable，说明StingBuilder对象是可以串行化（对象可以网络传输，可以保存文件）</li>
<li>StringBuilder是final类，不能被继承</li>
<li>StringBuilder对象字符序列仍然是存放在其父类AbstractStringBuilder的char【】 final，因此，字符序列在堆中</li>
<li>StringBuilder的方法，没有做互斥的处理，即没有synchronized关键字，因此在单线程的情况下使用</li>
</ul>
</li>
<li><p>String、StringBuffer和StringBuilder的比较</p>
<ol>
<li><p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p>
</li>
<li><p>String：不可变字符序列，效率低，但是复用率高</p>
</li>
<li><p>StringBuffer：可变字符序列、效率较高（增删）、线程安全</p>
</li>
<li><p>StringBuilder：可变字符序列、效率最高、线程不安全</p>
</li>
<li><p>String使用注意说明：</p>
<p>String s=“a”；//创建了一个字符串</p>
<p>s += “b”；//实际上原来的“a”字符串对象已经被遗弃，现在又产生了一个字符串s+“b”（也就是“ab”），如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能==&gt;结论：如果我们对String做大量修改，不要使用String</p>
</li>
</ol>
</li>
<li><p>String、StringBuffer和StringBuilder的选择</p>
<p>使用的原则，结论：</p>
<ol>
<li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li>
<li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li>
<li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li>
<li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li>
</ol>
</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul>
<li><p>基本介绍</p>
<p>Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数</p>
</li>
<li><p>方法一览（均为静态方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;abs:绝对值&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> abs = Math.abs(-<span class="number">12.1</span>);</span><br><span class="line">System.out.println(abs);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;ceil:向上转型&quot;</span>);</span><br><span class="line">System.out.println(Math.ceil(<span class="number">12.1</span>));</span><br><span class="line">System.out.println(Math.ceil(<span class="number">12.9</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;floor:向下转型&quot;</span>);</span><br><span class="line">System.out.println(Math.floor(<span class="number">12.1</span>));</span><br><span class="line">System.out.println(Math.floor(<span class="number">12.9</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;round:四舍五入&quot;</span>);</span><br><span class="line">System.out.println(Math.round(<span class="number">12.1</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">12.9</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;max:最大值&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> max = Math.max(<span class="number">12</span>, <span class="number">111</span>);</span><br><span class="line">System.out.println(max);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;函数曲线cos：输入x轴，返回y轴&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> cos = Math.cos(Math.PI);</span><br><span class="line">System.out.println(cos);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;sqrt:开方&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> sqrt = Math.sqrt(<span class="number">4</span>);</span><br><span class="line">System.out.println(sqrt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;pow:求幂&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> pow = Math.pow(<span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(pow);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;======= 随机数[0,1) 100次========&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">double</span> random = Math.random();</span><br><span class="line">   System.out.println(random);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回[2，7]之间的随机整数</span></span><br><span class="line"><span class="comment">//(int)(a + Math.random()*(b-a+1))</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">6</span> + <span class="number">2</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Date、Calendar、LocalDate…"><a href="#Date、Calendar、LocalDate…" class="headerlink" title="Date、Calendar、LocalDate…"></a>Date、Calendar、LocalDate…</h2><ul>
<li><p>第一代日期类</p>
<ol>
<li>Date：精确到毫秒，代表特定的瞬间</li>
<li>SimpleDateFormat：格式和解析日期的类，它允许进行格式化（日期——&gt;文本）、解析（文本——&gt;日期）和规范化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date1 = <span class="keyword">new</span> Date();<span class="comment">//获取当前的系统时间</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">43434</span>);<span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(date1.getTime());<span class="comment">//获得某个时间的对应毫秒数</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日	hh:mm:ss E&quot;</span>);</span><br><span class="line">String format = sdf.format(date1);</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;1923年01月23日	11:11:11 星期一&quot;</span>;</span><br><span class="line">Date date3 = sdf.parse(s);</span><br></pre></td></tr></table></figure>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\SimpleDateFormat字母定义.png"/></li>
<li><p>第二代日期类</p>
<ol>
<li><p>第二代日期类主要是Calendar类（日历）</p>
<p>public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt; Calender&gt;</p>
</li>
<li><p>Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Calendar没有提供对应的格式化的类，因此需要程序员自己组合</span></span><br><span class="line">Calendar instance = Calendar.getInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;年:&quot;</span>+instance.get(Calendar.YEAR));</span><br><span class="line">System.out.println(<span class="string">&quot;月:&quot;</span>+(instance.get(Calendar.MONTH)+<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;日:&quot;</span>+instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;时:&quot;</span>+instance.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(<span class="string">&quot;分:&quot;</span>+instance.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒:&quot;</span>+instance.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure></li>
<li><p>第三代日期类</p>
<p>JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用，而Calendar也存在问题：</p>
<ol>
<li>可变性</li>
<li>偏移性：Date中的年份从1900开始，而月份都是从0开始(month需要加1)</li>
<li>格式化：格式化对Date有用，Calendar则不行</li>
<li>此外，它们也不是线程安全的，不能处理闰秒等（每隔2天，多出1s）</li>
</ol>
<ul>
<li><p>第三代日期类常见方法</p>
<p>LocalDate（日期）、LocalTime（时间）、LocalDateTime（日期时间）JDK8加入</p>
<p>LocalDate只包含日期，可以获取日期字段</p>
<p>LocalTime只包含时间，可以获取时间字段</p>
<p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p>
</li>
<li><p>DateTimeFormatter格式日期类</p>
<p>类似于SimpleDateFormat</p>
</li>
<li><p>Instant时间戳</p>
<p>类似于Date</p>
<p>提供了一系列和Date类转换的方式</p>
</li>
<li><p>第三代日期类更多方法</p>
<ul>
<li>LocalDateTime类</li>
<li>MonthDay类：检查重复事件</li>
<li>是否是闰年</li>
<li>增加日期的某个部分</li>
<li>使用plus方法测试增加时间的某个部分</li>
<li>使用minus方法测试查看一年前和一年后的日期</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span>+localDateTime.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+localDateTime.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+localDateTime.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+localDateTime.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时：&quot;</span>+localDateTime.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分：&quot;</span>+localDateTime.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span>+localDateTime.getSecond());</span><br><span class="line"></span><br><span class="line"><span class="comment">//DateTimeFormatter</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;</span>);</span><br><span class="line">String format1 = dateTimeFormatter.format(localDateTime);</span><br><span class="line">System.out.println(format1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳Instant</span></span><br><span class="line">Instant now = Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"><span class="comment">//Instant——&gt;date</span></span><br><span class="line">Date date2 = Date.from(now);</span><br><span class="line">System.out.println(date2);</span><br><span class="line"><span class="comment">//Date——&gt;Instant</span></span><br><span class="line">Instant instant = date2.toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus增加</span></span><br><span class="line">System.out.println(<span class="string">&quot;plus使用======显示100天以后的时间=======&quot;</span>);</span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.plusDays(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;100天以后的时间：&quot;</span>+dateTimeFormatter.format(localDateTime1));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><ul>
<li><p>System类常见方法和案例</p>
<ol>
<li><p>exit：退出当前程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;ok1&quot;</span>);</span><br><span class="line"><span class="comment">//1、exit(0)表示程序退出</span></span><br><span class="line"><span class="comment">//2、0表示一个状态，正常的状态</span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ok2&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//当前&#123;0，0，0&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">src      the source array.原数组</span></span><br><span class="line"><span class="comment">srcPos   starting position in the source array.开始拷贝的原数组的起始位置</span></span><br><span class="line"><span class="comment">dest     the destination array.目标数组</span></span><br><span class="line"><span class="comment">destPos  starting position in the destination data.目标数据开始存放的位置</span></span><br><span class="line"><span class="comment">length   the number of array elements to be copied.拷贝元素的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,src.length);</span><br></pre></td></tr></table></figure></li>
<li><p>currentTimeMillens：返回当前时间距离1970-1-1的毫秒数</p>
</li>
<li><p>gc：运行垃圾回收机制System.gc()</p>
</li>
</ol>
</li>
</ul>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><ul>
<li><p>Arrays类常见方法</p>
<p>Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>
<ol>
<li><p>toString：返回数组的字符串形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a string representation of the contents of the specified array.</span></span><br><span class="line"><span class="comment">   * 返回指定数组内容的字符串表示形式</span></span><br><span class="line"><span class="comment">   * The string representation consists of a list of the array&#x27;s elements,</span></span><br><span class="line"><span class="comment">   * enclosed in square brackets(用方括号括起来) (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).</span></span><br><span class="line"><span class="comment">   * Adjacent[əˈdʒeɪs(ə)nt]相邻的 elements are</span></span><br><span class="line"><span class="comment">   * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma[ˈkɒmə]逗号 followed by a</span></span><br><span class="line"><span class="comment">   * space).  Elements are converted to strings as by</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;String.valueOf(int)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt; is</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;null&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> a the array whose string representation to return</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a string representation of &lt;tt&gt;a&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  System.out.println(Arrays.toString(ints));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="2">
<li>sort：排序（自然排序和定制排序）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sorts the specified array into ascending numerical order.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort(双枢轴快速排序)</span></span><br><span class="line"><span class="comment">   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. </span></span><br><span class="line"><span class="comment">   * This algorithm offers O(n log(n)) performance on many data sets(数据集) that cause other</span></span><br><span class="line"><span class="comment">   * quicksorts to degrade to quadratic performance, </span></span><br><span class="line"><span class="comment">   * 该算法在许多数据集上提供了O(n log(n))的性能，而这些数据集导致其他快速排序的性能下降到二次级</span></span><br><span class="line"><span class="comment">   * and is typically faster than traditional (one-pivot) Quicksort implementations.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span>[] arr1 = &#123;<span class="number">21</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  Arrays.sort(arr1);</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sort的定制排序(从大到小排序)</span></span><br><span class="line"><span class="comment">//体现接口编程的方式</span></span><br><span class="line"><span class="comment">//接口编程+动态绑定+匿名内部类的综合使用</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;Object&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">      Integer i1 = (Integer) o1;</span><br><span class="line">      Integer i2 = (Integer) o2;</span><br><span class="line">      <span class="keyword">return</span> i2 - i1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>binarySearch：通过二分搜索法进行查找，要求必须排好序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">111</span>,<span class="number">123</span>,<span class="number">132</span>,<span class="number">1132</span>&#125;;</span><br><span class="line"><span class="comment">/*binarySearch：只有已经排序好的数组可以使用该方法</span></span><br><span class="line"><span class="comment"> * @param a the array to be searched</span></span><br><span class="line"><span class="comment"> * @param key the value to be searched for</span></span><br><span class="line"><span class="comment"> * @return index of the search key, if it is contained in the array;</span></span><br><span class="line"><span class="comment"> *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</span></span><br><span class="line"><span class="comment"> *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</span></span><br><span class="line"><span class="comment"> *         key would be inserted into the array: the index of the first</span></span><br><span class="line"><span class="comment"> *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</span></span><br><span class="line"><span class="comment"> *         elements in the array are less than the specified key.  Note</span></span><br><span class="line"><span class="comment"> *         that this guarantees that the return value will be &amp;gt;= 0 if</span></span><br><span class="line"><span class="comment"> *         and only if the key is found.</span></span><br><span class="line"><span class="comment"> * 1.使用binarySearch二叉查找</span></span><br><span class="line"><span class="comment"> * 2.要求该数组有序的，如果该数组是无序的，不能使用binarySearch</span></span><br><span class="line"><span class="comment"> * 3.如果数组中不存在该元素，就返回 return -（low + 1）;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>*/
System.out.println(Arrays.binarySearch(arr,123));
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>copyOf：数组元素复制<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param original the array to be copied</span></span><br><span class="line"><span class="comment"> * @param newLength the length of the copy to be returned</span></span><br><span class="line"><span class="comment"> * @return a copy of the original array, truncated or padded with zeros</span></span><br><span class="line"><span class="comment"> * 		to obtain the specified length</span></span><br><span class="line"><span class="comment"> * 1.从数组arr中拷贝arr.length个元素到数组ints中</span></span><br><span class="line"><span class="comment"> * 2.如果拷贝的长度 &gt; arr.length，就再新数组的后面 增加 null</span></span><br><span class="line"><span class="comment"> * 3.该方法的底层使用的是 System.arraycopy()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>Integer[] newArr = Arrays.copyOf(arr, arr.length);
int[] ints = Arrays.copyOf(arr, 20);
System.out.println(Arrays.toString(ints));
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>fill：数组填充</li>
<li>equals：比较俩个数组元素内容是否完全一致</li>
<li>asList：将一组值转换成list</li>
</ol>
<h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><ul>
<li><p>BigInteger和BigDecimal介绍</p>
<p>应用场景：</p>
<ol>
<li><p>BigInteger适合保存比较大的整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bigInteger = <span class="keyword">new</span> BigInteger(<span class="string">&quot;11111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line">BigInteger bigInteger1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;8888888888888889&quot;</span>);</span><br><span class="line"><span class="comment">//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接进行+、-、*、/</span></span><br><span class="line">BigInteger bigInteger2 = bigInteger.add(bigInteger1);</span><br><span class="line">System.out.println(bigInteger2);</span><br><span class="line">BigInteger subtract = bigInteger.subtract(bigInteger1);</span><br><span class="line">BigInteger multiply = bigInteger.multiply(bigInteger1);</span><br><span class="line">BigInteger divide = bigInteger.divide(bigInteger1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">2. BigDecimal适合保存精度较高的浮点型（小数）</span><br><span class="line">  </span><br><span class="line">     ```java</span><br><span class="line">     //当我们需要保存一个精度很高的数时，double不够用，可以用BigDecimal</span><br><span class="line">     double d = 12.111111111111111111111111111111111;</span><br><span class="line">     System.out.println(d);</span><br><span class="line">     BigDecimal bigDecimal = new BigDecimal(&quot;12.111111111111111111111111111111111&quot;);</span><br><span class="line">     System.out.println(bigDecimal);</span><br><span class="line">     </span><br><span class="line">     BigDecimal bigDecimal1 = new BigDecimal(&quot;3&quot;);</span><br><span class="line">     //可能抛出异常（除不尽）：java.lang.ArithmeticException:Non-terminating decimal expansion</span><br><span class="line">     System.out.println(bigDecimal.divide(bigDecimal1));</span><br><span class="line">     //解决方法：在divide后指定一个精度即可</span><br><span class="line">     System.out.println(bigDecimal.divide(bigDecimal1,BigDecimal.ROUND_CEILING));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>前面我们保存多个数据使用的是数组，那么数组有什么不足之处呢？</p>
<ol>
<li>长度开始时必须指定，而且一旦指定，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行扩容并增加元素的——比较麻烦</li>
</ol>
<ul>
<li>集合<ol>
<li>可以动态保存任意多个对象，使用比较方便</li>
<li>提供了一系列方便的操作对象的方法：add、remove、set、get等</li>
<li>使用集合添加删除新元素——简洁</li>
</ol>
</li>
</ul>
<h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><ol>
<li>集合主要有两组（单列集合，双列集合）</li>
<li>Collection接口有两个重要子接口List Set，他们实现的子类都是单列集合</li>
<li>Map接口实现的子类是双列集合，存放K-V</li>
</ol>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\Collection继承体系图.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\Map继承体系图.png"/>

<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li><p>Collection接口实现类的特点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>collection实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）</li>
<li>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</li>
</ol>
</li>
<li><p>Collection接口和常用方法</p>
<ol>
<li>add：添加单个元素</li>
<li>remove：删除指定元素</li>
<li>contains：查找元素是否存在</li>
<li>size：获取元素个数</li>
<li>isEmpty：判断是否为空</li>
<li>clear：清空</li>
<li>addAll：添加多个元素</li>
<li>containsAll：查找多个元素是否存在</li>
<li>removeAll：删除多个元素</li>
</ol>
</li>
<li><p>Collection接口遍历元素方式1——使用Iterator（迭代器）</p>
<ol>
<li><p>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</p>
</li>
<li><p>所有实现了Collection接口的集合类都有一个iterator（）方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</p>
</li>
<li><p>Iterator的结构</p>
</li>
<li><p>Iterator仅用于遍历集合，Iterator本身并不存放对象</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\迭代器的执行原理.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\Iterator接口方法.png"/>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器原理：</span></span><br><span class="line">Iterator iterator = coll.iterator();<span class="comment">//得到一个集合的迭代器</span></span><br><span class="line"><span class="comment">//hasNext()：判断是否还有下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  <span class="comment">//next()：1、指针下移	2、将下移以后集合位置上元素返回</span></span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">iterator = col.iterator();</span><br></pre></td></tr></table></figure>

<p>注意：在调用it.next()方法之前必须调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</p>
<p>迭代器快捷键：itit</p>
</li>
</ol>
</li>
<li><p>Collection接口遍历对象方式2——增强for循环</p>
<p>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组。增强for底层仍然是迭代器，增强for也可以直接在数组使用</p>
<ul>
<li><p>基本语法</p>
<p>for（元素类型    元素名：集合名或数组名）{</p>
<p>​    访问元素</p>
<p>}</p>
</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><p>List接口基本介绍</p>
<ul>
<li>List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li>
<li>JDK API中List接口常用的实现类有：ArrayList、LinkedList和Vector</li>
</ul>
</li>
<li><p>List接口的常用方法</p>
<p><strong>List集合里添加了一些根据索引来操作集合元素的方法</strong></p>
<ul>
<li>void add(int index, Object ele)：在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index)：获取指定index位置的元素</li>
<li>int indexOf(Object obj)：返回obj在当前集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index)：移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele)：设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
<li><p>List的三种遍历方式</p>
<ul>
<li>使用迭代器</li>
<li>使用增强for循环</li>
<li>使用普通for</li>
</ul>
</li>
</ul>
<ol>
<li><p>ArrayList</p>
<ul>
<li><p>ArrayList的注意事项</p>
<ul>
<li>permits all elements,including null,ArrayList可以加入null，并且可以加入多个</li>
<li>ArrayList是由数组来实现数组存储的</li>
<li>ArrayList基本等同于Vector，除了ArrayList是线程不安全的（执行效率高），在多线程情况下，不建议使用ArrayList</li>
</ul>
</li>
<li><p>ArrayList的底层操作机制源码分析（重点、难点）</p>
<ol>
<li><p>ArrayList中维护了一个Object[]类型的数组elementData。</p>
<p>transient Object【】 elementData；</p>
<p>transient：表示瞬间的，短暂的，表示该属性不会被序列化</p>
</li>
<li><p>当创建对象时，如果使用的时无参构造器，则初始elementData容器为0（jdk7是10）</p>
</li>
<li><p>当添加元素时，先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适的位置</p>
</li>
<li><p>如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍</p>
</li>
<li><p>如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity</p>
</li>
<li><p>如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>LinkedList</p>
<ul>
<li><p>LinkedList的全面说明</p>
<ol>
<li>LinkedList实现了底层双向链表和双端队列的特点</li>
<li>可以添加任意元素（元素可以重复），包括null</li>
<li>线程不安全，没有实现同步</li>
</ol>
</li>
<li><p>LinkedList的底层操作机制</p>
<ol>
<li>LinkedList底层维护了一个双向链表</li>
<li>LinkedList中维护了两个属性，first和last，分别指向首节点和尾节点</li>
<li>每个节点（Node对象），里面又维护了prev、next、item三个属性，</li>
</ol>
</li>
</ul>
</li>
<li><p>Vector</p>
<ul>
<li><p>Vector的基本介绍</p>
<ol>
<li><p>Vecotr类的定义说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>Vector底层也是一个对象数组，protected Object[] elementData</p>
</li>
<li><p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</p>
</li>
<li><p>在开发中，需要线程同步安全时，考虑使用Vector</p>
</li>
</ol>
</li>
<li><p>Vector和ArrayList的比较</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">底层结构</th>
<th align="center">版本</th>
<th align="center">线程安全（同步）效率</th>
<th align="center">扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList</td>
<td align="center">可变数组</td>
<td align="center">jdk1.2</td>
<td align="center">不安全，效率高</td>
<td align="center">如果是无参构造器，第一次10，第二次开始按1.5倍扩容；如果是有参构造器，根据capacity按2倍扩容</td>
</tr>
<tr>
<td align="center">Vector</td>
<td align="center">可变数组</td>
<td align="center">jdk1.0</td>
<td align="center">安全，效率不高</td>
<td align="center">如果是无参。默认10，满后，按两倍扩容；如果指定大小，则每次直接按2倍扩容</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li>HashMap</li>
<li>Hashtable</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>Properties</li>
</ol>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><h2 id="泛型继承和通配符"><a href="#泛型继承和通配符" class="headerlink" title="泛型继承和通配符"></a>泛型继承和通配符</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h2><h2 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h2><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><h3 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h3><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>文件是什么</p>
<p>文件，我们并不陌生，文件是<strong>保存数据的地方</strong>，比如大家经常使用的word文档，txt文档，excel文件……都是文件。它既可以保存一张图片。也可以保存视频、声音……</p>
</li>
<li><p>文件流</p>
<p>文件在程序是以流的形式来操作的</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\文件流.png"/>

<p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p>
<p>输入流：数据从数据源（文件）到程序（内存）的路径</p>
<p>输出流：数据从程序（内存）到数据源（文件）的路径</p>
</li>
<li><p>创建文件对象相关构造器和方法</p>
<ul>
<li><p>相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(String pathName)<span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> File(File parent, String child)<span class="comment">//根据父目录文件+子路径构建</span></span><br><span class="line"><span class="keyword">new</span> File(String parent, String child)<span class="comment">//根据父目录+子路径构建</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//注意细节：d:\\不能写成d</span></span><br><span class="line"><span class="comment">//这里的file对象，在Java程序中只是一个对象</span></span><br><span class="line"><span class="comment">//只有执行了createNewFile方法，才会真正的在磁盘中创建该文件</span></span><br><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;./testio2.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file1.createNewFile()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;创建testio2成功！！！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取文件的相关信息</p>
<p>getName、getAbsolutePath、getParent、length(文件大小)、exists、isFile、isDirectory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;文件名：&quot;</span>+file.getName());</span><br><span class="line">System.out.println(<span class="string">&quot;绝对路径：&quot;</span>+file.getAbsoluteFile());</span><br><span class="line">System.out.println(<span class="string">&quot;是否存在：&quot;</span>+file.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;父目录的绝对路径：&quot;</span>+file.getParent());</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小：&quot;</span>+file.length());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是文件：&quot;</span>+file.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是目录：&quot;</span>+file.isDirectory());</span><br></pre></td></tr></table></figure></li>
<li><p>目录的操作和文件删除</p>
<p>mkdir：创建一级目录、mkdirs：创建多级目录、delete：删除空目录或文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\demo\\a\\b\\c&quot;</span>);</span><br><span class="line"><span class="comment">//判断d:\\demo\\a\\b\\c目录是否存在，如果存在就提示已经存在，否则就创建</span></span><br><span class="line"><span class="keyword">if</span> (file2.exists()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;d:\\demo\\a\\b\\c文件存在,不用创建&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file2.mkdirs()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\demo\\a\\b\\c文件创建成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\demo\\a\\b\\c文件创建失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deleteFile(file2);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不存在该文件！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.delete())&#123;</span><br><span class="line">       		System.out.println(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><ul>
<li><p>Java IO流原理</p>
<ol>
<li>I/O是Input/Output的缩写，I/O技术是非常使用的技术，用于处理数据传输，如读/写文件，网络通讯等</li>
<li>Java程序中。对于数据的输入/输出操作以”流（Stream）“的方式进行</li>
<li>java.io包下提供了各种”流“类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ol>
</li>
<li><p>流的分类</p>
<ul>
<li><p>按操作数据单位不同分为：字节流（8bit）（二进制文件），字符流（按字符）（文本文件）</p>
</li>
<li><p>按数据流的流向不同分为：输入流，输出流</p>
</li>
<li><p>按流的角色的不同分为：节点流、处理流/包装流</p>
<table>
<thead>
<tr>
<th align="center">（抽象基类）</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入流</td>
<td align="center">InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td align="center">输出流</td>
<td align="center">OutputStream</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<ol>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><ul>
<li><p>基本介绍</p>
<ol>
<li><p>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\节点流.png"/></li>
<li><p>处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，BufferedReader、BufferedWriter</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\处理流.png"/></li>
</ol>
</li>
</ul>
<ul>
<li><p>节点流和处理流一览图</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\节点流处理流一览图.png"/></li>
<li><p>节点流和处理流的区别和联系</p>
<ol>
<li>节点流是底层流/低级流，直接跟数据源相接</li>
<li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li>
<li>处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相接</li>
</ol>
</li>
<li><p>处理流的功能主要体现在以下两个方面：</p>
<ol>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率。</li>
<li>操作的便捷：处理流可能提供了一系列便捷的方法来一次性输入输出大批量数据，使用更加灵活方便</li>
</ol>
</li>
<li><p>处理流——BufferedReader和BufferedWriter</p>
<ol>
<li>BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的</li>
<li>关闭时，只需要关闭外层流即可</li>
</ol>
</li>
<li><p>处理流——BufferedInputStream和BufferedOutputStream</p>
<p>BufferedInputStream是字节流，在创建BufferedInputStream时，会创建一个内部缓冲区数组</p>
<p>BufferedOutputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统</p>
</li>
<li><p>对象流——ObjectInputStream和ObjectOutputStream</p>
<ul>
<li>看一个需求<ol>
<li>将int num = 100这个int数据保存到文件中，注意不是100数字，而是int 100，并且能够从文件中直接恢复int 100</li>
<li>将Dog dog=new Dog(“小黄”，3)这个Dog对象保存到文件中，并且能够从文件中恢复</li>
<li>上面的要求，就是能够将基本数据类型或者对象进行序列化和反序列化操作</li>
</ol>
</li>
<li>序列化和反序列化<ol>
<li>序列化就是在保存数据时，保存数据的值和数据类型</li>
<li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li>
<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：<ul>
<li>Serializable//这是一个标记接口（没有方法）</li>
<li>Externalizable//该接口有方法要实现，因此我们一般实现上面的</li>
</ul>
</li>
</ol>
</li>
<li>基本介绍<ol>
<li>功能：提供了对基本数据类型或对象类型序列化或反序列化的方法</li>
<li>ObjectOutputStream提供序列化功能</li>
<li>ObjectInputStream提供反序列化功能</li>
</ol>
</li>
<li>注意事项和细节说明<ol>
<li>读写顺序要一致</li>
<li>要求实现序列化或反序列化的对象，需要实现Serialzable</li>
<li>序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性</li>
<li>序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员</li>
<li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li>
<li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li>
</ol>
</li>
</ul>
</li>
<li><p>标准输入输出流</p>
<ul>
<li><p>介绍</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类型</th>
<th align="center">默认设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">System.in标准输入</td>
<td align="center">InputStream</td>
<td align="center">键盘</td>
</tr>
<tr>
<td align="center">System.out标准输出</td>
<td align="center">PrintStream</td>
<td align="center">显示器</td>
</tr>
</tbody></table>
</li>
<li><p>标准输入输出流</p>
<ul>
<li><p>案例1</p>
<p>传统方法<code>System.out.println(&quot;&quot;);</code>是使用out对象将数据输出到显示器</p>
</li>
<li><p>案例2</p>
<p>传统的方法：Scanner是从标准输入键盘接收数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>转换流——InputStreamReader和OutputStreamWriter</p>
<ul>
<li>介绍<ol>
<li>InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</li>
<li>OutputStreamWriter：Writer的子类，实现将OutputStream（字节流）包装成Writer（字符流）</li>
<li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流</li>
<li>可以在使用时，指定编码格式（比如：utf-8，gbk，gb2312，ISO8859-1等）</li>
</ol>
</li>
</ul>
</li>
<li><p>打印流——PrintStream和PrintWriter</p>
<p>打印流只有输出流，没有输入流</p>
</li>
</ul>
<h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>InputStream(字节输入流)抽象类是所有类字节输入流的超类</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\InputStream.png"/>

<ol>
<li><p>FileInputStream（文件输入流）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求：请使用FileInputStream读取testio2.txt文件，</span></span><br><span class="line"><span class="comment">// 并将文件内容显示到控制台</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prac</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建FileInputStream对象，用于读取文件</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\testio2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> readData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从该输入流读取一个字节的数据，如果没有输入可用，此方法将阻止</span></span><br><span class="line">        <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">        <span class="comment">//read()是一个字节一个字节读取，利用utf8读取汉字必然出错，</span></span><br><span class="line">        <span class="comment">//因为此时汉字由三个字节组成</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)readData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭文件流释放资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文件：利用read(new Byte[])</span></span><br><span class="line"><span class="comment">//read(new Byte[]):返回读取的字节数量或-1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prac2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];<span class="comment">//每次读取8个字节</span></span><br><span class="line">    <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\testio2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BufferedInputStream（缓冲字节输入流）</p>
</li>
<li><p>ObjectInputStream（对象字节输入流）</p>
</li>
</ol>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><ol>
<li><p>FileReader</p>
<p>FileReader和FileWriter是字符流，即按照字符来操作io</p>
<p>FileReader相关方法：</p>
<ul>
<li>new FileReader(File/String)</li>
<li>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</li>
<li>read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li>
</ul>
<p>相关API：</p>
<ul>
<li>new String(char[])：将char[]转换成String</li>
<li>new String(char[],off,len)：将char[]的指定部分转换成String</li>
</ul>
</li>
<li><p>BufferedReader</p>
</li>
<li><p>InputStreamReader</p>
</li>
</ol>
<p>##输出流</p>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><ol>
<li><p>FileOutputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件写入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    String pathName = <span class="string">&quot;d:\\testio.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(pathName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不需要创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//构造对象，准备对文件就行操作</span></span><br><span class="line">        <span class="comment">//fos = new FileOutputStream(pathName);//默认写入内容时，进行覆盖</span></span><br><span class="line">		fos = <span class="keyword">new</span> FileOutputStream(pathName,<span class="keyword">true</span>);<span class="comment">//append为true时，进行追加</span></span><br><span class="line">        String str = <span class="string">&quot;hhhhhh&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        <span class="comment">//fos.write(&#x27;h&#x27;);</span></span><br><span class="line">        <span class="comment">//fos.write(&quot;sdasasa流域aaaa&quot;.getBytes());</span></span><br><span class="line">        <span class="comment">//将字节数组，从偏移量offset开始的指定数组写入到此文件输入流中</span></span><br><span class="line">        fos.write(bytes,<span class="number">2</span>,bytes.length-<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完成图片的拷贝</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\明日香.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\temp\\明日香.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1.读取要拷贝的数据</span></span><br><span class="line">        <span class="comment">//2.向指定文件写入数据</span></span><br><span class="line">        <span class="keyword">while</span>((readLen = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//String str = new String(buf,0,readLen);</span></span><br><span class="line">            <span class="comment">//fos.write(str.getBytes());</span></span><br><span class="line">            fos.write(buf,<span class="number">0</span>,readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BufferedOutputStream</p>
</li>
<li><p>ObjectOutputStream</p>
</li>
</ol>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><ol>
<li><p>FileWriter</p>
<p>FileWriter常用方法</p>
<ul>
<li>new FileWriter(File/String)：覆盖模式，相当于流的指针在首端</li>
<li>new FileWriter(File/String，true)：追加模式，相当于流的指针在尾端</li>
<li>write(int)：写入单个字符</li>
<li>write(char[])：写入指定数组</li>
<li>write(char[],off,len)：写入指定数组的指定部分</li>
<li>write(string)：写入整个字符串</li>
<li>write(string,off,len)：写入字符串的指定部分</li>
</ul>
<p>相关API：Stirng类：toCharArray：将String转换成char[]</p>
<p>FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件中</p>
</li>
<li><p>BufferedWriter</p>
</li>
<li><p>OutputStreamWriter</p>
</li>
</ol>
<h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2><ul>
<li><p>引入</p>
<p>如下一个配置文件mysql.properties</p>
<p>ip = 192.168.0.13</p>
<p>user = root</p>
<p>pwd = 12345</p>
<p>请问编程读取ip、user和pwd的值是多少</p>
<p>分析：</p>
<p>1、传统的方法</p>
<p>2、使用Properties类可以方便实现</p>
</li>
<li><p>基本介绍</p>
<ol>
<li><p>专门用于读写配置文件的集合类</p>
<p>配置文件的格式：</p>
<p>键 = 值</p>
<p>键 = 值</p>
</li>
<li><p>注意：键值对不需要又空格，值不需要用引号一起来，默认类型是String</p>
</li>
<li><p>Properties的常见方法</p>
<p>load：加载配置文件的键值对到Properties对象</p>
<p>list：将数据显示到指定设备/流对象</p>
<p>getProperty(key)：根据键获取值</p>
<p>setProperty(key,value)：设置键值对到Properties对象</p>
<p>store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</p>
<p><a target="_blank" rel="noopener" href="http://tool.chinaz.com/tools/unicode.aspx">unicode码查询工具</a></p>
</li>
</ol>
</li>
</ul>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h2 id="反射获取类的结构信息"><a href="#反射获取类的结构信息" class="headerlink" title="反射获取类的结构信息"></a>反射获取类的结构信息</h2><ol>
<li>Class</li>
<li>Field</li>
<li>Method</li>
<li>Constructor</li>
<li>访问属性</li>
<li>访问方法</li>
</ol>
<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p>为什么要学习数据库？</p>
<p>引出（一个问题）：</p>
<p>淘宝、京东、微信、抖音都有各自的功能，那么当我们退出系统的时候，下次再访问时，为什么信息还存在？</p>
<p>答：数据库，可以更有效的管理数据</p>
<h2 id="MySQL安装和配置"><a href="#MySQL安装和配置" class="headerlink" title="MySQL安装和配置"></a>MySQL安装和配置</h2><ul>
<li><p>使用命令行窗口连接Mysql数据库</p>
<ol>
<li><p><code> mysql -h 主机名 -P 端口 -u用户名 -p密码</code></p>
</li>
<li><p>登陆前保证服务启动</p>
<p>启动mysql数据库的常用方式【Dos命令】</p>
<ul>
<li>服务方式启动（界面）</li>
<li><code>net stop mysql（服务名）</code></li>
<li><code>net start mysql（服务名）</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li><p>数据库三层结构——破除MySQL神秘</p>
<ol>
<li><p>所谓安装MySQL数据库，就是在主机上安装一个数据库管理系统（DBMS），这个管理程序可以管理多个数据库。DBMS（database manage system）</p>
</li>
<li><p>一个数据库中可以创建多个表，以保存数据（信息）</p>
</li>
<li><p>数据库管理系统（DBMS）、数据库和表的关系如图所示：</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\MySQL三层结构.png"/></li>
</ol>
</li>
</ul>
<p>MySQL数据库——<strong>普通表的本质仍然是文件</strong></p>
<ul>
<li><p>SQL语句分类</p>
<p>DDL：数据定义语言（create 表、库……）</p>
<p>DML：数据操作语句（增加insert、修改update、删除delete）</p>
<p>DQL：数据查询语言（select）</p>
<p>DCL：数据控制语言（管理数据库：比如用户权限 grant revoke）</p>
</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] db_name</span><br><span class="line">		[create_specification...]</span><br><span class="line"></span><br><span class="line">create_specification:</span><br><span class="line">	[DEFAULT] CHARACTER SET charset_name</span><br><span class="line">	[DEFAULT] COLLATE collation_name</span><br></pre></td></tr></table></figure>

<ol>
<li>CHARACTER SET：指定数据库采用的字符集，如果不指定字符集，默认utf8</li>
<li>COLLATE：指定数据库字符集的校对规则（常用的utf8_bin【区分大小写】、utf8_general_ci【不区分大小写】【默认utf8_general_ci】）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个使用utf8字符集，并带校对规则的hsp_db数据库</span><br><span class="line">CREATE DATABASE hsp_db CHARACTER SET utf8 COLLATE utf8_bin;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看、删除数据库"><a href="#查看、删除数据库" class="headerlink" title="查看、删除数据库"></a>查看、删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"># 显示某个数据库的创建语句</span><br><span class="line"># 查看前面创建的数据库的定义信息</span><br><span class="line">SHOW CREATE DATABASE db_name;</span><br><span class="line">#数据库删除语句</span><br><span class="line">DROP DATABASE [IF EXISTS] db_name;</span><br></pre></td></tr></table></figure>

<h3 id="备份恢复数据库"><a href="#备份恢复数据库" class="headerlink" title="备份恢复数据库"></a>备份恢复数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份hsp_db02和hsp_db03库中的数据，并恢复</span><br><span class="line"># 备份要在Dos下执行mysqldump指令其实在mysql安装目录\bin</span><br><span class="line"># 这个备份的文件，就是对应的sql语句</span><br><span class="line"># -B：表示接下来的内容都是数据库名称</span><br><span class="line">mysqldump -u root -p -B hsp_db02 hsp_db03 &gt; d:\\bak.sql</span><br><span class="line"></span><br><span class="line"># 恢复数据库（注意：进入MySQL命令行再执行）</span><br><span class="line">source d:\\bak.sql</span><br><span class="line"># 第二种恢复方法</span><br><span class="line"># 直接将bak.sql的内容放到查询编辑器中，执行</span><br><span class="line"></span><br><span class="line"># 备份数据库中的表</span><br><span class="line">mysqldump -u 用户名 -p密码 数据库 表1 表2 表n &gt; d:\\文件名.sql</span><br></pre></td></tr></table></figure>

<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">	field1 datatype,</span><br><span class="line">    field2 datatype,</span><br><span class="line">    field3 datatype</span><br><span class="line">)character set 字符集 collate 校验规则 engine 存储引擎; </span><br><span class="line"></span><br><span class="line">############</span><br><span class="line"># field：指定列名	datatype：指定列类型（字段类型）</span><br><span class="line"># character set：如不指定，则为所在数据库字符集</span><br><span class="line"># collate：如不指定，则为所在数据库的校验规则</span><br><span class="line"># engine：引擎（这个涉及内容较多，后面单独讲解）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示表的结构</span><br><span class="line">desc tableName;</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>创建一个员工表emp，选用适当的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">    id INT UNSIGNED,</span><br><span class="line">    `name` VARCHAR(20),</span><br><span class="line">    sex BIT(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATE,</span><br><span class="line">    job VARCHAR(200),</span><br><span class="line">    salary FLOAT unsigned,</span><br><span class="line">    `resume` TEXT </span><br><span class="line">) CHARSET utf8 COLLATE utf8_general_ic ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp VALUES(1,&#x27;海绵宝宝&#x27;,1,&#x27;2011-1-1&#x27;,&#x27;2021-1-1&#x27;,&#x27;蟹王堡面点师&#x27;,100.1,&#x27;是派大星的朋友&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除列</span><br><span class="line">alter table table1_name</span><br><span class="line">	drop (column);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除sex列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">	drop sex;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 追加列</span><br><span class="line">alter table tablename</span><br><span class="line">	add (colum datatype [default expr],</span><br><span class="line">         colum datatype</span><br><span class="line">         ......);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改列</span><br><span class="line">alter table tablename</span><br><span class="line">	modify (colum datatype [default expr],</span><br><span class="line">         colum datatype</span><br><span class="line">         ......);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在员工表emp上增加一个image列，varchar类型（要求在resume后面）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp </span><br><span class="line">	add image varchar(32) not null default &#x27;&#x27; </span><br><span class="line">	after `resume`;</span><br></pre></td></tr></table></figure></li>
<li><p>修改job列，使其长度为60</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">	modify job varchar(60) not null default &#x27;&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>表名改为employee</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename table emp to employee;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表的字符集为utf8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee character set utf8;</span><br></pre></td></tr></table></figure></li>
<li><p>列名name修改为user_name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee</span><br><span class="line">	change name user_name varchar(50) not null default &#x27;&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="MySQL数据类型-列类型"><a href="#MySQL数据类型-列类型" class="headerlink" title="MySQL数据类型(列类型)"></a>MySQL数据类型(列类型)</h2><img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\MySQL常用数据类型.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\MySQL列类型1.png"/>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\MySQL列类型2.png"/>

<ul>
<li><p>数值型（整数）的基本使用</p>
<ol>
<li><p>说明，使用规范：在能够满足需求的情况下，尽量选择占用空间小的类型</p>
</li>
<li><p>应用实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1 (</span><br><span class="line">    id TINYINT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test1(id) VALUE(128);</span><br><span class="line"></span><br><span class="line">SELECT id FROM test1;</span><br><span class="line"># ============================</span><br><span class="line">CREATE TABLE test2 (</span><br><span class="line">    id TINYINT UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test2(id) VALUE(128);</span><br><span class="line"></span><br><span class="line">SELECT id FROM test2; </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>数值型（bit）的使用</p>
<ol>
<li><p>基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test3 (</span><br><span class="line">    num BIT(8)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test3(num) VALUE(1);</span><br><span class="line"></span><br><span class="line">SELECT num FROM test3; </span><br><span class="line"></span><br><span class="line">SELECT num FROM test3 WHERE num = 1;</span><br></pre></td></tr></table></figure></li>
<li><p>细节说明</p>
<ul>
<li>bit字段显示时，按照<strong>位的方式显示</strong></li>
<li>查询的时候仍然可以使用添加的数值</li>
<li>如果一个值只有0、1，可以考虑使用bit（1），可以节约空间</li>
<li>位类型。M指定位数，默认值1，范围1-64</li>
<li>使用不多</li>
</ul>
</li>
</ol>
</li>
<li><p>数值型（小数）的基本使用</p>
<ol>
<li><p>FLOAT/DOUBLE[UNSIGNED]</p>
<p>Float单精度精度，Double双精度精度</p>
</li>
<li><p>DECIMAL[M,D] [UNSIGNED]</p>
<ul>
<li>可以支持更加精确的小数位。M时小数位数（精度）的总数，D是小数点（标度）后面的位数</li>
<li>如果D是0，则值没有小数点或分数部分。M最大65。D最大是30。如果D被省略，默认是0，如果M被省略，默认是10。</li>
<li>建议：如果希望小数的精度高，推荐使用decimal</li>
</ul>
</li>
</ol>
</li>
<li><p>字符串的基本使用</p>
<p>CHAR（size）</p>
<p>固定长度字符串    最大255<strong>字符</strong></p>
<p>VARCHAR（size）    65535 - <strong>3（用于记录字段大小）</strong></p>
<p>可变长度字符串    最大65532<strong>字节</strong>（utf8编码最大21844【65532/3】字符    1-3字节用于记录大小）</p>
<p>字符串使用细节</p>
<ol>
<li><p>细节一</p>
<p>char（4）//这个4表示字符数（最大255），不是字节数，不管是中文还是字母都是放四个，按字符计算</p>
<p>varchar（4）//这个4表示字符数，不管是字母还是中文都以定义好的表的编码来存放数据</p>
<p>不管是中文还是英文字母，都是最多存放4个，是按照字符来存放的</p>
</li>
<li><p>char（4）是定长，就是说，即使你插入‘aa’，也会占用分配的4个字符</p>
<p>varchar（4）是变长，就是说，如果你插入‘aa‘，实际占用空间大小并不是4个字符，而是按照实际占用空间来分配（老汉说明：varchar本身还需要占用1-3个字节来记录存放内容长度）</p>
</li>
<li><p>什么时候使用char，什么时候使用varchar</p>
<ul>
<li>如果数据是定长，推荐使用char，比如md5的密码、邮编、手机号、身份证号码等</li>
<li>如果一个字段的长度是不确定的，我们使用varchar，比如留言，文章</li>
<li>查询速度：char &gt; varchar</li>
</ul>
</li>
<li><p>在存放文本时，也可以使用Text数据类型，可以将TEXT列视为VARCHAR列，注意Text不能有默认值，大小0 - 2^16字节，如果希望存放更多字符，可以选择MEDIUMTEXT(0– 2^24)或者LONGTEXT（0 – 2^32）</p>
</li>
</ol>
</li>
<li><p>日期类型的基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE birthday6 (</span><br><span class="line">    t1 DATE,</span><br><span class="line">    t2 DATETIME,</span><br><span class="line">    t3 TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO birthday6(t1,t2) VALUES(&#x27;2022-11-11&#x27;,&#x27;2022-11-11 10:10:11&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM birthday6;</span><br><span class="line">#############################</span><br><span class="line"># 添加时，如果没有添加时间，默认使用当前时间</span><br><span class="line"># 更新时，自动会使用当前时间对该字段进行更新</span><br><span class="line">NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br></pre></td></tr></table></figure></li>
<li><p>日期类型的细节说明</p>
<p>timestamp在insert和update时，自动更新</p>
<p><code>NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code></p>
</li>
</ul>
<h2 id="C-create-R-read-U-update-D-delete"><a href="#C-create-R-read-U-update-D-delete" class="headerlink" title="C[create]R[read]U[update]D[delete]"></a>C[create]R[read]U[update]D[delete]</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><ul>
<li><p>使用INSERT语句向表中插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name[(column [,column...])]</span><br><span class="line">VALUES (`value` [,`value`]);</span><br></pre></td></tr></table></figure></li>
<li><p>细节说明</p>
<ol>
<li><p>插入的数据应与字段的数据类型相同</p>
<p>比如把’abc‘添加到int类型会错误</p>
</li>
<li><p>数据的长度应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中</p>
</li>
<li><p>在values中列出的数据位置必须与被加入的列的排列位置相对应</p>
</li>
<li><p>字符和日期型数据应包含在单引号中</p>
</li>
<li><p>列可以插入空值【前提是该字段允许为空】</p>
<p>insert into table value（null）；</p>
</li>
<li><p>insert into table_name（列名…）values（）（）…形式添加多条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">    id INT UNSIGNED,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE UNSIGNED</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO goods(id,goods_name,price) </span><br><span class="line">	VALUES(3,&#x27;可乐&#x27;,3.5),(4,&#x27;芬达&#x27;,6.5);</span><br></pre></td></tr></table></figure></li>
<li><p>如果是给表中的所有字段添加数据，可以不写前面的字段名称</p>
</li>
<li><p>默认值的使用，当不给某个字段值时，如果有默认值就会添加，否则报错</p>
<p>如果某个列没有指定not null，那么当添加数据时，没有给定值，则会默认给null</p>
</li>
</ol>
</li>
</ul>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><ul>
<li><p>使用update语句修改表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table1_name</span><br><span class="line">	set col_name = expr1[,col_name2 = expr2]</span><br><span class="line">	[where where_definition];</span><br></pre></td></tr></table></figure></li>
<li><p>基本使用</p>
<p>要求:在上面创建的employee表中修改表中的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">    id INT UNSIGNED,</span><br><span class="line">    `name` VARCHAR(20),</span><br><span class="line">    sex BIT(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATE,</span><br><span class="line">    job VARCHAR(200),</span><br><span class="line">    salary FLOAT unsigned,</span><br><span class="line">    `resume` TEXT </span><br><span class="line">) CHARSET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp </span><br><span class="line">	VALUES(2,&#x27;小妖怪&#x27;,0,&#x27;1000-1-1&#x27;,&#x27;1024-1-1&#x27;,&#x27;巡山小喽啰&#x27;,1000,&#x27;银角大王的属下&#x27;),</span><br><span class="line">	(3,&#x27;小妖怪&#x27;,0,&#x27;1000-1-1&#x27;,&#x27;1024-1-1&#x27;,&#x27;巡山小喽啰&#x27;,1001,&#x27;银角大王的属下&#x27;),</span><br><span class="line">	(4,&#x27;小妖怪&#x27;,0,&#x27;1000-1-1&#x27;,&#x27;1024-1-1&#x27;,&#x27;巡山小喽啰&#x27;,1000,&#x27;银角大王的属下&#x27;),</span><br><span class="line">	(5,&#x27;老妖怪&#x27;,1,&#x27;900-1-1&#x27;,&#x27;924-1-1&#x27;,&#x27;巡山大喽啰&#x27;,1000,&#x27;银角大王的中层干部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 将所有员工薪水修改为5000元</span><br><span class="line">UPDATE emp</span><br><span class="line">	SET salary = 5000;</span><br><span class="line">-- 将所有姓名为小妖怪的员工薪水修改为3000元</span><br><span class="line">UPDATE emp</span><br><span class="line">	SET salary = 3000</span><br><span class="line">	WHERE `name` = &#x27;小妖怪&#x27;;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000元</span><br><span class="line">UPDATE emp</span><br><span class="line">	SET salary = salary+1000</span><br><span class="line">	WHERE `name` = &#x27;老妖怪&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用细节</p>
<ol>
<li>UPDATE语法可以用新值更新原有表行中的各列</li>
<li>SET子句指示要修改哪些列和要给予哪些值</li>
<li>WHERE子句指定应更新那些行。如没有WHERE子句，则更新所有的行</li>
<li>如果需要修改多个字段，可以通过set 字段1=值1，字段2=值2……</li>
</ol>
</li>
</ul>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><ul>
<li><p>使用delete语句删除表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from table1_name</span><br><span class="line">	[where where_definition];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除表中名为老妖怪的记录</span><br><span class="line">delete from emp </span><br><span class="line">	where `name` = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">delete from emp;</span><br></pre></td></tr></table></figure></li>
<li><p>使用细节</p>
<ol>
<li>如果不使用where子句，将删除表中的所有数据</li>
<li>delete语句不能删除某一列的值（可使用update设为null或者’‘）</li>
<li>使用delete语句仅删除记录，不删除表本身，如要删除表，使用drop table语句。drop table 表名；</li>
</ol>
</li>
</ul>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><ol>
<li><p>单表</p>
<ul>
<li><p>基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select [distinct] *|&#123;column1,column2,column3...&#125; from table1_name;</span><br></pre></td></tr></table></figure>

<p>在select语句中可使用as语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column_name as 别名 from 表名;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li>select指定查询哪些列的数据</li>
<li>column指定列名</li>
<li>*号代表所有列，表名 . *表示将该表所有列都显示出来</li>
<li>from指定查询哪张表</li>
<li>distinct可选，指显示结果时，是否去掉重复数据</li>
</ul>
</li>
<li><p>在where子句中经常使用的运算符</p>
<table>
<thead>
<tr>
<th align="center">比较运算符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;   &lt;   &lt;=   &gt;=   =   &lt;&gt;   !=</td>
<td align="center">大于、小于、大于等于、小于等于、不等于</td>
</tr>
<tr>
<td align="center">BTETWEEN…AND…</td>
<td align="center">显示在某一区间的值(闭区间)</td>
</tr>
<tr>
<td align="center">IN（set）</td>
<td align="center">显示在in列表中的值，例：in(100,20)</td>
</tr>
<tr>
<td align="center">LIKE ’张pattern‘       Not LIKE ’ ‘</td>
<td align="center">模糊查询</td>
</tr>
<tr>
<td align="center">is null</td>
<td align="center">判断是否为空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">逻辑运算符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">多个条件同时为空</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">多个条件任意成立</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">不成立，例：where not(salary&gt;100);</td>
</tr>
</tbody></table>
</li>
<li><p>使用order by子句排序查询结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2,column3...</span><br><span class="line">from table1_name</span><br><span class="line">order by colum asc|desc;</span><br><span class="line"></span><br><span class="line">-- 1.order by指定排序的列，排序的列既可以是表中的列名，也可以是select语句后指定的列名</span><br><span class="line">-- 2.asc升序（默认）、desc降序</span><br><span class="line">-- 3.order by 子句应位于select语句的结尾</span><br></pre></td></tr></table></figure></li>
<li><p>使用group by子句对列进行分组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2…… from tableName</span><br><span class="line">group by column_;</span><br></pre></td></tr></table></figure></li>
<li><p>使用having子句对<code>分组后的结果</code>进行过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2…… from tableName</span><br><span class="line">group by column_ having ……;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>显示<code>每个部门的</code>平均工资和最高工资</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select department_name,avg(salary),max(salary) from department group by department_name;</span><br></pre></td></tr></table></figure></li>
<li><p>显示<code>每个部门的</code> <code>每种岗位的</code>平均工资和最低工资</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select department_name,job,avg(salary),min(salary) from department group by department_name,job;</span><br></pre></td></tr></table></figure></li>
<li><p>显示<code>平均工资低于2000的</code>部门号和它的平均工资</p>
<ol>
<li><p>显示每个部门的部门号和它的平均工资</p>
</li>
<li><p>筛选出平均工资低于2000的</p>
</li>
<li><p>使用别名进行过滤</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select department_id,avg(salary) as avg_sal from department group by department_id having avg_sal &lt; 2000;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>单表查询加强</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何查询2022-01-01后入职的员工</span><br><span class="line">select * from emp</span><br><span class="line">	where hiredate &gt; &#x27;2022-01-01&#x27;;</span><br><span class="line">-- 如何使用like操作符</span><br><span class="line">-- %：表述0到多个任意字符</span><br><span class="line">-- _：表示单个任意字符</span><br><span class="line">-- 如何显示姓王的员工和介绍</span><br><span class="line">SELECT `name`,intro FROM edu_teacher</span><br><span class="line">WHERE `name` LIKE &#x27;王%&#x27;;</span><br><span class="line">-- 如何显示第三个字符为大写O的所有员工的姓名和工资</span><br><span class="line">SELECT `name`,intro FROM edu_teacher</span><br><span class="line">WHERE `name` LIKE &#x27;__O%&#x27;;</span><br><span class="line">-- 查询表的结构</span><br><span class="line">desc edu_teacher;</span><br><span class="line">-- 按照部门号升序而雇员的工资降序排列，显示雇员信息</span><br><span class="line">select * from emp</span><br><span class="line">	order by deptno asc, sal desc;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MySQL表查询——加强(分页)</p>
<ol>
<li><p>按雇员的id号升序取出，每页显示3条记录，请分别显示第一页，第二页，第三页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 第一页</span><br><span class="line">select * from emp </span><br><span class="line">	order by id asc </span><br><span class="line">	limit 0,3;</span><br><span class="line">-- 第二页</span><br><span class="line">select * from emp </span><br><span class="line">	order by id asc </span><br><span class="line">	limit 3,3;</span><br><span class="line">-- 第三页</span><br><span class="line">select * from emp </span><br><span class="line">	order by id asc </span><br><span class="line">	limit 6,3;</span><br><span class="line">-- 推导一个公式</span><br><span class="line">select * from emp</span><br><span class="line">	order by id asc</span><br><span class="line">	limit 每页显示记录数*（第几页-1）, 每页显示记录数;</span><br></pre></td></tr></table></figure></li>
<li><p>基本语法：select…… limit start， rows</p>
<p>表示从start+1行开始取，取出rows行，start从0开始计算</p>
</li>
<li><p>课堂练习：按雇员的empno号降序取出，每页显示5条记录，请分别显示第三页，第五页对应的sql语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 第三页</span><br><span class="line">select * from emp</span><br><span class="line">	order by empno desc</span><br><span class="line">	limit 10, 5;</span><br><span class="line">-- 第五页</span><br><span class="line">select * from emp</span><br><span class="line">	order by empno desc</span><br><span class="line">	limit 20, 5;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>使用分组函数和分组子句group by</p>
<ol>
<li><p>显示每种岗位的雇员总数、平均工资</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) as 雇员总数,avg(sal) as 平均工资 from emp group by job;</span><br></pre></td></tr></table></figure></li>
<li><p>显示雇员总数，以及获得补助的雇员数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) as 雇员总数,count(comm) as 获得补助的雇员数 from emp;</span><br></pre></td></tr></table></figure></li>
<li><p>显示管理者的总人数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct mgr) as 管理者总人数 from emp;</span><br></pre></td></tr></table></figure></li>
<li><p>显示雇员工资的最大差额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(sal)-min(sal) as 最大差额 from emp;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>数据分组的总结</p>
<p>如果select语句同时包含group by,having,order by,limit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2,column3... from tab_name</span><br><span class="line">	group by columnn</span><br><span class="line">	having conditionn</span><br><span class="line">	order by columnn</span><br><span class="line">	limit startn,rows;</span><br></pre></td></tr></table></figure>

<p>请统计各个部门的平均工资，并且是大于1000的，并且按照平均工资从高到低排序，取出前两行记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select deptno,avg(sal) as avg_sal from emp </span><br><span class="line">	group by location</span><br><span class="line">	having avg_sal&gt;1000</span><br><span class="line">    order by avg_sal desc</span><br><span class="line">    limit 0,2;</span><br></pre></td></tr></table></figure></li>
<li><p>多表</p>
<p>多表查询是指基于两个和两个以上的表查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp,dept;</span><br></pre></td></tr></table></figure>

<p>在默认情况下：当对两个表进行查询时，规则：</p>
<ol>
<li>从第一张表中，取出一行和第二张表的每一行进行组合，返回结果【含有两张表的所有列】</li>
<li>一共返回的记录数：第一张表行数*第二张表的行数</li>
<li>这样多表查询默认处理返回的结果，称为笛卡尔集</li>
<li>解决这个多表的关键就是要写出正确的过滤条件where</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal,dname,emp.deptno</span><br><span class="line">from emp,dept</span><br><span class="line">where emp.deptno = dept.deptno;</span><br></pre></td></tr></table></figure>

<p>老汉小技巧：多表查询的条件不能少于<strong>表的个数-1</strong>，否则会出现笛卡尔积</p>
</li>
</ol>
<ul>
<li><p>自连接</p>
<p>自连接是指在同一张表的连接查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 显示公司员工名字和他的上级的名字</span><br><span class="line">select worker.ename as 员工名,boss.ename as 上级 </span><br><span class="line">from emp worker,emp boss</span><br><span class="line">where worker.mgr = boss.empno;</span><br></pre></td></tr></table></figure>

<p>自连接的特点：</p>
<ol>
<li>把同一张表当作两张表使用</li>
<li>需要给表取别名</li>
<li>列名不明确。可以指定列的别名</li>
</ol>
</li>
<li><p>MySQL表子查询</p>
<ul>
<li><p>什么是子查询</p>
<p>子查询是指嵌入在其他SQL语句中的select语句，也叫嵌套语句</p>
</li>
<li><p>单行子查询</p>
<p>单行子查询是指只返回一行数据的子查询语句</p>
<p>请思考：如何显示与SMITH同一部门的所有员工？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp </span><br><span class="line">where deptno = (select deptno from emp where ename = &#x27;SMITH&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>多行子查询</p>
<p>多行子查询指返回多行数据的子查询    使用关键字in</p>
<p>课堂练习：如何查询和部门10的工作相同的雇员的名字、岗位、工资、部门号，但是不含10号部门自己的雇员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.查询到10号部门有那些工作</span><br><span class="line">select distinct job</span><br><span class="line">	from emp</span><br><span class="line">	where deptno = 10;</span><br><span class="line">-- 2.把上面查询的结果当作子查询使用</span><br><span class="line">select ename,job,sal,deptno from emp</span><br><span class="line">where job in (select distinct job from emp where deptno = 10)</span><br><span class="line">and deptno != 10;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以把子查询当作一张临时表使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在from子句中使用子查询</span><br><span class="line">  </span><br><span class="line">  -- 查询每个部门工资高于本部门平均工资的人的资料</span><br><span class="line">  -- 部门号和每个部门的平均工资</span><br><span class="line">  SELECT deptno, AVG(sal) AS avg_sal </span><br><span class="line">  	FROM emp </span><br><span class="line">	GROUP BY deptno;</span><br><span class="line">  -- 查询</span><br><span class="line">SELECT ename,sal,avg_sal,emp.deptno </span><br><span class="line">  	FROM emp,(</span><br><span class="line">  		SELECT deptno, AVG(sal) AS avg_sal </span><br><span class="line">  		FROM emp </span><br><span class="line">  		GROUP BY emp.deptno) temp </span><br><span class="line">  	WHERE emp.deptno = temp.deptno AND emp.`sal` &gt; temp.avg_sal;</span><br><span class="line">	</span><br><span class="line">  -- 查找每个部门工资最高的人的详细资料</span><br><span class="line">-- 每个部门工资最高的人</span><br><span class="line">  SELECT MAX(sal) AS max_sal</span><br><span class="line">	FROM emp</span><br><span class="line">  	GROUP BY deptno;</span><br><span class="line">  -- 按要求查找</span><br><span class="line">  SELECT * </span><br><span class="line">  	FROM emp,(</span><br><span class="line">  		SELECT MAX(sal) AS max_sal</span><br><span class="line">  		FROM emp</span><br><span class="line">  		GROUP BY deptno</span><br><span class="line">  		) temp</span><br><span class="line">  	WHERE emp.`sal` = max_sal;</span><br><span class="line">  </span><br><span class="line">  -- 查询每个部门的信息（包括：部门名，编号，地址）和人员数量</span><br><span class="line">  SELECT deptno,COUNT(*) AS 人数</span><br><span class="line">  	FROM emp</span><br><span class="line">  	GROUP BY deptno;</span><br><span class="line">  </span><br><span class="line">  SELECT temp.deptno,dname,loc,人数</span><br><span class="line">  	FROM dept,(</span><br><span class="line">  		SELECT deptno,COUNT(*) AS 人数</span><br><span class="line">  		FROM emp</span><br><span class="line">  		GROUP BY deptno) temp</span><br><span class="line">  	WHERE temp.deptno = dept.`deptno`;</span><br></pre></td></tr></table></figure></li>
<li><p>在多行子查询中使用all操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号</span><br><span class="line">select ename,sal,deptno </span><br><span class="line">	from emp </span><br><span class="line">	where sal&gt;all(select sal </span><br><span class="line">                  from emp </span><br><span class="line">                  where deptno = 30);</span><br></pre></td></tr></table></figure></li>
<li><p>在多行子查询中使用any操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何显示工资比部门30的其中一个员工的工资高的员工的姓名、工作和部门号</span><br><span class="line">select ename,sal,deptno </span><br><span class="line">	from emp</span><br><span class="line">	where sal&gt;any(select sal </span><br><span class="line">                  from emp </span><br><span class="line">                  where deptno=30);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>多列子查询</p>
<p>多列子查询则是指查询返回多个列数据的子查询语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何查询与smith的部门和岗位完全相同的所有雇员（并且不含smith本人）</span><br><span class="line">-- （字段1，字段2……）=（select 字段1，字段2 from……）</span><br><span class="line">-- 返回smith的部门和岗位</span><br><span class="line">select deptno, job </span><br><span class="line">	from emp </span><br><span class="line">	where ename = &#x27;smith&#x27;;</span><br><span class="line">-- 根据要求查表</span><br><span class="line">select * </span><br><span class="line">	from emp </span><br><span class="line">   	where (deptno, job) = (</span><br><span class="line">        select deptno, job </span><br><span class="line">        from emp </span><br><span class="line">        where ename = &#x27;smith&#x27;) and ename != &#x27;smith&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 请查询和宋江数学、英语、语文成绩完全相同的学生(不包括宋江本人)</span><br><span class="line"></span><br><span class="line">-- 宋江成绩情况</span><br><span class="line">select math,english,chinese </span><br><span class="line">	from student </span><br><span class="line">	where ename =&#x27;宋江&#x27;;</span><br><span class="line">-- 查询</span><br><span class="line">select * from student </span><br><span class="line">where (math,english,chinese) = (</span><br><span class="line">	select math,english,chinese </span><br><span class="line">    from student </span><br><span class="line">    where ename =&#x27;宋江&#x27;</span><br><span class="line">	) and ename != &#x27;宋江&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>表复制</p>
<ul>
<li><p>自我复制数据（蠕虫复制）</p>
<p>有时为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 建表</span><br><span class="line">CREATE TABLE emp2(</span><br><span class="line">	id INT unsigned,</span><br><span class="line">	ename VARCHAR(20),</span><br><span class="line">	job VARCHAR(20),</span><br><span class="line">	deptno INT UNSIGNED</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">-- 复制旧表</span><br><span class="line">INSERT INTO emp2(id,ename,job,deptno)</span><br><span class="line">	SELECT empno,ename,job,deptno FROM emp;</span><br><span class="line">	</span><br><span class="line">-- 自我复制（蠕虫复制）</span><br><span class="line">insert into emp2</span><br><span class="line">	select * from emp2;</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line"></span><br><span class="line">-- 如何删除一张表重复的记录</span><br><span class="line">-- （1）先创建一张临时表my_tmp，该表的结构和原表一致</span><br><span class="line">CREATE TABLE emp2 LIKE emp3;</span><br><span class="line">-- （2）通过distinct关键字处理原表，将获得的记录复制到my_tmp</span><br><span class="line">INSERT INTO emp2</span><br><span class="line">	SELECT DISTINCT * FROM emp3;</span><br><span class="line">SELECT * FROM emp3;</span><br><span class="line">-- （3）清除掉原表记录</span><br><span class="line">DELETE FROM emp3;</span><br><span class="line">-- （4）把my_tmp表的记录复制到原表</span><br><span class="line">INSERT INTO emp3 </span><br><span class="line">	SELECT * FROM emp2;</span><br><span class="line">-- （5）drop掉临时表</span><br><span class="line">DROP TABLE emp2;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>合并查询</p>
<p>有时在实际应用中，为了合并多个select语句的结果，可以使用集合操作符号union、union all</p>
<ol>
<li><p>union all</p>
<p>该操作符用于取得两个结果集的并集。当使用该操作符时，不会取消重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal from emp where sal&gt;2500 </span><br><span class="line">union all</span><br><span class="line">select ename,sal from emp where job = &#x27;MANAGER&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>union</p>
<p>该操作符与union all相似，但是会自动去掉结果集中重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal from emp where sal&gt;2500 </span><br><span class="line">union</span><br><span class="line">select ename,sal from emp where job = &#x27;MANAGER&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><ul>
<li><p>count返回行的总数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*)|count(列名) from tableName</span><br><span class="line">	[where where_definition];</span><br><span class="line">	</span><br><span class="line">-- 解释：</span><br><span class="line">-- count(*)：返回满足条件的记录的行数</span><br><span class="line">-- count(列)：统计满足条件的某列有多少个，但是会排除 为null</span><br></pre></td></tr></table></figure></li>
<li><p>合计函数——sum</p>
<p>sum函数返回满足where条件的行的和，一般使用在数值列上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(列名) &#123;,sum(列名)……&#125; from tableName</span><br><span class="line">	[where where_definition];</span><br><span class="line">	</span><br><span class="line">-- 注意：sum仅对数值起作用，否则会报错</span><br><span class="line">-- 注意：对多列求和，“，”号不能少</span><br></pre></td></tr></table></figure></li>
<li><p>合计函数——avg</p>
<p>avg函数返回满足where条件的一列的平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select avg(列名) &#123;,avg(列名)……&#125; from tableName</span><br><span class="line">	[where where_definition];</span><br></pre></td></tr></table></figure></li>
<li><p>合计函数——max/min</p>
<p>max/min函数返回满足where条件的一列的最大/最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(列名) from tableName</span><br><span class="line">	[where where_definition];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><table>
<thead>
<tr>
<th align="center">时间日期相关函数</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">current_date()</td>
<td align="center">当前日期</td>
</tr>
<tr>
<td align="center">current_time()</td>
<td align="center">当前时间</td>
</tr>
<tr>
<td align="center">current_timestamp()</td>
<td align="center">当前时间戳</td>
</tr>
<tr>
<td align="center">date(datetime)</td>
<td align="center">返回datetime的日期部分</td>
</tr>
<tr>
<td align="center">date_add(date2,interval d_value d_type)</td>
<td align="center">在date2上加上时间或日期</td>
</tr>
<tr>
<td align="center">date_sub(date2,interval d_value d_type)</td>
<td align="center">在date2上减去一个时间</td>
</tr>
<tr>
<td align="center">datediff(date1,date2)</td>
<td align="center">两个日期差（结果是多少天）</td>
</tr>
<tr>
<td align="center">timediff(date1,date2)</td>
<td align="center">两个时间差（多少小时多少分钟多少秒）</td>
</tr>
<tr>
<td align="center">now()</td>
<td align="center">当前时间</td>
</tr>
<tr>
<td align="center">year|month|date(datetime)</td>
<td align="center">返回年、月、日</td>
</tr>
<tr>
<td align="center">unix_timestamp()</td>
<td align="center">返回的是1970-1-1到现在的秒数</td>
</tr>
<tr>
<td align="center">from_unixtime()</td>
<td align="center">把一个unix_timestamp秒数转成指定格式日期</td>
</tr>
</tbody></table>
<ul>
<li><p>细节说明</p>
<table>
<thead>
<tr>
<th align="center">时间日期相关函数</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date(datetime)</td>
<td align="center">返回datetime的日期部分</td>
</tr>
<tr>
<td align="center">date_add(date2,interval d_value d_type)</td>
<td align="center">在date2上加上时间或日期</td>
</tr>
<tr>
<td align="center">date_sub(date2,interval d_value d_type)</td>
<td align="center">在date2上减去一个时间</td>
</tr>
<tr>
<td align="center">datediff(date1,date2)</td>
<td align="center">两个日期差（结果是多少天）</td>
</tr>
</tbody></table>
<ul>
<li>date_add()中的interval后面可以是year、month、day、hour、minute、second等</li>
<li>date_sub()中的interval后面可以是year、month、day、hour、minute、second等</li>
<li>datediff(date1,date2)得到的是天数，而且是date1-date2的天数，因此可以是负数</li>
<li>这四个函数的日期类型可以是date、datetime或者timestamp</li>
<li>在实际开发中，我们也常使用int来保存一个unix时间戳，然后使用from_unixtime()进行转换，还是非常有价值的</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mes(</span><br><span class="line">	id INT UNSIGNED,</span><br><span class="line">	context VARCHAR(100),</span><br><span class="line">	send_datetime DATETIME</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO mes VALUES(1,&#x27;朝闻天下&#x27;,NOW());</span><br><span class="line">INSERT INTO mes VALUES(2,&#x27;午夜新闻&#x27;,CURRENT_TIMESTAMP());</span><br><span class="line"></span><br><span class="line">SELECT * FROM mes;</span><br><span class="line">-- date()/time()</span><br><span class="line">SELECT id,content,TIME(send_datetime) FROM mes;</span><br><span class="line"></span><br><span class="line">-- 返回20分钟之内发布的信息</span><br><span class="line">-- date_sub(date1,interval d_value d_type)</span><br><span class="line">SELECT id,content,send_datetime FROM mes</span><br><span class="line">WHERE send_datetime BETWEEN DATE_SUB(NOW(),INTERVAL 20 MINUTE) AND NOW();</span><br><span class="line">-- detediff()</span><br><span class="line">SELECT DATEDIFF(&#x27;2011-11-11&#x27;,&#x27;1999-1-1&#x27;) AS 相差天数 FROM DUAL;</span><br><span class="line">SELECT DATEDIFF(&#x27;2075-5-12&#x27;,&#x27;1995-5-12&#x27;) FROM DUAL;</span><br><span class="line">-- datediff()   date_add()</span><br><span class="line">SELECT DATEDIFF(DATE_ADD(&#x27;1995-5-12&#x27;,INTERVAL 80 YEAR),NOW()) AS 存在天数 FROM DUAL;</span><br><span class="line">-- year()</span><br><span class="line">SELECT YEAR(NOW()) FROM DUAL;</span><br><span class="line">-- unix_timestamp()</span><br><span class="line">SELECT CONCAT(FORMAT(UNIX_TIMESTAMP()/60/60/24/365,2),&#x27;年&#x27;) AS 1970年至今 FROM DUAL;</span><br><span class="line">-- from_unixtime()</span><br><span class="line">SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(),&#x27;%Y--%m--%d,%H:%i:%s&#x27;) FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th align="center">字符串相关函数</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">charset(str)</td>
<td align="center">返回字符串字符集</td>
</tr>
<tr>
<td align="center">concat(string2 [, …..])</td>
<td align="center">连接字符串</td>
</tr>
<tr>
<td align="center">instr(string,substring)</td>
<td align="center">返回substring在string中出现的位置，没有返回0</td>
</tr>
<tr>
<td align="center">ucase(string)</td>
<td align="center">转换成大写</td>
</tr>
<tr>
<td align="center">lcase(string)</td>
<td align="center">转换成小写</td>
</tr>
<tr>
<td align="center">left/right(string2,length)</td>
<td align="center">从string2中左/右边起取length个字符</td>
</tr>
<tr>
<td align="center">length(string)</td>
<td align="center">string长度【按照字节】</td>
</tr>
<tr>
<td align="center">replace(str,search_str,replace_str)</td>
<td align="center">在str中用replace_str替换search_str</td>
</tr>
<tr>
<td align="center">strcmp(string1,string2)</td>
<td align="center">逐字符比较两字串大小</td>
</tr>
<tr>
<td align="center">substring(str,position [,length])</td>
<td align="center">从str的position开始【从1开始计算】，取length个字符</td>
</tr>
<tr>
<td align="center">ltrim(str)/rtrim(str)</td>
<td align="center">去除前端空格或后端空格</td>
</tr>
<tr>
<td align="center">trim（str）</td>
<td align="center">去除前后端空格</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- concat</span><br><span class="line">select concat(ename,&#x27;工作是&#x27;,job) from emp;</span><br><span class="line">-- instr</span><br><span class="line">-- dual：亚元表，系统表 可以作为测试表使用</span><br><span class="line">select instr(&#x27;liyouuulalal&#x27;,&#x27;la&#x27;) from dual;</span><br><span class="line">-- 以首字母小写的方式显示所有员工的昵称</span><br><span class="line">SELECT `name`,CONCAT(LCASE(SUBSTRING(`mini_name`,1,1)),SUBSTRING(`mini_name`,2)) AS &#x27;昵称&#x27; FROM emp;</span><br></pre></td></tr></table></figure>

<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table>
<thead>
<tr>
<th align="center">数学相关函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abs(num)</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">ceiling(num)</td>
<td align="center">向上取整，得到比num大的最小整数</td>
</tr>
<tr>
<td align="center">conv(number,from_base,to_base)</td>
<td align="center">进制转换</td>
</tr>
<tr>
<td align="center">floor(num)</td>
<td align="center">向下取整，得到比num小的最大整数</td>
</tr>
<tr>
<td align="center">format(num,decimal_places)</td>
<td align="center">保留小数位数（四舍五入）</td>
</tr>
<tr>
<td align="center">hex(DecimalNumber)</td>
<td align="center">转十六进制</td>
</tr>
<tr>
<td align="center">least(num,num2 [,……..])</td>
<td align="center">求最小值</td>
</tr>
<tr>
<td align="center">mod(numerator,denominator)</td>
<td align="center">求余</td>
</tr>
<tr>
<td align="center">bin(decimal_number)</td>
<td align="center">十进制转二进制</td>
</tr>
<tr>
<td align="center">rand([seed])</td>
<td align="center">其范围为0 &lt;= v &lt;= 1.0</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- conv</span><br><span class="line">-- 将十进制转换成二进制</span><br><span class="line">SELECT CONV(14,10,2) FROM DUAL;</span><br><span class="line">-- 输出1110</span><br><span class="line"></span><br><span class="line">-- format：保留小数位后俩位</span><br><span class="line">SELECT FORMAT(21.1111,2) FROM DUAL;</span><br><span class="line"></span><br><span class="line">-- rand()：产生一个随机数</span><br><span class="line">-- rand([seed])：固定的随机数</span><br><span class="line">SELECT RAND(2) FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="加密和系统函数"><a href="#加密和系统函数" class="headerlink" title="加密和系统函数"></a>加密和系统函数</h3><table>
<thead>
<tr>
<th align="center">函数名称</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user()</td>
<td align="center">查询登录mysql的有哪些用户，以及登录的IP，返回用户@IP地址</td>
</tr>
<tr>
<td align="center">database()</td>
<td align="center">查询当前数据库名称</td>
</tr>
<tr>
<td align="center">md5(str)</td>
<td align="center">为字符串算出一个（MD5） 32位的字符串，（为用户密码）加密</td>
</tr>
<tr>
<td align="center">password(str)</td>
<td align="center">从原文密码str计算并返回密码字符串，通常用于对mysql数据库的用户密码加密</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE hsp_user(</span><br><span class="line">	id INT UNSIGNED,</span><br><span class="line">	`user` VARCHAR(20),</span><br><span class="line">	pwd CHAR(32)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">SELECT * FROM hsp_user;</span><br><span class="line"></span><br><span class="line">INSERT INTO hsp_user VALUES(1,&#x27;小刘&#x27;,MD5(&#x27;123456&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><table>
<thead>
<tr>
<th align="center">函数名称</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">if（expr1，expr2，expr3）</td>
<td align="center">如果expr1为true，则返回expr2，否则返回expr3</td>
</tr>
<tr>
<td align="center">ifnull（expr1，expr2）</td>
<td align="center">如果expr1为空null，则expr2；否则返回它本身</td>
</tr>
<tr>
<td align="center">select case when expr1 then expr2 when expr3 then expr4 else expr5 end；【类似多重分支】</td>
<td align="center">如果expr1为true，则返回expr2；如果expr3为true，则返回expr4；否则返回expr5</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT IF(FALSE,&#x27;北京&#x27;,&#x27;上海&#x27;) FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT IFNULL(NULL,&#x27;一个字符串&#x27;) FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT CASE </span><br><span class="line">    WHEN FALSE THEN &#x27;情况一&#x27;</span><br><span class="line">    WHEN TRUE THEN &#x27;情况二&#x27;</span><br><span class="line">    ELSE &#x27;情况三&#x27; END AS 选择语句;</span><br><span class="line">    </span><br><span class="line">select ename,if(comm is null, 0.0, comm) from emp;</span><br><span class="line">select ename,ifnull(comm,0.0) from emp;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><ul>
<li><p>提出一个问题</p>
<ol>
<li><p>前面我们学习的查询，是利用where子句对两张表或者多张表，形成的笛卡尔积进行筛选，根据关联条件，显示所有匹配的记录，匹配不上的，不显示的</p>
</li>
<li><p>比如：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dept.dname,ename,emp.job</span><br><span class="line">		from emp,dept</span><br><span class="line">		where emp.deptno = dept.deptno;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>外连接</p>
<ol>
<li><p>左外连接（如果<strong>左侧的表完全显示</strong>，我们就说是左外连接）</p>
</li>
<li><p>右外连接（如果<strong>右侧的表完全显示</strong>我们就说是右外连接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT UNSIGNED,</span><br><span class="line">	`name` VARCHAR(20)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">INSERT INTO stu </span><br><span class="line">	VALUES(1,&#x27;Jack&#x27;),</span><br><span class="line">	(2,&#x27;Tom&#x27;),</span><br><span class="line">	(3,&#x27;Kity&#x27;),</span><br><span class="line">	(4,&#x27;nono&#x27;);</span><br><span class="line">	</span><br><span class="line">CREATE TABLE exam(</span><br><span class="line">	id INT UNSIGNED,</span><br><span class="line">	grade INT UNSIGNED</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">INSERT INTO exam</span><br><span class="line">	VALUES(1,56),</span><br><span class="line">	(2,76),</span><br><span class="line">	(11,8);</span><br><span class="line">SELECT * FROM stu;</span><br><span class="line">SELECT * FROM exam;</span><br><span class="line">-- 同时显示学号、姓名和成绩</span><br><span class="line">SELECT stu.id,`name`,grade</span><br><span class="line">	FROM stu,exam</span><br><span class="line">	WHERE stu.`id` = exam.`id`;</span><br><span class="line">	</span><br><span class="line">-- 左外连接</span><br><span class="line">SELECT stu.`id`,stu.`name`,exam.`grade`</span><br><span class="line">	FROM stu LEFT JOIN exam</span><br><span class="line">	ON stu.`id` = exam.`id`;</span><br><span class="line">-- 右外连接</span><br><span class="line">SELECT stu.`id`,stu.`name`,exam.`grade`</span><br><span class="line">	FROM stu RIGHT JOIN exam</span><br><span class="line">	ON stu.`id` = exam.`id`;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li><p>基本介绍</p>
<p>约束用于确保数据库的数据满足特定的商业规划</p>
<p>在MySQL中，约束包括：not null、unique、primary key、foreign key和check五种</p>
</li>
</ul>
<h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h3><ul>
<li><p>primary key（主键）——基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 primary key</span><br></pre></td></tr></table></figure>

<p>用于唯一的表示表行的数据，当定义主键约束后，该列不能重复</p>
</li>
<li><p>primary key（主键）——细节说明</p>
<ol>
<li><p>primary key不能重复而且不能为null</p>
</li>
<li><p>一张表最多只能有一个主键，但可以是复合主键（多个条件同时相同才违反约束）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t17(</span><br><span class="line">	id INT UNSIGNED,</span><br><span class="line">	`name` VARCHAR(20),</span><br><span class="line">	email VARCHAR(30),</span><br><span class="line">    PRIMARY KEY (id,`name`) -- 这里就是复合主键</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br></pre></td></tr></table></figure></li>
<li><p>主键指定的方式有两种</p>
<ul>
<li>直接字段后指定：primary key</li>
<li>在表定义最后写primary key（列名）</li>
</ul>
</li>
<li><p>使用desc 表名，可以看到primary key的情况</p>
</li>
<li><p>在实际开发中，每个表往往都会设计一个主键</p>
</li>
</ol>
</li>
</ul>
<h3 id="not-null-amp-amp-unique"><a href="#not-null-amp-amp-unique" class="headerlink" title="not null &amp;&amp; unique"></a>not null &amp;&amp; unique</h3><ul>
<li><p>not null（非空）</p>
<p>如果在列上定义了not null，那么当插入数据时，必须为列提供数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 not null</span><br></pre></td></tr></table></figure></li>
<li><p>unique（唯一）</p>
<p>当定义了唯一约束后，该列是不能重复的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 unique</span><br></pre></td></tr></table></figure></li>
<li><p>unique细节（注意）</p>
<ol>
<li>如果没有指定not null，则unique字段可以有多个null</li>
<li>一张表可以有多个unique字段</li>
</ol>
</li>
</ul>
<h3 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h3><ul>
<li><p>foreign key（外键）</p>
<p>用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须具有主键约束或是unique约束，当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOREIGN KEY (本表字段名) REFERENCES 主表名（主键名或unique字段名）</span><br></pre></td></tr></table></figure>

<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\外键示意图.png"/>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE my_class(</span><br><span class="line">	id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">	`name` VARCHAR(32),</span><br><span class="line">	addr VARCHAR(32)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE my_stu(</span><br><span class="line">	id INT UNSIGNED,</span><br><span class="line">	`name` VARCHAR(32),</span><br><span class="line">	class_id INT UNSIGNED,</span><br><span class="line">	-- 指定外键关系</span><br><span class="line">	FOREIGN KEY (class_id) REFERENCES class(id)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">-- 先往主表里添加数据</span><br><span class="line">INSERT INTO my_class</span><br><span class="line">	VALUES(10,&#x27;一班&#x27;,&#x27;beijing&#x27;),</span><br><span class="line">	(20,&#x27;二班&#x27;,&#x27;beijing&#x27;);</span><br><span class="line"></span><br><span class="line">-- 从表进行测试	</span><br><span class="line">INSERT INTO my_stu</span><br><span class="line">	VALUES(1,&#x27;张三&#x27;,10),</span><br><span class="line">	(2,&#x27;李四&#x27;,10),</span><br><span class="line">	(3,&#x27;王朝&#x27;,20),</span><br><span class="line">	(4,&#x27;马汉&#x27;,20);</span><br><span class="line">INSERT INTO stu VALUES(5,&#x27;展昭&#x27;,30); -- 失败</span><br><span class="line">	</span><br><span class="line">SELECT * FROM my_class;</span><br><span class="line">SELECT * FROM my_stu; </span><br></pre></td></tr></table></figure></li>
<li><p>foreign key(外键)——细节说明</p>
<ol>
<li>外键指向的表的字段要求是primary key或者是unique</li>
<li>表的类型是innodb，这样的表才支持外键</li>
<li>外键字段的类型要和主键字段的类型一致（长度可以不同）</li>
<li>外键字段的值，必须在主键字段中出现过，或者为null【前提是外键字段允许为null】</li>
<li>一旦建立主外键的关系，数据就不能随意删除了</li>
</ol>
</li>
<li><p>练习</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\外键练习.png"/>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE shop_db;</span><br><span class="line"></span><br><span class="line">CREATE TABLE goods(</span><br><span class="line">	goods_id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">	goods_name VARCHAR(32),</span><br><span class="line">	unitprice FLOAT CHECK(unitprice BETWEEN 1.0 AND 9999.99),</span><br><span class="line">	category VARCHAR(32),</span><br><span class="line">	provider VARCHAR(32)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">CREATE TABLE customer(</span><br><span class="line">	customer_id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">	`name` VARCHAR(32) NOT NULL,</span><br><span class="line">	addr VARCHAR(32),</span><br><span class="line">	email VARCHAR(32) UNIQUE,</span><br><span class="line">	sex CHAR(1),</span><br><span class="line">	card_id VARCHAR(32)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">CREATE TABLE purchase(</span><br><span class="line">	order_id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">	customer_id INT UNSIGNED,</span><br><span class="line">	goods_id INT UNSIGNED,</span><br><span class="line">	nums INT UNSIGNED,</span><br><span class="line">	</span><br><span class="line">	FOREIGN KEY (customer_id) REFERENCES customer(customer_id),</span><br><span class="line">	FOREIGN KEY (goods_id) REFERENCES goods(goods_id)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">INSERT INTO goods</span><br><span class="line">	VALUES(101,&#x27;巧克力&#x27;,20,&#x27;休闲食品&#x27;,&#x27;德福&#x27;),</span><br><span class="line">	(201,&#x27;晾衣架&#x27;,30,&#x27;生活用品&#x27;,&#x27;苏果&#x27;);</span><br><span class="line">	</span><br><span class="line">DELETE FROM goods;</span><br><span class="line">SELECT * FROM goods;</span><br><span class="line">INSERT INTO customer</span><br><span class="line">	VALUES(1,&#x27;张龙&#x27;,&#x27;北京&#x27;,&#x27;123@163.com&#x27;,&#x27;男&#x27;,&#x27;321084199506092111&#x27;),</span><br><span class="line">	(2,&#x27;赵虎&#x27;,&#x27;北京&#x27;,&#x27;1232121@163.com&#x27;,&#x27;男&#x27;,&#x27;321084199506092111&#x27;);</span><br><span class="line">	</span><br><span class="line">INSERT INTO purchase</span><br><span class="line">	VALUES(1001,1,101,2);</span><br><span class="line">SELECT * FROM purchase;</span><br><span class="line">INSERT INTO purchase</span><br><span class="line">	VALUES(1002,2,201,2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><ul>
<li><p>check</p>
<p>用于强制行数据必须满足的条件，假定在sal列上定义了check约束，并要求sal列值在1000~~2000之间就会提示错误。</p>
<p>Oracle和sql server均支持check，但是mysql5.7目前还不支持check，只做语法校验，但不会生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本语法：列名	类型	check（check的条件）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user`(</span><br><span class="line">	id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">	`name` VARCHAR(32),</span><br><span class="line">	sex VARCHAR(32) CHECK(sex IN(&#x27;man&#x27;,&#x27;woman&#x27;)),</span><br><span class="line">	sal INT UNSIGNED CHECK(sal BETWEEN 100 AND 900)</span><br><span class="line">	)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line">	</span><br><span class="line">INSERT INTO `user`</span><br><span class="line">	VALUES(1,&#x27;炭之郎&#x27;,&#x27;man&#x27;,500);</span><br><span class="line">SELECT * FROM USER;</span><br><span class="line">INSERT INTO `user`</span><br><span class="line">	VALUES(3,&#x27;炭之郎&#x27;,&#x27;mansas&#x27;,5000);</span><br></pre></td></tr></table></figure>

<p>在MySQL中实现check的功能，一般是在程序中控制，或者通过触发器完成</p>
</li>
</ul>
<h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><ul>
<li><p>自增长基本介绍  一个问题</p>
<p>在某张表中，存在一个id列（整数），我们希望在添加记录的时候，该列从1开始，自动的增长，怎么处理？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名	整型	primary key auto_increment</span><br></pre></td></tr></table></figure>

<p>添加自增长的字段方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into XXX(字段1,字段2……) values(null,&#x27;值&#x27;……);</span><br><span class="line">insert into XXX(字段2……) values(&#x27;值1&#x27;,&#x27;值2&#x27;……);</span><br><span class="line">insert into XXX values(null,&#x27;值1&#x27;……);</span><br></pre></td></tr></table></figure></li>
<li><p>自增长使用细节</p>
<ol>
<li><p>一般来说自增长是和primary key配合使用的</p>
</li>
<li><p>自增长也可以单独使用【但需要配合一个unique】</p>
</li>
<li><p>自增长修饰的字段为整数型的（虽然小数也可以，但是非常非常少这样使用）</p>
</li>
<li><p>自增长默认从1开始，你也可以通过如下命令修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 auto_increment = 新的起始值;</span><br></pre></td></tr></table></figure></li>
<li><p>如果你添加数据时，给自增长字段（列）指定的有值，则以指定的值为准，如果指定了自增长，一般来说，就按照自增长的规则来添加数据</p>
</li>
</ol>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>说起提高数据库性能，索引是最物美价廉的东西了，不用加内存，不用改程序，不用调sql，查询速度就可能提高百倍千倍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 表示在emp表的empno列创建索引</span><br><span class="line">create index empno_index on emp(empno);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>索引的原理</p>
<p>没有索引为什么会慢？</p>
<p>答：当我们没有索引时，数据库管理系统会进行全表扫描，查询速度慢</p>
<p>使用索引为什么会快？</p>
<p>答：形成一个索引的数据结构，比如二叉树</p>
<p>索引的代价</p>
<ol>
<li>磁盘占用</li>
<li>对dml（update、dalete、insert）语句的效率影响</li>
</ol>
<p>韩老师告诉你：在我们的项目中，select【90%】语句要比update、delete、insert【10%】语句多得多</p>
</li>
<li><p>主键索引，主键自动的为主索引（类型Primary key）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t1(</span><br><span class="line">	id int primary key, -- 主键，同时也是索引，称为主键索引</span><br><span class="line">    enanme varchar(32)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure></li>
<li><p>唯一索引（UNIQUE）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">	id int unique, -- id是唯一的，同时也是索引，称为unique索引</span><br><span class="line">    ename varchar(32)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure></li>
<li><p>普通索引（INDEX）</p>
</li>
<li><p>全文索引（FULLTEXT）【适用于MyISAM】</p>
<p>一般开发不使用MySQL自带的全文索引，而是考虑使用：全文搜索Solr和ElasticSearch（ES）</p>
</li>
<li><p>索引使用</p>
<ol>
<li><p>添加索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [unique] index index_name </span><br><span class="line">	on tab_name(col_name[(length)] [ASC|DESC],……);</span><br><span class="line"></span><br><span class="line">alter table tab_name</span><br><span class="line">	add [unique] index[index_name](index_col_name,……);</span><br></pre></td></tr></table></figure></li>
<li><p>添加主键（索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tab_name </span><br><span class="line">	add primary key (列名);</span><br></pre></td></tr></table></figure></li>
<li><p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_name on tab_name;</span><br><span class="line"></span><br><span class="line">alter table tab_name </span><br><span class="line">	drop index index_name;</span><br></pre></td></tr></table></figure></li>
<li><p>删除主键索引 比较特别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t_b drop primary key;</span><br></pre></td></tr></table></figure></li>
<li><p>修改索引</p>
<p>先删除，再添加新的索引</p>
</li>
<li><p>查询索引</p>
<ul>
<li><p>```mysql<br>show index from tab_name;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  show indexes from tab_name;</span><br></pre></td></tr></table></figure></li>
<li><p>```mysql<br>show keys from tab_name;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  desc tab_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>小结：哪些列上适合使用索引</p>
<ol>
<li>较频繁的作为条件的字段应该创建索引</li>
<li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li>
<li>更新非常频繁的字段不适合创建索引</li>
<li>不会出现再WHERE子句中的字段不该创建索引</li>
</ol>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li><p><strong>事务引入</strong></p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\事务引入.png"/>

<ul>
<li><p>什么是事务</p>
<p>事务用于保存数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败。如：转账就要用事务来处理，用以保存数据的一致性。</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\事务操作示意图.png"/></li>
<li><p>事务和锁</p>
</li>
</ul>
<p>​       当给执行事务操作时（dml语句），MySQL会再表上加锁，防止其他用户该表的数据，这对用户来讲是非 常重要的  </p>
</li>
<li><p><strong>MySQL数据库控制台事务的几个重要操作</strong></p>
<ol>
<li><p>```mysql<br>start transaction – 开始一个事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```mysql</span><br><span class="line">   savepoint -- 保存点名，设置保存点</span><br></pre></td></tr></table></figure></li>
<li><p>```mysql<br>rollback to – 保存点名，回退事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```mysql</span><br><span class="line">   rollback -- 回退全部事务</span><br></pre></td></tr></table></figure></li>
<li><p>```mysql<br>commit – 提交事务，所有的操作生效，不能回退</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  细节：</span><br><span class="line"></span><br><span class="line">  - 没有设置保存点</span><br><span class="line">  - 多个保存点</span><br><span class="line">  - 存储引擎</span><br><span class="line">  - 开始事务方式</span><br><span class="line"></span><br><span class="line">  回退事务</span><br><span class="line"></span><br><span class="line">  在介绍回退事务前，先介绍一下保存点（savepoint），保存点是事务中的点，用于取消部分事务，当结束事务时，会自动地删除该事务所定义地所有保存点，当执行回退事务时，通过指定保存点可以回退到指定地点</span><br><span class="line"></span><br><span class="line">  提交事务</span><br><span class="line"></span><br><span class="line">  使用commit语句可以提交事务，当执行了commit语句之后，会确认事务的变化、结束事务、删除保存点、释放锁、数据生效。当使用commit语句结束事务之后，其他会话将可以查到事务变化后地新数据。</span><br><span class="line"></span><br><span class="line">  事务细节讨论</span><br><span class="line"></span><br><span class="line">  1. 如果不开始事务，默认情况下，dml操作是自动提交的，不能回退</span><br><span class="line">  2. 如果开始一个事务，你没有创建保存点，你可以执行rollback，默认就是回退到你事务开始的状态</span><br><span class="line">  3. 你也可以在事务中（还没有提交），创建多个保存点，比如savepoint aaa；执行dml，savepoint bbb；</span><br><span class="line">  4. 你也可以在这个事务没有提交前，选择回退到哪个保存点</span><br><span class="line">  5. mysql的事务机制需要innodb的存储引擎还可以使用，myisam不好使</span><br><span class="line"></span><br><span class="line">  开始一个事务:</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">start transanction, set autocommit = off;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>MySQL事务隔离级别</strong></p>
<ol>
<li><p>多个连接开启各自事务操作数据库中数据时，数据库系统负责隔离操作，以保证各个连接在获取数据时的准确性（通俗解释）</p>
</li>
<li><p>如果不考虑隔离性，可能会引发如下问题：</p>
<p>正常状态：一端进入事务后，能够读取的数据应该是进入事务前拥有的数据。</p>
<ul>
<li><p>脏读（dirty read）</p>
<p>当一个事务读取另一个事务尚未提交的修改（dml）时，产生脏读。</p>
</li>
<li><p>不可重复读（nonrepeatable read）</p>
<p>同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同的结果集，此时发生不可重复读。</p>
</li>
<li><p>幻读（phantom read）</p>
<p>同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>插入</strong>操作，每次返回不同的结果集，此时发生幻读。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>事务隔离级别</p>
<p>概念：MySQL隔离级别定义了事务与事务之间的隔离程度</p>
<table>
<thead>
<tr>
<th align="center">MySQL隔离级别（4种）</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th align="center">加锁读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（Read uncommitted）</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">不加锁</td>
</tr>
<tr>
<td align="center">读已提交（Read commited）</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">不加锁</td>
</tr>
<tr>
<td align="center">可重复读（Repeatable Read）</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">不加锁</td>
</tr>
<tr>
<td align="center">可串行化（Serializable）</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">加锁</td>
</tr>
</tbody></table>
<p>说明：Y：可能出现</p>
<p>​            N：不会出现</p>
<p>​    可串行化（Serializable）：当隔离级别为Serializable的表正在被操作时，其他客户端无法操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.查看当前会话的隔离级别</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line">-- 2.查看系统当前的隔离级别</span><br><span class="line">SELECT @@global.tx_isolation;</span><br><span class="line">-- 3.设置当前会话的隔离级别</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">-- 4.设置系统当前隔离级别</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​        MySQL默认的事务隔离级别是repeatable read，一般情况下，没有特殊要求，没有必要修改（因为该级别可以满足绝大部分项目需求）</p>
<ul>
<li><p>全局修改隔离级别</p>
<p>修改my.ini配置文件，在最后加上</p>
<p>可选参数有：READ-UNCOMMITTED/READ-COMMITTED/REPEATABLE-READ/SERIAILABLE</p>
<p>[mysqld]</p>
<p>transaction-isolation = REPEATABLE-READ</p>
</li>
<li><p>事务的acid特性</p>
<ol>
<li><p>原子性（Atomicity）</p>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</p>
</li>
<li><p>一致性（Consistency）</p>
<p>事务必须使数据库从一个一致性状态变换到另一个一致性状态</p>
</li>
<li><p>隔离性（Isolation）</p>
<p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离</p>
</li>
<li><p>持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>MySQL表类型和存储引擎</strong></p>
<ul>
<li><p>基本介绍</p>
<ol>
<li><p>MySQL的表类型由存储引擎（Storage Engines）决定，主要包括MyISAM、innodb、Memory等</p>
</li>
<li><p>MySQL数据表主要支持六种类型，分别是：CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、Innodb。</p>
</li>
<li><p>这六种又分为两类，一类是“事务安全型”（transaction-safe），比如：Innodb；其余都属于第二类，称为“非事务安全型”（non-transaction-safe）【myisam和memory】。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 显示当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>主要的存储引擎/表类型特点</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\存储引擎的特点.png"/></li>
<li><p>细节说明</p>
<p>重点介绍三种：MyISAM、InnoDB、MEMORY</p>
<ol>
<li>MyISAM不支持事务、也不支持外键，但其访问速度快，对事务完整性没有要求</li>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索引。但是一旦服务关闭，表中的数据就会丢失掉，表的结构还在。</li>
</ol>
</li>
<li><p>三种存储引擎表的使用案例</p>
<ol>
<li>InnoDB<ul>
<li>支持事务</li>
<li>支持外键</li>
<li>支持行级锁</li>
</ul>
</li>
<li>MyISAM<ul>
<li>添加速度快</li>
<li>不支持外键和事务</li>
<li>支持表级锁</li>
</ul>
</li>
<li>MEMORY<ul>
<li>数据存储在内存中【关闭了MySQL服务，数据丢失，但是表结构还在】</li>
<li>执行速度很快（没有I/O读写）</li>
<li>支持索引（Hash表）</li>
</ul>
</li>
</ol>
</li>
<li><p>如何选择表的存储引擎</p>
<ol>
<li>如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二之选，速度快</li>
<li>如果需要支持事务，选择InnoDB</li>
<li>Memory存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失（经典用法：用户的在线状态）</li>
</ol>
</li>
<li><p>修改存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table `表名` engine = 存储引擎;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li><p>看一个需求</p>
<p>emp表的列信息很多，有些信息是个人重要信息（比如：sal、comm、mgr、hiredate），如果我们希望某个用户只能查询emp表的（empno、ename、job和deptno）信息，有什么办法？</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\emp表.png"/></li>
<li><p>基本概念</p>
<ol>
<li><p>视图是一个虚拟表，其内容由查询定义。同真是的表一样，视图包含列，其数据来自对应的真实表（基表）</p>
</li>
<li><p>视图与基表关系的示意图</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\视图与基表的关系.png"/></li>
</ol>
</li>
<li><p>视图的基本使用</p>
<ol>
<li>create view 视图名 as select语句</li>
<li>alter view 视图名 as select 语句</li>
<li>show create view 视图名</li>
<li>drop view 视图1，视图2</li>
</ol>
</li>
<li><p>完成前面提出的需求</p>
<p>创建一个视图emp_view01，只能查询emp表（empno、ename、job和deptno）信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_view01 </span><br><span class="line">	AS </span><br><span class="line">	SELECT empno,ename,deptno,sal FROM emp;</span><br></pre></td></tr></table></figure></li>
<li><p>视图细节讨论</p>
<ol>
<li>创建视图后，到数据库去看，对应视图只有一个视图结构文件（形式：视图名.frm）</li>
<li>视图的数据变化会影响到基表，基表的数据变化也会影响到视图</li>
<li>试图中可以再使用视图</li>
</ol>
</li>
<li><p>视图最佳实践</p>
<ol>
<li>安全。一些数据表有着重要的信息，有些字段是保密的，不能让用户直接看到，这时就可以创建一个视图，在这张视图中只保留一部分字段，这样，用户就可以查询自己需要的字段，不能查看保密的字段</li>
<li>性能。关系数据库的数据常常会分表存储，使用外键建立这些表之间的关系，这时，数据库查询通常会用到连接（JOIN）。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起，就可以避免使用JOIN查询数据。</li>
<li>灵活。如果系统中有一张旧的表，这张表由于设计问题，即将被废弃。然而很多应用都是基于这张表，不宜修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。</li>
</ol>
</li>
</ul>
<h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><ul>
<li><p>MySQL用户</p>
<p>mysql中的用户，都存储在系统数据库mysql中user中</p>
<img src= "/img/lazyload1.gif" data-lazy-src="..\Java基础查漏补缺\表user.png"/>

<p>其中user表的重要字段说明：</p>
<ol>
<li><p>host</p>
<p>允许登录的“位置”，localhost表示该用户只允许本机登录，也可以指定ip地址，比如：192.168.1.100</p>
</li>
<li><p>user</p>
<p>用户名</p>
</li>
<li><p>authentication_string</p>
<p>密码，是通过mysql的password（）函数加密之后的密码</p>
</li>
</ol>
</li>
<li><p>创建用户</p>
<p>当我们做项目开发时，可以根据不同的开发人员，赋给他们相应的MySQL操作权限。</p>
<p>不同的数据库用户，登录到DBMS后，根据相应的权限，可以操作的数据库和数据对象（表、视图、触发器）都不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建用户，同时指定密码</span><br><span class="line">create user &#x27;用户名&#x27; @ &#x27;允许登录位置&#x27; identified by &#x27;密码&#x27; </span><br><span class="line">create user &#x27;hsp_edu&#x27;@localhost identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27; @ &#x27;允许登陆位置&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>用户修改密码</p>
<p>修改自己的密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set password = password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure>

<p>修改他人的密码（需要有修改用户密码权限）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set password for &#x27;用户名&#x27;@ &#x27;登陆位置&#x27; = password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>给用户授权</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限列表 on 库.对象名 to &#x27;用户名&#x27;@ &#x27;登陆位置&#x27; 【identified by &#x27;密码&#x27;】;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>权限列表，多个权限用逗号分开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant select on...</span><br><span class="line">grant select,delete,create on...</span><br><span class="line">grant all [privileges] on ...     //表示赋予该用户在该对象上的所有权限 </span><br></pre></td></tr></table></figure></li>
<li><p>特别说明</p>
<p>*. *：代表本系统中的所有数据库的所有对象（表、视图、存储过程）</p>
<p>库.*：表示某个数据库中的所有数据对象（表、视图、存储过程）</p>
</li>
<li><p>identified by 可以省略，也可以写出</p>
<ul>
<li>如果用户存在，就是修改该用户的密码</li>
<li>如果该用户不存在，就是创建该用户</li>
</ul>
</li>
</ol>
</li>
<li><p>回收用户授权</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke 权限列表 on 库.对象名 from &#x27;用户名&#x27;@ &#x27;登陆位置&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>权限生效指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如果权限没有生效，可以执行下面命令</span><br><span class="line">-- 基本语法：</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>细节说明</p>
<ol>
<li><p>在创建用户的时候，如果不指定host，则为%，%表示所有IP都有连接权限</p>
<p>create user xxx;</p>
</li>
<li><p>你也可以这样指定</p>
<p>create user ’xxx‘@192.168.1.%;</p>
<p>表示xxx用户在192.168.1.*的IP可以登录MySQL</p>
</li>
<li><p>在删除用户的时候，如果host不是%，需要明确指定’用户‘@’host值‘</p>
</li>
</ol>
</li>
</ul>
<h1 id="jdbc和连接池"><a href="#jdbc和连接池" class="headerlink" title="jdbc和连接池"></a>jdbc和连接池</h1><h2 id="jdbc概述"><a href="#jdbc概述" class="headerlink" title="jdbc概述"></a>jdbc概述</h2><p>jdbc是什么？</p>
<p>jdbc是一套为不同的数据库提供了统一访问的接口。相关类和接口在java.sql和javax.sql包里。</p>
<p>jdbc的基本原理图：</p>
<p>Java厂商提供一套jdbc接口规范，不同的数据库厂商根据接口，实现具体的类，具体类会被打包成jar包，该jar包就是我们所说的驱动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	不同的数据库厂商实现统一的接口规范，体现了一种多态的思想</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdbc</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//JdbcInterface jdbcInterface = new MysqlImpl();</span></span><br><span class="line">        JdbcInterface jdbcInterface = <span class="keyword">new</span> OracleImpl();</span><br><span class="line">        jdbcInterface.getConnection();</span><br><span class="line">        jdbcInterface.crud();</span><br><span class="line">        jdbcInterface.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一的接口规范</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JdbcInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crud</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlImpl</span> <span class="keyword">implements</span> <span class="title">JdbcInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql连接成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql进行crud操作！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql关闭资源连接！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleImpl</span> <span class="keyword">implements</span> <span class="title">JdbcInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle连接成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle进行crud操作！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle关闭资源连接！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdbc快速入门"><a href="#jdbc快速入门" class="headerlink" title="jdbc快速入门"></a>jdbc快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	第一个jdbc程序，完成简单的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testjdbc</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into actor(id,name,gender,borntime,phone) values(null,&quot;</span>海绵宝宝<span class="string">&quot;,&quot;</span>男<span class="string">&quot;,&quot;</span><span class="number">1991</span>-<span class="number">1</span>-<span class="number">1</span><span class="string">&quot;,&quot;</span><span class="number">1231232</span><span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="comment">//物理删</span></span><br><span class="line">        String sql2 = <span class="string">&quot;delete from actor where id = 2&quot;</span>;</span><br><span class="line">        <span class="comment">//改（逻辑删除）</span></span><br><span class="line">        String sql3 = <span class="string">&quot;update actor set name = &#x27;派大星&#x27; where id = 1&quot;</span>;</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql);<span class="comment">//影响的行数</span></span><br><span class="line">        System.out.println(row &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">       	<span class="comment">//关闭资源连接</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	五种加载驱动连接数据库的方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionWays</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionWay1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperties(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperties(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = driver.connect(url,properties);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭资源连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式2：加载驱动改为反射获得</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionWay2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Class&lt;?&gt; aclass = Class.forname(<span class="string">&quot;con.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver)aclass.newInstance();</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperties(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperties(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = driver.connect(url,properties);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭资源连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionWay3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Class&lt;?&gt; aclass = Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver)aclass.newInstance();</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">     	<span class="string">&quot;&quot;</span>   </span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line">        DriverManager.getConnection(url,user,password);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        <span class="comment">//关闭资源连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><h2 id="JDBC-Utils"><a href="#JDBC-Utils" class="headerlink" title="JDBC Utils"></a>JDBC Utils</h2><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><h3 id="Proxool"><a href="#Proxool" class="headerlink" title="Proxool"></a>Proxool</h3><h3 id="BoneCP"><a href="#BoneCP" class="headerlink" title="BoneCP"></a>BoneCP</h3><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><h2 id="Apache-DBUtils"><a href="#Apache-DBUtils" class="headerlink" title="Apache-DBUtils"></a>Apache-DBUtils</h2><h2 id="DAO的增删改查-BasicDAO"><a href="#DAO的增删改查-BasicDAO" class="headerlink" title="DAO的增删改查-BasicDAO"></a>DAO的增删改查-BasicDAO</h2><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>为什么要学习正则表达式？</p>
<ol>
<li>提取文章中的所有英文单词</li>
<li>提取文章中所有的数字</li>
<li>提取文章中所有的英文单词和数字</li>
<li>提起百度热榜标题</li>
</ol>
<p>结论：正则表达式是处理文本的利器</p>
<p>再提几个问题？</p>
<ol>
<li>给你一个字符串（或文章），找出所有四个数字连在一起的子串？</li>
<li>给你一个字符串（或文章），请找出所有四个数字连在一起的子串，并且这四个数字要满足：第一位与第四位相同，第二位与第三位相同，如1221，5775等</li>
<li>请验证输入的邮件是否符合电子邮件格式</li>
<li>请验证输入的手机号是否符合手机号格式</li>
</ol>
<ul>
<li>解决之道——正则表达式<ol>
<li>为了解决上述问题，Java提供了正则表达式技术，专门用于解决类似文本处理问题</li>
<li>简单的说：正则表达式是对字符串执行模式匹配的技术</li>
<li>正则表达式：regular expression =&gt; RegExp</li>
</ol>
</li>
</ul>
<h2 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h2><h3 id="正则表达式基本介绍"><a href="#正则表达式基本介绍" class="headerlink" title="正则表达式基本介绍"></a>正则表达式基本介绍</h3><ol>
<li>一个正则表达式，就是用某种模式去匹配字符串的一个公式，很多人因为他们看起来比较古怪而且复杂所以不敢去使用，不过，经过练习后，就觉得这些复杂的表达式写起来还是相当简单的，而且，一旦弄懂它们，就能把数小时辛苦而且易错的文本处理工作缩短在几分钟（甚至几秒钟）内完成</li>
<li>正则表达式不是只有Java才有，实际上很多编程语言（js、php、Java……）都支持正则表达式进行字符串操作</li>
</ol>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><ul>
<li><p>基本介绍</p>
<p>如果想要灵活运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大体分为：</p>
<ol>
<li>限定符</li>
<li>选择匹配符</li>
<li>分组组合和反向引用符</li>
<li>特殊字符</li>
<li>字符匹配符</li>
<li>定位符</li>
</ol>
</li>
<li><p>元字符（Metacharacter）——转义号\\ </p>
<p>\\ 符号说明：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转移符号，否则检索不到结果，甚至会报错的。</p>
<p>案例：用$去匹配”abc$（“会怎样？用（去匹配”abc$（“会怎样？</p>
<p>再次提示：*<em>在Java的正则表达式中，两个\\代表其他语言中的一个\*</em></p>
<p>需要用到转移符号的字符有以下：.*()$/?[]^{}</p>
</li>
<li><p>元字符——字符匹配符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[]</td>
<td align="center">可接收的字符列表</td>
<td align="center">[efgh]</td>
<td align="center">e、f、g、h中任意一个字符</td>
</tr>
<tr>
<td align="center">[^]</td>
<td align="center">不接受的字符列表</td>
<td align="center">[^abc]</td>
<td align="center">除a、b、c之外的任意一个字符，包括数字和特殊符号</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">连字符</td>
<td align="center">A-Z</td>
<td align="center">任意单个大写字母</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配除\n以外的任何字符</td>
<td align="center">a..b</td>
<td align="center">以a开头，b结尾，中间包括两个任意字符的长度为4的字符串</td>
</tr>
<tr>
<td align="center">\\d</td>
<td align="center">匹配单个数字字符，相当于[0-9]</td>
<td align="center">\\d{3}(\\d)?</td>
<td align="center">包含3个或4个数字的字符串</td>
</tr>
<tr>
<td align="center">\\D</td>
<td align="center">匹配单个非数字字符，相当于   [ ^0-9 ]</td>
<td align="center">\\D(\\d)*</td>
<td align="center">以单个非数字字符开头，后接任意个数字的字符串</td>
</tr>
<tr>
<td align="center">\\w</td>
<td align="center">匹配单个数字、大小写字母字符，相当于[0-9a-zA-Z]</td>
<td align="center">\\d{3}\\w{4}</td>
<td align="center">以3个数字字符开头的长度为7的数字字母字符串</td>
</tr>
<tr>
<td align="center">\\W</td>
<td align="center">匹配单个非数字、大小写字母字符，相当于[ ^0-9a-zA-Z ]</td>
<td align="center">\\W+\\d{2}</td>
<td align="center">以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td>
</tr>
</tbody></table>
</li>
</ul>
<p>应用实例：</p>
<ol>
<li>[a-z]说明：[a-z]表示可以匹配a-z中任意一个字符，比如[a-z]、[A-Z]去匹配a11c8会得到什么结果？</li>
<li>Java正则表达式默认是区分字母大小写的，如何实现不区分大小写<ul>
<li><p>(?i)abc表示abc都不区分大小写</p>
<ul>
<li>a(?i)bc表示bc不区分大小写</li>
</ul>
</li>
<li><p>a((?i)b)c表示只有b不区分大小写</p>
</li>
<li><pre><code class="Java">  Pattern compile = Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);
</code></pre>
</li>
</ul>
</li>
</ol>
<p>  [A-Z]表示可以匹配A-Z中任意一个字符</p>
<p>  [0-9]表示可以匹配0-9中任意一个字符</p>
<ol start="3">
<li><p>[^a-z]说明：</p>
<p>[^a-z]表示可以匹配不是a-z中的任意一个字符</p>
<p>[ ^A-Z]表示可以匹配不是A-Z中的任意一个字符</p>
<p>[ ^0-9]表示可以匹配不是0-9中的任意一个字符</p>
</li>
<li><p>[abcd]表示可以匹配abcd中的任意一个字符</p>
</li>
<li><p>[^abcd]表示可以匹配不是abcd中的任意一个字符</p>
</li>
<li><p>\\d表示可以匹配0-9的任意一个数字，相当于[0-9]</p>
</li>
<li><p>\\D表示可以匹配不是0-9中的任意一个字符，相当于[ ^0-9]</p>
</li>
<li><p>\\w匹配任意英文字符、数字和下划线，相当于[a-zA-Z0-9_]</p>
</li>
<li><p>\\W相当于[ ^a-zA-Z0-9_]和\\w刚好相反</p>
</li>
<li><p>\\s匹配任意空白字符（空格、制表符等）</p>
</li>
<li><p>\\S匹配任何非空白字符，和\\s刚好相反</p>
</li>
<li><p>.（小圆点）匹配除\n之外的所有字符，如果要匹配，本身则需要使用\\</p>
</li>
</ol>
<ul>
<li><p>元字符——选择匹配符</p>
<p>在匹配某个字符串的时候是选择性的，即：既可以匹配这个，也可以匹配那个，这时候你可以用到选择匹配符号|</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">解释</th>
<th align="center">示例</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|</td>
<td align="center">匹配“|”之前后之后的表达式</td>
<td align="center">ab|cd</td>
<td align="center">ab或cd</td>
</tr>
</tbody></table>
</li>
<li><p>元字符——限定符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="center">指定字符重复0次或n次（无要求）</td>
<td align="center">（abc)*</td>
<td align="center">仅包含任意个abc的字符串</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">指定字符重复1次或n次（至少一次）</td>
<td align="center">m+(abc)*</td>
<td align="center">以至少1个m开头，后接任意个abc的字符串</td>
</tr>
<tr>
<td align="center">？</td>
<td align="center">指定字符重复0次或1次（最多一次）</td>
<td align="center">m+abc?</td>
<td align="center">以至少1个m开头，后接ab或abc的字符串</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="center">只能输入n个字符</td>
<td align="center">[abcd]{3}</td>
<td align="center">由abcd中的字母组成的任意长度为3的字符串</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">指定至少n个匹配</td>
<td align="center">[abcd]{3,}</td>
<td align="center">由abcd中的字母组成的任意长度不小于3的字符串</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">指定至少n个但不多于m个匹配</td>
<td align="center">[abcd]{3,5}</td>
<td align="center">由abcd中的字母组成的任意不小于3，不大于5的字符串，如：abd、abcdc等</td>
</tr>
</tbody></table>
<p>Java默认贪婪匹配。优先匹配多的，如1{2,4}，优先匹配1111</p>
<p>?：当此字符紧随任何其他限定符（*、+、？、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪婪模式”，“非贪婪模式”匹配到的、尽可能短的字符串，例如，在字符串“oooo”中，“o+？”只匹配单个“o”，而“o+”匹配所有“o”</p>
</li>
<li><p>元字符——定位符</p>
<p>定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是结束的位置，这个也是相当有用的，必须掌握</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">指定起始字符</td>
<td align="center">^[0-9]+[a-z]*</td>
<td align="center">以至少1个数字开头，后接任意个小写字母的字符串</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">指定结束字符</td>
<td align="center">^[0-9]\\-[a-z]+$</td>
<td align="center">以1个数字开头，后接连字符“-”，并以至少1个小写字母结尾的字符串</td>
</tr>
<tr>
<td align="center">\\b</td>
<td align="center">匹配目标字符串的边界</td>
<td align="center">han\\b</td>
<td align="center">这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置，如sphan、nnhan</td>
</tr>
<tr>
<td align="center">\\B</td>
<td align="center">匹配目标字符串的非边界</td>
<td align="center">han\\B</td>
<td align="center">和\\b的含义刚刚相反，目标字符串的开始位置</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>分组</p>
<ul>
<li><p>常用分组</p>
<table>
<thead>
<tr>
<th align="center">常用分组构造形式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">（pattern）</td>
<td align="center">非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号</td>
</tr>
<tr>
<td align="center">（？<name> pattern）</td>
<td align="center">命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如（？‘name’）</td>
</tr>
</tbody></table>
</li>
<li><p>特别分组</p>
<table>
<thead>
<tr>
<th align="center">常见分组构造形式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">（？：pattern）</td>
<td align="center">匹配pattern但不捕获该匹配的子表达式，即他是一个非捕获匹配，不存储以后使用的匹配。这对于用“or”字符（|）组合模式部件的情况很有用。例如，industr（？：y|ies）是比industry|industries更经济的表达式</td>
</tr>
<tr>
<td align="center">（？=pattern）</td>
<td align="center">它是一个非捕获匹配。例如，“Windows（？=95|98|NT|2000）”匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。</td>
</tr>
<tr>
<td align="center">（？！pattern）</td>
<td align="center">该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，“Windows（？！95|98|NT|2000）”匹配“Windows 3.1”中的“Windows”，但不匹配“Windows 2000”中的“Windows”。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="三个常用类"><a href="#三个常用类" class="headerlink" title="三个常用类"></a>三个常用类</h3><ol>
<li>Pattern</li>
<li>Matcher</li>
<li>PatternSyntaxException</li>
</ol>
<h3 id="分组、捕获、反向引用"><a href="#分组、捕获、反向引用" class="headerlink" title="分组、捕获、反向引用"></a>分组、捕获、反向引用</h3><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h1 id="Java8和Java11新特性"><a href="#Java8和Java11新特性" class="headerlink" title="Java8和Java11新特性"></a>Java8和Java11新特性</h1><h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h3 id="接口静态方法"><a href="#接口静态方法" class="headerlink" title="接口静态方法"></a>接口静态方法</h3><h3 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h3><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><h3 id="stream-API"><a href="#stream-API" class="headerlink" title="stream API"></a>stream API</h3><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><h3 id="串行流"><a href="#串行流" class="headerlink" title="串行流"></a>串行流</h3><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><h3 id="新时间日期-API"><a href="#新时间日期-API" class="headerlink" title="新时间日期 API"></a>新时间日期 API</h3><h2 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h2><h3 id="代码层面新特性"><a href="#代码层面新特性" class="headerlink" title="代码层面新特性"></a>代码层面新特性</h3><ol>
<li>JShell</li>
<li>类型推断</li>
<li>集合增强API</li>
<li>Stream 加强</li>
<li>新增字符串处理方法</li>
<li>Optional加强</li>
<li>InputStream增强API</li>
<li>标准Java异步HTTP客户</li>
</ol>
<h3 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8?from=search&seid=3263764915424826952&spm_id_from=333.337.0.0">【零基础 快速学Java】韩顺平 零基础30天学会Java_哔哩哔哩_bilibili</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Liyou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hualala-2.github.io/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">http://hualala-2.github.io/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hualala-2.github.io" target="_blank">Liyou's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/J2SE/">J2SE</a></div><div class="post_share"><div class="social-share" data-image="/img/cover5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/lazyload1.gif" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/lazyload1.gif" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/02/html%E7%AC%94%E8%AE%B0%EF%BC%88%E7%8B%82%E7%A5%9E%EF%BC%89/"><img class="prev-cover" src= "/img/lazyload1.gif" data-lazy-src="/img/cover18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">html笔记（狂神）</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/29/Java%E5%8F%8D%E5%B0%84/"><img class="next-cover" src= "/img/lazyload1.gif" data-lazy-src="/img/cover20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java反射</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/29/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img class="cover" src= "/img/lazyload1.gif" data-lazy-src="/img/cover20.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-29</div><div class="title">Java反射</div></div></a></div><div><a href="/2021/08/28/Java%E6%B3%A8%E8%A7%A3/" title="Java注解"><img class="cover" src= "/img/lazyload1.gif" data-lazy-src="/img/cover13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">Java注解</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/lazyload1.gif" data-lazy-src="/img/tit.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Liyou</div><div class="author-info__description">做事做事！orz</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hualala-2"><i class="fab fa-github"></i><span>Follow Me For Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1458396499&amp;website=www.oicqzone.com" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1458396499@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">记录生活每一天(~^O^~)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.</span> <span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">Java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.</span> <span class="toc-text">如何快速学习新技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Java的应用领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">什么是程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%8E%86%E5%8F%B2"><span class="toc-number">2.4.</span> <span class="toc-text">Java历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.5.</span> <span class="toc-text">Java技术体系平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">Java重要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">2.7.</span> <span class="toc-text">Java的开发工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">Java运行机制及运行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJDK%EF%BC%8CJRE"><span class="toc-number">2.9.</span> <span class="toc-text">什么是JDK，JRE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%AE%89%E8%A3%85"><span class="toc-number">2.10.</span> <span class="toc-text">JDK安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.11.</span> <span class="toc-text">Java快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-number">2.12.</span> <span class="toc-text">Java开发注意事项和细节说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">2.13.</span> <span class="toc-text">Java转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%EF%BC%88comment%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">注释（comment）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">2.15.</span> <span class="toc-text">代码规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOS%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.16.</span> <span class="toc-text">DOS命令（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.17.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">变量介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">+号的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">运算符介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">关系运算符(比较运算符)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.6.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.7.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83"><span class="toc-number">4.8.</span> <span class="toc-text">标识符的命名规则和规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">4.9.</span> <span class="toc-text">进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.10.</span> <span class="toc-text">位运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%EF%BC%88if-else-switch%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">分支（if else switch）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%EF%BC%88for%EF%BC%8Cwhile%EF%BC%8Cdo-while%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">循环（for，while，do while）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-break"><span class="toc-number">5.4.</span> <span class="toc-text">跳转控制语句-break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-continue"><span class="toc-number">5.5.</span> <span class="toc-text">跳转控制语句-continue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-return"><span class="toc-number">5.6.</span> <span class="toc-text">跳转控制语句-return</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text">数组介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">数组的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%81%E5%8F%8D%E8%BD%AC%E3%80%81%E6%89%A9%E5%AE%B9%E3%80%81%E7%BC%A9%E5%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">数组的拷贝、反转、扩容、缩减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.4.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.1.</span> <span class="toc-text">类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">7.1.3.</span> <span class="toc-text">成员方法传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="toc-number">7.1.4.</span> <span class="toc-text">方法重载（Overload）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">7.1.5.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.1.6.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">7.1.7.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">7.1.8.</span> <span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7"><span class="toc-number">7.2.</span> <span class="toc-text">中级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IntelliJ-IDEA"><span class="toc-number">7.2.1.</span> <span class="toc-text">IntelliJ IDEA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">7.2.2.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.2.3.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">7.2.4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.5.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">7.2.6.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#override%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89"><span class="toc-number">7.2.7.</span> <span class="toc-text">override（覆盖）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">7.2.8.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.2.9.</span> <span class="toc-text">Object类详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88debug%EF%BC%89"><span class="toc-number">7.2.10.</span> <span class="toc-text">断点调试（debug）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7"><span class="toc-number">7.3.</span> <span class="toc-text">高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.1.</span> <span class="toc-text">类变量与类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-number">7.3.2.</span> <span class="toc-text">理解main方法语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">7.3.3.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.3.4.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">7.3.5.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.3.6.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.3.7.</span> <span class="toc-text">内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.1.</span> <span class="toc-text">自定义注解实现枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.2.</span> <span class="toc-text">enum关键字实现枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%86%85%E7%BD%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.</span> <span class="toc-text">JDK内置的基本注解类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%9A%E5%AF%B9%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.4.</span> <span class="toc-text">元注解：对注解进行注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">9.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">异常的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">9.2.</span> <span class="toc-text">异常体系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">9.3.</span> <span class="toc-text">常见的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">9.5.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">9.6.</span> <span class="toc-text">throw和throws的对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">10.2.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer"><span class="toc-number">10.3.</span> <span class="toc-text">StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder"><span class="toc-number">10.4.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">10.5.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date%E3%80%81Calendar%E3%80%81LocalDate%E2%80%A6"><span class="toc-number">10.6.</span> <span class="toc-text">Date、Calendar、LocalDate…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-number">10.7.</span> <span class="toc-text">System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays"><span class="toc-number">10.8.</span> <span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger-BigDecimal"><span class="toc-number">10.9.</span> <span class="toc-text">BigInteger BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">11.1.</span> <span class="toc-text">集合框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-number">11.2.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">11.2.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">11.2.2.</span> <span class="toc-text">Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">11.3.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-number">11.4.</span> <span class="toc-text">Collections</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">泛型语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.2.</span> <span class="toc-text">自定义泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">12.2.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.2.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.3.</span> <span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">12.3.</span> <span class="toc-text">泛型继承和通配符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.1.</span> <span class="toc-text">线程介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">线程使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread"><span class="toc-number">13.2.1.</span> <span class="toc-text">继承Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable"><span class="toc-number">13.2.2.</span> <span class="toc-text">实现Runnable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">线程方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">13.4.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized"><span class="toc-number">13.5.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">13.6.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">13.7.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO"><span class="toc-number">14.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">14.1.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">IO流原理及流的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">14.3.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">14.4.</span> <span class="toc-text">输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream"><span class="toc-number">14.4.1.</span> <span class="toc-text">InputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader"><span class="toc-number">14.4.2.</span> <span class="toc-text">Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStream"><span class="toc-number">14.4.3.</span> <span class="toc-text">OutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Writer"><span class="toc-number">14.4.4.</span> <span class="toc-text">Writer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties%E7%B1%BB"><span class="toc-number">14.5.</span> <span class="toc-text">Properties类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">15.1.</span> <span class="toc-text">网络基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress"><span class="toc-number">15.2.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-number">15.3.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">15.4.</span> <span class="toc-text">TCP编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">15.4.1.</span> <span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">15.4.2.</span> <span class="toc-text">字符流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E7%BC%96%E7%A8%8B"><span class="toc-number">15.5.</span> <span class="toc-text">UDP编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">16.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">16.1.</span> <span class="toc-text">反射机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">16.2.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">16.3.</span> <span class="toc-text">类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">16.4.</span> <span class="toc-text">反射获取类的结构信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80"><span class="toc-number">17.</span> <span class="toc-text">MySQL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">17.1.</span> <span class="toc-text">MySQL安装和配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">17.2.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">17.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">17.2.2.</span> <span class="toc-text">查看、删除数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">17.2.3.</span> <span class="toc-text">备份恢复数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8"><span class="toc-number">17.3.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="toc-number">17.3.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">17.3.2.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">17.3.3.</span> <span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.4.</span> <span class="toc-text">MySQL数据类型(列类型)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-create-R-read-U-update-D-delete"><span class="toc-number">17.5.</span> <span class="toc-text">C[create]R[read]U[update]D[delete]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert"><span class="toc-number">17.5.1.</span> <span class="toc-text">Insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update"><span class="toc-number">17.5.2.</span> <span class="toc-text">Update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delete"><span class="toc-number">17.5.3.</span> <span class="toc-text">Delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Select"><span class="toc-number">17.5.4.</span> <span class="toc-text">Select</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">17.6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0"><span class="toc-number">17.6.1.</span> <span class="toc-text">统计函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F"><span class="toc-number">17.6.2.</span> <span class="toc-text">时间日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">17.6.3.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">17.6.4.</span> <span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-number">17.6.5.</span> <span class="toc-text">加密和系统函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">17.6.6.</span> <span class="toc-text">流程控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">17.7.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">17.8.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">17.9.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#primary-key"><span class="toc-number">17.9.1.</span> <span class="toc-text">primary key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#not-null-amp-amp-unique"><span class="toc-number">17.9.2.</span> <span class="toc-text">not null &amp;&amp; unique</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreign-key"><span class="toc-number">17.9.3.</span> <span class="toc-text">foreign key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check"><span class="toc-number">17.9.4.</span> <span class="toc-text">check</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%95%BF"><span class="toc-number">17.9.5.</span> <span class="toc-text">自增长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">17.10.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">17.11.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">17.12.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%AE%A1%E7%90%86"><span class="toc-number">17.13.</span> <span class="toc-text">MySQL管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jdbc%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">18.</span> <span class="toc-text">jdbc和连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jdbc%E6%A6%82%E8%BF%B0"><span class="toc-number">18.1.</span> <span class="toc-text">jdbc概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdbc%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">18.2.</span> <span class="toc-text">jdbc快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC-API"><span class="toc-number">18.3.</span> <span class="toc-text">JDBC API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PreparedStatement"><span class="toc-number">18.3.1.</span> <span class="toc-text">PreparedStatement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DriverManager"><span class="toc-number">18.3.2.</span> <span class="toc-text">DriverManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Statement"><span class="toc-number">18.3.3.</span> <span class="toc-text">Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResultSet"><span class="toc-number">18.3.4.</span> <span class="toc-text">ResultSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC-Utils"><span class="toc-number">18.4.</span> <span class="toc-text">JDBC Utils</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="toc-number">18.5.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">18.6.</span> <span class="toc-text">批处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">18.7.</span> <span class="toc-text">连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataSource"><span class="toc-number">18.7.1.</span> <span class="toc-text">DataSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DBCP"><span class="toc-number">18.7.2.</span> <span class="toc-text">DBCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C3P0"><span class="toc-number">18.7.3.</span> <span class="toc-text">C3P0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxool"><span class="toc-number">18.7.4.</span> <span class="toc-text">Proxool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BoneCP"><span class="toc-number">18.7.5.</span> <span class="toc-text">BoneCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Druid"><span class="toc-number">18.7.6.</span> <span class="toc-text">Druid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Apache-DBUtils"><span class="toc-number">18.8.</span> <span class="toc-text">Apache-DBUtils</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAO%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-BasicDAO"><span class="toc-number">18.9.</span> <span class="toc-text">DAO的增删改查-BasicDAO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">19.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">19.2.</span> <span class="toc-text">正则表达式基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.2.1.</span> <span class="toc-text">正则表达式基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">19.2.2.</span> <span class="toc-text">正则表达式语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">19.2.3.</span> <span class="toc-text">三个常用类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E3%80%81%E6%8D%95%E8%8E%B7%E3%80%81%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">19.2.4.</span> <span class="toc-text">分组、捕获、反向引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">19.2.5.</span> <span class="toc-text">应用实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8%E5%92%8CJava11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.</span> <span class="toc-text">Java8和Java11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.1.</span> <span class="toc-text">Java8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda"><span class="toc-number">20.1.1.</span> <span class="toc-text">Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.1.2.</span> <span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">20.1.3.</span> <span class="toc-text">接口静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">20.1.4.</span> <span class="toc-text">接口默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">20.1.5.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">20.1.6.</span> <span class="toc-text">构造器引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream-API"><span class="toc-number">20.1.7.</span> <span class="toc-text">stream API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-number">20.1.8.</span> <span class="toc-text">并行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%B5%81"><span class="toc-number">20.1.9.</span> <span class="toc-text">串行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional"><span class="toc-number">20.1.10.</span> <span class="toc-text">Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F-API"><span class="toc-number">20.1.11.</span> <span class="toc-text">新时间日期 API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.2.</span> <span class="toc-text">Java11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.2.1.</span> <span class="toc-text">代码层面新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.2.2.</span> <span class="toc-text">其他新特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">21.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/Linux/" title="Linux"><img src= "/img/lazyload1.gif" data-lazy-src="/img/cover23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2022/11/21/Linux/" title="Linux">Linux</a><time datetime="2022-11-21T11:29:13.000Z" title="发表于 2022-11-21 19:29:13">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/%E9%A1%B9%E7%9B%AE/" title="项目"><img src= "/img/lazyload1.gif" data-lazy-src="/img/cover35.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目"/></a><div class="content"><a class="title" href="/2022/03/13/%E9%A1%B9%E7%9B%AE/" title="项目">项目</a><time datetime="2022-03-13T08:24:59.000Z" title="发表于 2022-03-13 16:24:59">2022-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/" title="大数据技术"><img src= "/img/lazyload1.gif" data-lazy-src="/img/cover26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据技术"/></a><div class="content"><a class="title" href="/2022/03/13/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/" title="大数据技术">大数据技术</a><time datetime="2022-03-13T08:21:19.000Z" title="发表于 2022-03-13 16:21:19">2022-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/DevOps-%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E4%B8%80%E4%BD%93%E5%8C%96/" title="DevOps(开发运维一体化)"><img src= "/img/lazyload1.gif" data-lazy-src="/img/cover37.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DevOps(开发运维一体化)"/></a><div class="content"><a class="title" href="/2022/03/13/DevOps-%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E4%B8%80%E4%BD%93%E5%8C%96/" title="DevOps(开发运维一体化)">DevOps(开发运维一体化)</a><time datetime="2022-03-13T08:14:47.000Z" title="发表于 2022-03-13 16:14:47">2022-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%9E%B6%E6%9E%84/" title="分布式微服务并行架构"><img src= "/img/lazyload1.gif" data-lazy-src="/img/cover27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式微服务并行架构"/></a><div class="content"><a class="title" href="/2022/03/13/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%9E%B6%E6%9E%84/" title="分布式微服务并行架构">分布式微服务并行架构</a><time datetime="2022-03-13T07:49:43.000Z" title="发表于 2022-03-13 15:49:43">2022-03-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Liyou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'iG9VNGVHnEWTnf7C4WHD2JCp-gzGzoHsz',
      appKey: 'OtN1LyiQ4Fv4JhG8dnJLWGnB',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>