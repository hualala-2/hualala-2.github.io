<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目</title>
      <link href="/2022/03/13/%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/03/13/%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h1><h1 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h1><h1 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h1><h1 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h1><h1 id="CRM、ERP"><a href="#CRM、ERP" class="headerlink" title="CRM、ERP"></a>CRM、ERP</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据技术</title>
      <link href="/2022/03/13/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/03/13/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h1 id="Impals"><a href="#Impals" class="headerlink" title="Impals"></a>Impals</h1><h1 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h1><h1 id="flink"><a href="#flink" class="headerlink" title="flink"></a>flink</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps(开发运维一体化)</title>
      <link href="/2022/03/13/DevOps-%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E4%B8%80%E4%BD%93%E5%8C%96/"/>
      <url>/2022/03/13/DevOps-%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E4%B8%80%E4%BD%93%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s（让部署容器化的应用简单高效）"><a href="#k8s（让部署容器化的应用简单高效）" class="headerlink" title="k8s（让部署容器化的应用简单高效）"></a>k8s（让部署容器化的应用简单高效）</h1><h1 id="普罗米修斯（prometheus）【系统监控和报警】"><a href="#普罗米修斯（prometheus）【系统监控和报警】" class="headerlink" title="普罗米修斯（prometheus）【系统监控和报警】"></a>普罗米修斯（prometheus）【系统监控和报警】</h1><h1 id="Jenkins（监控持续的工作【部署、集成、交付】）"><a href="#Jenkins（监控持续的工作【部署、集成、交付】）" class="headerlink" title="Jenkins（监控持续的工作【部署、集成、交付】）"></a>Jenkins（监控持续的工作【部署、集成、交付】）</h1><h1 id="Harbor（容器的镜像仓库）"><a href="#Harbor（容器的镜像仓库）" class="headerlink" title="Harbor（容器的镜像仓库）"></a>Harbor（容器的镜像仓库）</h1><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><h1 id="项目工程代码质量检测（Sonarqube）"><a href="#项目工程代码质量检测（Sonarqube）" class="headerlink" title="项目工程代码质量检测（Sonarqube）"></a>项目工程代码质量检测（Sonarqube）</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式微服务并行架构</title>
      <link href="/2022/03/13/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/03/13/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h1 id="Dubbo（RPC框架）"><a href="#Dubbo（RPC框架）" class="headerlink" title="Dubbo（RPC框架）"></a>Dubbo（RPC框架）</h1><h1 id="FastDFS（分布式的文件系统）"><a href="#FastDFS（分布式的文件系统）" class="headerlink" title="FastDFS（分布式的文件系统）"></a>FastDFS（分布式的文件系统）</h1><h1 id="Docker（应用容器引擎）"><a href="#Docker（应用容器引擎）" class="headerlink" title="Docker（应用容器引擎）"></a>Docker（应用容器引擎）</h1><h1 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h1><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="SpringCloud（组件很多）"><a href="#SpringCloud（组件很多）" class="headerlink" title="SpringCloud（组件很多）"></a>SpringCloud（组件很多）</h2><h3 id="Nacos（阿里巴巴，服务发现，配置，管理）"><a href="#Nacos（阿里巴巴，服务发现，配置，管理）" class="headerlink" title="Nacos（阿里巴巴，服务发现，配置，管理）"></a>Nacos（阿里巴巴，服务发现，配置，管理）</h3><h3 id="Seata（阿里巴巴，分布式事务的中间件）"><a href="#Seata（阿里巴巴，分布式事务的中间件）" class="headerlink" title="Seata（阿里巴巴，分布式事务的中间件）"></a>Seata（阿里巴巴，分布式事务的中间件）</h3><h3 id="Sentinel（阿里巴巴，流量控制，熔断，系统负载保护）"><a href="#Sentinel（阿里巴巴，流量控制，熔断，系统负载保护）" class="headerlink" title="Sentinel（阿里巴巴，流量控制，熔断，系统负载保护）"></a>Sentinel（阿里巴巴，流量控制，熔断，系统负载保护）</h3><h3 id="GateWay（网关，限流，日志，监控，鉴权）"><a href="#GateWay（网关，限流，日志，监控，鉴权）" class="headerlink" title="GateWay（网关，限流，日志，监控，鉴权）"></a>GateWay（网关，限流，日志，监控，鉴权）</h3><h3 id="OpenFeign（服务间调用）"><a href="#OpenFeign（服务间调用）" class="headerlink" title="OpenFeign（服务间调用）"></a>OpenFeign（服务间调用）</h3><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="MyCat（数据库中间件，分库分表）"><a href="#MyCat（数据库中间件，分库分表）" class="headerlink" title="MyCat（数据库中间件，分库分表）"></a>MyCat（数据库中间件，分库分表）</h2><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h1 id="日志分析与监控（ELK）"><a href="#日志分析与监控（ELK）" class="headerlink" title="日志分析与监控（ELK）"></a>日志分析与监控（ELK）</h1><h2 id="ElasticSearch（搜集，存储数据）"><a href="#ElasticSearch（搜集，存储数据）" class="headerlink" title="ElasticSearch（搜集，存储数据）"></a>ElasticSearch（搜集，存储数据）</h2><h2 id="LogStash（分析日志）"><a href="#LogStash（分析日志）" class="headerlink" title="LogStash（分析日志）"></a>LogStash（分析日志）</h2><h2 id="Kibana（可视化）"><a href="#Kibana（可视化）" class="headerlink" title="Kibana（可视化）"></a>Kibana（可视化）</h2><h2 id="Zookeeper（一致性服务：比如配置维护，域名维护，分布式同步）"><a href="#Zookeeper（一致性服务：比如配置维护，域名维护，分布式同步）" class="headerlink" title="Zookeeper（一致性服务：比如配置维护，域名维护，分布式同步）"></a>Zookeeper（一致性服务：比如配置维护，域名维护，分布式同步）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主流的框架和项目管理</title>
      <link href="/2022/03/13/%E4%B8%BB%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2022/03/13/%E4%B8%BB%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux（操作系统，必学）"><a href="#Linux（操作系统，必学）" class="headerlink" title="Linux（操作系统，必学）"></a>Linux（操作系统，必学）</h1><h1 id="Nginx（做反向代理的WEB服务器）"><a href="#Nginx（做反向代理的WEB服务器）" class="headerlink" title="Nginx（做反向代理的WEB服务器）"></a>Nginx（做反向代理的WEB服务器）</h1><h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="Spring（轻量级的容器框架）"><a href="#Spring（轻量级的容器框架）" class="headerlink" title="Spring（轻量级的容器框架）"></a>Spring（轻量级的容器框架）</h2><h2 id="SpringMVC（分层的web开发框架）"><a href="#SpringMVC（分层的web开发框架）" class="headerlink" title="SpringMVC（分层的web开发框架）"></a>SpringMVC（分层的web开发框架）</h2><h2 id="MyBatis（持久化框架）"><a href="#MyBatis（持久化框架）" class="headerlink" title="MyBatis（持久化框架）"></a>MyBatis（持久化框架）</h2><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h2 id="Git-amp-Github"><a href="#Git-amp-Github" class="headerlink" title="Git&amp;Github"></a>Git&amp;Github</h2><h2 id="SVN（用的少）"><a href="#SVN（用的少）" class="headerlink" title="SVN（用的少）"></a>SVN（用的少）</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h1 id="其他框架"><a href="#其他框架" class="headerlink" title="其他框架"></a>其他框架</h1><h2 id="WebService【即SOA】"><a href="#WebService【即SOA】" class="headerlink" title="WebService【即SOA】"></a>WebService【即SOA】</h2><h2 id="Activity（工作流框架-引擎）"><a href="#Activity（工作流框架-引擎）" class="headerlink" title="Activity（工作流框架/引擎）"></a>Activity（工作流框架/引擎）</h2><h2 id="Shiro（安全框架）"><a href="#Shiro（安全框架）" class="headerlink" title="Shiro（安全框架）"></a>Shiro（安全框架）</h2><h2 id="Spring-Security（安全框架）"><a href="#Spring-Security（安全框架）" class="headerlink" title="Spring Security（安全框架）"></a>Spring Security（安全框架）</h2><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><h2 id="SpringData（持久层的通用解决方案）"><a href="#SpringData（持久层的通用解决方案）" class="headerlink" title="SpringData（持久层的通用解决方案）"></a>SpringData（持久层的通用解决方案）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2022/03/13/JavaWeb/"/>
      <url>/2022/03/13/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><h1 id="前端框架（可以弱化）"><a href="#前端框架（可以弱化）" class="headerlink" title="前端框架（可以弱化）"></a>前端框架（可以弱化）</h1><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h1 id="Java-web后端"><a href="#Java-web后端" class="headerlink" title="Java web后端"></a>Java web后端</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java高级</title>
      <link href="/2022/03/13/Java%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/03/13/Java%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程-高并发"><a href="#Java多线程-高并发" class="headerlink" title="Java多线程/高并发"></a>Java多线程/高并发</h1><h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h3><h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><h3 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h3><h3 id="atomic（原子类）"><a href="#atomic（原子类）" class="headerlink" title="atomic（原子类）"></a>atomic（原子类）</h3><h3 id="tools（CountDownLatch，Exchanger、ThreadLocal、CyclicBarrier）"><a href="#tools（CountDownLatch，Exchanger、ThreadLocal、CyclicBarrier）" class="headerlink" title="tools（CountDownLatch，Exchanger、ThreadLocal、CyclicBarrier）"></a>tools（CountDownLatch，Exchanger、ThreadLocal、CyclicBarrier）</h3><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组（稀疏数组）"><a href="#数组（稀疏数组）" class="headerlink" title="数组（稀疏数组）"></a>数组（稀疏数组）</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><h3 id="动态规划（背包问题）"><a href="#动态规划（背包问题）" class="headerlink" title="动态规划（背包问题）"></a>动态规划（背包问题）</h3><h3 id="回溯（骑士周游问题）"><a href="#回溯（骑士周游问题）" class="headerlink" title="回溯（骑士周游问题）"></a>回溯（骑士周游问题）</h3><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><h3 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h3><h3 id="floyd（最短路径）"><a href="#floyd（最短路径）" class="headerlink" title="floyd（最短路径）"></a>floyd（最短路径）</h3><h3 id="迪杰斯特拉（最短路径）"><a href="#迪杰斯特拉（最短路径）" class="headerlink" title="迪杰斯特拉（最短路径）"></a>迪杰斯特拉（最短路径）</h3><h1 id="设计模式（23种）"><a href="#设计模式（23种）" class="headerlink" title="设计模式（23种）"></a>设计模式（23种）</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM体系"><a href="#JVM体系" class="headerlink" title="JVM体系"></a>JVM体系</h2><h2 id="类加载过程-机制"><a href="#类加载过程-机制" class="headerlink" title="类加载过程/机制"></a>类加载过程/机制</h2><h2 id="双亲委派机制-沙箱安全机制"><a href="#双亲委派机制-沙箱安全机制" class="headerlink" title="双亲委派机制/沙箱安全机制"></a>双亲委派机制/沙箱安全机制</h2><h2 id="JMM（Java内存模式）"><a href="#JMM（Java内存模式）" class="headerlink" title="JMM（Java内存模式）"></a>JMM（Java内存模式）</h2><h2 id="字节码执行的过程-机制"><a href="#字节码执行的过程-机制" class="headerlink" title="字节码执行的过程/机制"></a>字节码执行的过程/机制</h2><h2 id="GC（垃圾回收算法）"><a href="#GC（垃圾回收算法）" class="headerlink" title="GC（垃圾回收算法）"></a>GC（垃圾回收算法）</h2><h2 id="JVM性能监控和故障定位"><a href="#JVM性能监控和故障定位" class="headerlink" title="JVM性能监控和故障定位"></a>JVM性能监控和故障定位</h2><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot入门</title>
      <link href="/2021/11/10/Spring-Boot%E5%85%A5%E9%97%A8/"/>
      <url>/2021/11/10/Spring-Boot%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>狂神原件：</p><p><a href="https://www.cnblogs.com/zhuchengbo/p/12688161.html#2">狂神说SpringBoot - 月佩半琪 - 博客园 (cnblogs.com)</a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Spring：2003年兴起的一款为简化企业级开发的、轻量级的开发框架，作者：Rod Johnson </p><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</p><p>程序 = 数据结构 + 算法（集合框架）</p><ul><li><p>什么是微服务架构？</p><p>微服务架构是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合；可以通过http、rpc等方式进行互通。要说微服务架构，先得说说过去我们的单体应用架构。</p></li><li><p>单体微服务架构</p><p>所谓的单体应用架构（all in one）是指，我们将一个应用中的所用应用服务都封装在一个应用中。</p><p>无论是ERP、CRM或是其他什么系统，都是把数据库访问、web访问等各个功能放在一个war包内。</p><p>这样做的好处是，易于开发和测试；也十分方便部署，当需要扩展时，只需要将war包复制多份，然后放到多个服务器上，再做个负载均衡就可以了。</p><p>单体应用架构的缺点是，哪怕只要修改一个非常小的地方，我们都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用中。如何维护和分工合作都是问题。</p></li><li><p>微服务架构    </p><p>all in one的架构方式，我们把所有的功能单元放在一个应用里面，然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后再负载均衡。</p><p>所谓的微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素动态组合，需要的功能元素才拿来组合。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。</p><p>这样做的好处：</p><p>1、节省了调用资源</p><p>2、每个功能元素的服务都是一个可替换的、可独立升级的软件代码。</p><p>MVC三层架构    MVVM    微服务架构</p><p>业务：service：userService：===&gt;模块！</p><p>Spring MVC，controller ===&gt; 提供接口</p><p>用户下单：调用controller！</p><p>需要做的事情（消息队列）：仓库冻结；资金冻结；验证；购买成功；仓库数量减少；仓库解冻；资金解冻</p><p>高内聚低耦合便于升级</p></li><li><p>如何构建微服务</p><p>一个大型系统的微服务架构，就像一个复杂交织的神经网络，每一个神经元就是一个功能元素，他们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务，都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改了其中一个功能，只需要更新升级其中一个功能服务单元即可。</p><p>但是这种庞大的系统构架给部署和运维带来很大的难度。于是，Spring为我们带来了构建大型分布式微服务的全套、全程产品：</p><ul><li>构建一个个功能独立的微服务应用模块，可以使用Spring Boot</li><li>大型分布式网络服务的调用，这部分由Spring Cloud来完成，实现分布式；</li><li>在分布式中间，进行流式数据计算、批处理，我们有Spring Cloud Data Flow。</li></ul><p>Spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。</p><ul><li><p>原理初探</p><p>pom.xml</p><ul><li>spring-boot-dependencies：核心依赖在父工程中</li><li>我们在引入一些Spring Boot依赖时，不需要指定版本号，就是因为在父工程中有这些版本仓库</li></ul><p>启动器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动器：说白了就是Spring Boot的启动场景</li><li>比如spring-boot-starter-starter-web，他就会帮我们自动导入web环境所有的依赖！</li><li>Spring Boot会将所有的功能场景都变成一个个启动器</li><li>我们要使用什么功能，就只需要找到对应的启动器就可以了<code>starter</code></li></ul><p>主程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注这是一个Spring Boot应用：启动类下的所有资源被导入</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloworldApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(HelloworldApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span>:Spring Boot的配置</span><br><span class="line">    <span class="meta">@Configuration</span>：Spring配置类</span><br><span class="line">    <span class="meta">@Component</span>：说明这也是一个Spring的组件</span><br><span class="line">   </span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>：自动配置</span><br><span class="line">    <span class="meta">@AutoConfigurationPackage</span>：自动配置包</span><br><span class="line">    <span class="meta">@Import(AutoConfigurationPackages.Register.class)</span>：自动配置`包注册`</span><br><span class="line">    <span class="meta">@Import(AutoConfigurationImportSelector.class)</span>：自动配置导入选择</span><br><span class="line">   </span><br><span class="line"><span class="comment">//获取所有的配置</span></span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取候选的配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兜兜转转最终指向了@EnableAutoConfiguration</p><p>巴拉巴拉 ………………………….</p><hr><p>结论：Spring Boot所有自动配置都是在启动的时候扫描并加载：spring.factories所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的starter，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功！</p><ol><li>Spring Boot在启动的时候在类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值；</li><li>将这些值作为自动装配类导入容器，自动装配类就生效，帮我们进行配置工作；</li><li>以前我们需要自己配置的东西，自动装配类都帮我们解决了；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>他将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中；</li><li>它会给容器中导入非常多的自动装配类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</li><li>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。</li></ol></li></ul></li></ul></li></ul><blockquote><p>Run</p></blockquote><p>我最初以为就是运行一个main方法，没想到却开启了一个服务；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloworldApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该方法返回以ConfigurableApplicationContext对象</span></span><br><span class="line">        <span class="comment">//参数一：应用入口的类参数二：命令行参数</span></span><br><span class="line">SpringApplication.run(HelloworldApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplication.run分析</p><p>分析主要分为两部分，一部分是SpringApplication的实例化，而是run方法的执行；</p><blockquote><p>SpringApplication</p></blockquote><p>这个类主要做了以下四件事情：</p><ol><li>推断应用的类型是普通的项目还是Web项目</li><li>查找并加载所有可用初始化器，设置到initializers属性中</li><li>找到所有的应用程序监听器，设置到listeners属性中</li><li>推断并设置main方法的定义类，找到运行的主类</li></ol><blockquote><p>run</p></blockquote><img src="..\Spring-Boot入门\run方法.PNG"/><p>关于Spring Boot，谈谈你的理解：</p><ol><li>自动装配</li><li>run()</li></ol><p>全面接管SpringMVC的配置</p><h2 id="配合如何编写-yaml"><a href="#配合如何编写-yaml" class="headerlink" title="配合如何编写 yaml"></a>配合如何编写 yaml</h2><blockquote><p>配置文件</p></blockquote><p>Spring Boot使用一个全局的配置文件，配置文件名称是固定的</p><ul><li><p>application.properties</p><ul><li>语法结构：key=value</li></ul></li><li><p>application.yaml</p><ul><li>语法结构：key：空格 value</li></ul></li></ul><p>配置文件的作用：修改Spring Boot自动配置的默认值，因为Spring Boot在底层都给我们自动配置好了</p><p>松散绑定：这个什么意思呢？比如我的yml中写的last-name，这个和lastName是一样的，后面跟的字母默认大写的，这就是松散绑定</p><p>JSR303数据校验，这个就是我们可以在字段增加一层过滤验证，可以保证数据的合法性</p><p><a href="https://www.jianshu.com/p/d2ddd856cce2">JSR303数据校验 - 简书 (jianshu.com)</a></p><p>结论：</p><ul><li>配置yml和配置properties都可以获取到值，强烈推荐yml</li><li>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用以下@value</li><li>如果说，我们专门编写了一个JavaBean来和配置文件进行映射，就直接使用@ConfigurationProperties，不要犹豫！</li></ul><h2 id="自动装配原理：重要谈资"><a href="#自动装配原理：重要谈资" class="headerlink" title="自动装配原理：重要谈资"></a>自动装配原理：重要谈资</h2><h2 id="集成Web开发：业务的核心"><a href="#集成Web开发：业务的核心" class="headerlink" title="集成Web开发：业务的核心"></a>集成Web开发：业务的核心</h2><p><strong>静态资源：</strong></p><ul><li><p>在Spring Boot中，我们可以使用以下方式处理静态资源</p><ul><li>webjars    <code>localhost:8080/webjars/</code></li><li>resources,static,public,/**      <code>localhost:8080/</code></li></ul></li><li><p>文件夹的优先级：resources&gt;static(默认)&gt;public</p></li></ul><p><strong>首页如何定制：</strong></p><p>index.html</p><p><strong>模板引擎thymeleaf：</strong></p><p>结论：只要需要使用thymeleaf，只需要导入对应的依赖就可以了！我们将html放在我们的templates目录下</p><p>所有的html元素都可以被thymeleaf替换接管，th：元素名</p><p><strong>装配扩展Spring MVC</strong></p><p>自研starter：configuration+properties两个类打到jar包里，放到autoconfigure里</p><p>在Spring Boot中，有非常多的xxxxConfiguration帮助我们进行扩展配置，只要看到了这个东西，我们就要注意了！</p><p><strong>增删改查</strong></p><p><strong>拦截器</strong></p><p><strong>国际化</strong></p><h2 id="集成数据库：Druid"><a href="#集成数据库：Druid" class="headerlink" title="集成数据库：Druid"></a>集成数据库：Druid</h2><h2 id="分布式开发：Dobbo-zookeeper"><a href="#分布式开发：Dobbo-zookeeper" class="headerlink" title="分布式开发：Dobbo+zookeeper"></a>分布式开发：Dobbo+zookeeper</h2><h2 id="swagger：接口文档"><a href="#swagger：接口文档" class="headerlink" title="swagger：接口文档"></a>swagger：接口文档</h2><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h2 id="SpringSecurity：Shiro"><a href="#SpringSecurity：Shiro" class="headerlink" title="SpringSecurity：Shiro"></a>SpringSecurity：Shiro</h2><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h2 id="Spring-Cloud入门"><a href="#Spring-Cloud入门" class="headerlink" title="Spring Cloud入门"></a>Spring Cloud入门</h2><h2 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h2><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h2 id="Ribborn"><a href="#Ribborn" class="headerlink" title="Ribborn"></a>Ribborn</h2><h2 id="Fegin"><a href="#Fegin" class="headerlink" title="Fegin"></a>Fegin</h2><h2 id="HyStrix"><a href="#HyStrix" class="headerlink" title="HyStrix"></a>HyStrix</h2><h2 id="Zuul路由网关"><a href="#Zuul路由网关" class="headerlink" title="Zuul路由网关"></a>Zuul路由网关</h2><h2 id="Spring-Cloud-config：Git"><a href="#Spring-Cloud-config：Git" class="headerlink" title="Spring Cloud config：Git"></a>Spring Cloud config：Git</h2><h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h1><ol><li>自动导包、自动删包：勾选巴拉巴拉</li><li>alt+鼠标下托：多行选中</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/zhuchengbo/p/12688161.html#2">狂神说SpringBoot - 月佩半琪 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV1PE411i7CV?p=12&spm_id_from=pageDriver">【狂神说Java】SpringBoot最新教程IDEA版通俗易懂_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2^32=4GB?</title>
      <link href="/2021/11/08/2-32-4GB/"/>
      <url>/2021/11/08/2-32-4GB/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么32位操作系统最大支持4G内存？"><a href="#为什么32位操作系统最大支持4G内存？" class="headerlink" title="为什么32位操作系统最大支持4G内存？"></a>为什么32位操作系统最大支持4G内存？</h1><h2 id="内存的最基础单位"><a href="#内存的最基础单位" class="headerlink" title="内存的最基础单位"></a>内存的最基础单位</h2><p>1个Byte（字节）可以看成是由8个<strong>物理上连续</strong>的bit（位）组成的。</p><h2 id="内存是计算机的主存储器"><a href="#内存是计算机的主存储器" class="headerlink" title="内存是计算机的主存储器"></a>内存是计算机的主存储器</h2><p><strong>内存作为1个存储数据的存在， 有1个很重要的特性， 就是内存里的数据能被cpu直接访问。</strong>cpu能不能直接访问硬盘的数据呢， 不能。 只能通过把硬盘的数据先放到内存里， 然后再从内存里访问硬盘的数据。我们平时玩游戏碰上读图loading 进度条的这个过程， 就是把数据从硬盘读到内存的过程啊。 读完条后地图的数据就在内存中了。</p><p>所以内存才是计算机系统的主存储器， 而硬盘是被分到跟光盘、u盘一类都是外部存储器。</p><h2 id="内存的基本结构"><a href="#内存的基本结构" class="headerlink" title="内存的基本结构"></a>内存的基本结构</h2><p>内存里存放的数据是什么呢？ 其实也是只是存放0或者1这两个二进制数字啊， 所以内存里实际上有海量的小格子，每1个格子是1个 <strong>bit</strong>，就只能存放1个数字（0或者1）， 那么数值255需要几个格子来放呢？ 就是8个格子啊， 1个字节 <strong>byte</strong>啊。</p><p>但是问题来了， 我刚说了内存里的格子数量非常巨大， 如果cpu要读出某个指定的数据， 怎么去找呢？</p><p>1个1个格子去遍历吗， 其实稍微接触过数据结构的都知道， 遍历虽然实现简单， 但是在海量数据面前简直是自杀行为。</p><p>所以实际上内存是把8个8个bit排成1组， 每1组成为1个单位， 大小是1 <strong>byte</strong>(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit)。<strong>1个byte字节就是内存的最小的IO单位</strong>。</p><p>大部分数据都会作为各种数据类型存放在内存内， 而各种数据类型所占的字节大小也是不同的。</p><h2 id="引入内存地址的概念"><a href="#引入内存地址的概念" class="headerlink" title="引入内存地址的概念"></a>引入内存地址的概念</h2><p> 即使我们把内存分成了以字节为单位的结构， 但是实际上内存里还是有非常多的字节的，例如64MB内存就有 64 × 1024 × 1024 个字节啊！</p><p>如果cpu要查找1个变量， 还是要1个个字节去找到话，显然是浪费时间的行为，所以为了避免去遍历内存，计算机系统就引入了内存地址这个概念。</p><p>举个例子, 内存就是一栋大楼， 而内存里每1个字节就是大楼的每个房间， 而内存地址就是房间的门牌号码了。如果没有门牌号码,我们去访问某个住在大楼的人是十分苦难的， 只能从1楼开始每个房间去敲门， 如果那个人住在顶楼你就悲剧了。而如果你知道那个人的门牌号码， 就可以直接上去敲他的门查他水表了，实在是方便很多啊。</p><p>内存也一样, <strong>计算机操作系统</strong>会给内存每1个字节分配1个内存地址, cpu只需要知道某个数据类型的地址, 就可以 <strong>直接</strong>去对应的内存位置去提取数据了。</p><h2 id="直接寻址技术"><a href="#直接寻址技术" class="headerlink" title="直接寻址技术"></a>直接寻址技术</h2><p>当代计算机还实现了1个逆天的技术,就是直接寻址了。</p><p>什么意思呢, 还是用上面的例子说明,  假如你知道你要找的人住在那栋大楼的17楼 1702, 但是你还是需要从1楼走到17楼去找他, 这个过程还是需要时间成本的。</p><p>但是如果你具有了直接寻址技术, 就能直接跳到17楼 1702门前, 如果你找的下1个人在2楼, 又能从17楼直接跳到2楼, 逆天啊！！！</p><p>而直接寻址技术已经成为当代计算机软硬件的标准技术之一了, 也就是说只要CPU知道要访问数据的内存地址, 就能直接到内存的对应位置去访问数据！</p><h2 id="内存地址的表示方式"><a href="#内存地址的表示方式" class="headerlink" title="内存地址的表示方式"></a>内存地址的表示方式</h2><p> 跟门牌号一样, 其实内存地址也是由一个二进制数字来表示的。   每1个地址对应内存里的1个byte字节, 如果地址的值加1, 那么这个地址就对应下1个字节了。 </p><p>那么内存地址的长度是多少呢? 这个就是这篇文章标题所涉及的。在32位操作系统中, <strong>内存的地址就是32位的二进制数</strong>, 那么假如32位系统的某个内存地址是:0000 1111 1111 0000 1111 0000 1111 0000<br>那么它可以用十六进制表示成： 0   F   F   0   F    0   F   0 </p><p>也就是 <strong>Ox</strong>0ff0f0f0 前面Ox代表十六进制, 所以你见到这种字母数字混合一次的地址方式,就是这样得来的了, 它实际上是1个二进制的数字啊. 不过计算机里面所有的东西都是二进制了。</p><h2 id="内存地址的数量决定CPU能访问的内存大小"><a href="#内存地址的数量决定CPU能访问的内存大小" class="headerlink" title="内存地址的数量决定CPU能访问的内存大小"></a>内存地址的数量决定CPU能访问的内存大小</h2><p>上面说了, 既然32位系统里内存地址长度是32位的. 所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111 1111 1111 1111 1111 1111 啦（Ox00000000 ~ OxFFFFFFFF)， 这里有几个地址呢？ 明显是有 2^32 个啦。</p><p>那么2^32到底是多少个？ 2^32 = 4 * 1024(G) * 1024(M) * 1024(K) = 4294967296 , 就是<strong>4G</strong> 啊, 而每1个地址对应1个1个字节， 容量就是1byte， 所以2^32个地址就总共能对应应<strong>4G*<em>B*</em></strong> 的内存容量啊， 这里的B指的是byte 字节啊。</p><p>假如你给32位的系统配上了8GB的内存， 操作系统最多也只能给其中4GB 分配地址， 其余 4GB 是没有地址， 因为地址不够用啊， 所以32位系统最多支持4GB内存就是这样来的。</p><p>​      那么64位系统呢， 对应地， 64位系统的内存地址是64位的二进制数啊， 0000 …64个0 ~ 1111 …64个1, 用十六进表示就是从Ox0000000000000000 ~ OxFFFFFFFFFFFFFFFF , 每个地址的长度比32位的长度多1倍！  而64位系统总共有多少个地址？</p><p>​      2^64 = 2^34 *  2^10(G) * 2^10(M) * 2^10(K)   也就是 17179869184 G（4G × 4G）个地址， 我艹这是神码概念， 也就是说64位系统配上64位cpu理论上支持17多亿GB的内存， 当然这个只是理论了， 实际上现在的普通主版能上个16GB都不错了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/weixin_30325971/article/details/95698467?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">详解为什么32位系统只能用4G内存._weixin_30325971的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计组计网操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组计网操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制工具Git</title>
      <link href="/2021/10/24/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7Git/"/>
      <url>/2021/10/24/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7Git/</url>
      
        <content type="html"><![CDATA[<h1 id="狂神聊Git-笔记"><a href="#狂神聊Git-笔记" class="headerlink" title="狂神聊Git(笔记)"></a>狂神聊Git(笔记)</h1><p>Git：分布式版本控制系统，管理多人协同开发的技术，仓库的所有版本信息全部同步到本地的每个用户。不会因为服务器或者网络问题，造成不能工作的情况！</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul><li><p>Git与SVN最主要区别（图像记忆）</p><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而在工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需要把各自的修改送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><p><strong>Git是目前世界上最先进的分布式版本控制系统</strong></p></li></ul><h2 id="聊聊Git历史"><a href="#聊聊Git历史" class="headerlink" title="聊聊Git历史"></a>聊聊Git历史</h2><p>Linux与Git之父：Linus</p><h2 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h2><p>安装完之后，有三个可以打开的应用。</p><p>Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多，<strong>使用Ctrl+滚轮</strong></p><p>Git CMD：Windows风格的命令行</p><p>Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><ul><li><p>显示当前Git的配置（l：list）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure></li><li><p>显示系统为Git提供的配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure></li><li><p>全局配置，该配置说明你是谁</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></li></ul><p>Git的相关配置文件：</p><ol><li>Git\etc\gitconfig：Git安装目录下的gitconfig      –system系统级</li><li>C:\Users\Administrator（个性化配置的当前用户）\ .gitconfig        只适用于当前登录用户的配置        –global全局</li></ol><ul><li><p>设置用户名与邮箱（<strong>用户标识，必要</strong>）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;hualala-2&quot;#名称</span><br><span class="line">git config --global user.email &quot;hualala_2@aliyun.com&quot;#邮箱</span><br></pre></td></tr></table></figure></li></ul><h2 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h2><p><strong>核心，所有实践都源于这个理论</strong></p><ul><li><p>工作区域</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A[Remote Directory]--git pull--&gt;B[History];</span><br><span class="line">B--git push--&gt;A;</span><br><span class="line">B--git reset--&gt;C;</span><br><span class="line">C[Stage_index]--git commit--&gt;B;</span><br><span class="line">C--git checkout--&gt;D[Working Directory];</span><br><span class="line">D--git add--&gt;C;</span><br></pre></td></tr></table></figure></li><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index/Stage：暂存区，用于临时存放你的变动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据，其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台用于远程交换数据的电脑</p></li></ul><img src="..\版本控制工具Git\Git工作区域.PNG"/><p>Git的工作流程一般是这样的：</p><ol><li>在工作目录中添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；</li><li>将暂存区域的文件提交到Git仓库。</li></ol><p>因此，Git管理的文件有三种状态：已修改（modified）、已暂存（staged），已提交（committed）</p><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><blockquote><p>创建工作目录与常用命令</p></blockquote><p>工作目录（Workspace）一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图的6个命令：</p><img src="..\版本控制工具Git\常用命令.PNG"/><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><ol><li><p>创建全新的仓库，需要用Git管理的项目的根目录执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录下新建一个Git代码库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等所有信息都在这个目录里面。</p></li></ol><blockquote><p>克隆远程仓库</p></blockquote><ol><li><p>另一种方式是克隆远程目录，即将远程服务器上的仓库完全镜像一份至本地。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史（版本信息）</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure></li><li><p>去gitee或者github上克隆一个测试！</p></li></ol><h2 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h2><ul><li><p>查看文件状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将所有文件添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 查看文件状态，确认文件是否被添加到暂存区</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 将文件添加到本地库</span></span><br><span class="line">git commit -m <span class="string">&quot;new file hello.txt&quot;</span></span><br><span class="line"><span class="comment"># 查看文件状态，确认文件添加到本地库</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>忽略文件</p><p>有时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立“.gitignore”文件，此文件有如下规则：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.txt <span class="comment"># 忽略所有.txt结尾的文件，这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt <span class="comment"># 但lib.txt除外</span></span><br><span class="line">/temp <span class="comment"># 仅忽略项目根目录下的TODO文件，不包括其他目录temp</span></span><br><span class="line">build/ <span class="comment"># 忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt <span class="comment"># 会忽略doc/notes.txt，但不包括doc/server/arch.txt</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>Github是有墙的，比较慢，在国内的话，我们一般使用gitee，公司中有时候会搭建自己的gitlab服务器。</p><ol><li><p>注册登录码云，完善个人信息</p></li><li><p>设置本机绑定SSH公钥，实现免密登录！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 C:\Users\Administrator\.ssh目录</span></span><br><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></li><li><p>将公匙信息public key添加到码云账户中即可！</p></li><li><p>使用码云创建一个自己的仓库！</p></li></ol><h2 id="IDEA中集成Git"><a href="#IDEA中集成Git" class="headerlink" title="IDEA中集成Git"></a>IDEA中集成Git</h2><ol><li>新建项目，绑定Git。<ul><li>将我们远程的Git文件目录拷贝到项目中即可！</li></ul></li><li>修改文件，使用IDEA操作Git。（也可直接在Terminal操作）<ul><li>添加到暂存区</li><li>commit提交</li><li>push到远程仓库</li></ul></li><li>提交测试。</li></ol><h2 id="说明：Git分支"><a href="#说明：Git分支" class="headerlink" title="说明：Git分支"></a>说明：Git分支</h2><p>分支在Git中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><ul><li><p>Git分支中常用指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure></li></ul><p>多个分支如果并行执行，就会导致我们代码不冲突，也就是同时存在多个版本！</p><p>如果同一个文件在合并分支时都被修改了，则会造成冲突：<strong>解决的办法是我们可以修改冲突文件后重新提交！（两人经过商量后，决定保留谁的代码）</strong></p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后，可以合并到主分支master上来。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.bilibili.com/video/BV1FE411P7B3?p=4&spm_id_from=pageDriver">【狂神说Java】Git最新教程通俗易懂_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记知识</title>
      <link href="/2021/10/16/%E6%9D%82%E8%AE%B0%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/10/16/%E6%9D%82%E8%AE%B0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>#ping通多台pc（虚拟机模拟）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ping通另一台电脑</span></span><br><span class="line">ping 192.168.1.100 </span><br><span class="line"><span class="meta">#</span><span class="bash">查看本机IP</span></span><br><span class="line">ifconfig（Linux）</span><br><span class="line">ipconfig（Win）</span><br><span class="line"><span class="meta">#</span><span class="bash">分配一个可用的ip地址</span></span><br><span class="line">dhclient</span><br><span class="line"><span class="meta">#</span><span class="bash">进入配置网卡的文件</span></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置网卡，固定网址</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static（dhcp）（改动处1）</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=b069944f-2f31-4b78-b283-7d1ef493f86a</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes（no）（改动处2）</span><br><span class="line">IPADDR=192.168.1.104（新增）（改动处3）#ip地址</span><br><span class="line">NETMASK=255.255.255.0（新增）#子网掩码</span><br><span class="line">GATEWAY=192.168.1.1（新增）#网关</span><br><span class="line">DNS1=119.29.29.29（新增）##公网DNS</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启网卡</span></span><br><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><ul><li><p>tips:</p><p>宿主机可以ping通虚拟机，但虚拟机ping不同宿主机，该咋办？</p><p>关闭宿主机防火墙。</p></li></ul><h1 id="包管理工具scoop"><a href="#包管理工具scoop" class="headerlink" title="包管理工具scoop"></a>包管理工具scoop</h1><ul><li><p><strong>在powershell下安装包管理工具scoop</strong></p><p>情景：你试图执行的操作需要提升权限，那么你可以使用“RunasAdministrator”选项启动Powershell，并更改执行策略，成功后，你就可以执行你的操作了<br>执行：get-ExecutionPolicy，显示Restricted，表示状态是禁止的，如果是RemoteSigned，那么就不用往下执行了<br>以管理员启动：Start-Process powershell -Verb runAs<br>执行：set-ExecutionPolicy RemoteSigned<br>这时再执行get-ExecutionPolicy，就显示RemoteSigned</p><p>​        Restricted——默认的设置， 不允许任何script运行<br>​        AllSigned——只能运行经过数字证书签名的script<br>　　RemoteSigned——运行本地的script不需要数字签名，但是运行从网络上下载的script就必须要有数字签名<br>　　Unrestricted——允许所有的script运行</p></li><li><p><strong>安装完成后，还需要添加软件源，不然会有好些软件能search到但是不能install</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add versions</span><br></pre></td></tr></table></figure></li><li><p><strong>输入如下命令即可安装需要的软件</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop install &lt;软件名&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果是安装到global目录，命令如下</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop install -g &lt;软件名&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>软件搜索</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop search &lt;软件名&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>软件安装</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装aria2以加快scoop下载速度</span></span><br><span class="line">scoop install aria2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>（网络不好搞得头大:sheep::sheep::sheep:）</p><ul><li><strong>参考文献</strong></li></ul><p><a href="https://blog.csdn.net/weixin_37891983/article/details/105231263">Scoop安装详解_boyinthesun的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/luoyooi/article/details/102990113">Windows下Scoop安装、配置与使用_luoyooi的博客-CSDN博客_scoop</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机入门（计组/计网/操作系统）</title>
      <link href="/2021/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8%EF%BC%88%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%BD%91-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
      <url>/2021/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8%EF%BC%88%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%BD%91-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="概述篇"><a href="#概述篇" class="headerlink" title="概述篇"></a>概述篇</h2><h3 id="计算机的发展简史"><a href="#计算机的发展简史" class="headerlink" title="计算机的发展简史"></a>计算机的发展简史</h3><h4 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h4><ul><li><p>1946-1957：电子管计算机</p><p>埃尼阿克（ENIAC）</p></li><li><p>1957-1964：晶体管计算机</p><p>PDP-1</p></li><li><p>1964-1980：集成电路计算机</p></li><li><p>1980-现在：超大规模集成电路计算机</p></li><li><p>畅想：第五阶段，未来的计算机</p><p>1、生物计算机        2、量子计算机</p></li></ul><h4 id="微型计算机的发展历史"><a href="#微型计算机的发展历史" class="headerlink" title="微型计算机的发展历史"></a>微型计算机的发展历史</h4><ul><li><p>单核CPU：</p><p>摩尔定律：当价格不变时，集成电路的性能，每18-24个月就会提升一倍（21世纪已失效）</p></li><li><p>多核CPU（单核CPU达到瓶颈）</p></li></ul><h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3><ul><li><p>超级计算机</p><p>标记他们运算速度的单位：TFlop/s（每秒一万亿次浮点计算）</p><p>Summit、神威太湖之光、Sierra、天河二号、天河一号</p></li><li><p>大型计算机</p><p>去“IOE”行动</p></li><li><p>迷你计算机（服务器）</p><p>联想、华为等</p><p>普通服务器以及代替了传统的大型机，成为大规模企业计算的中枢（阿里云、腾讯云）</p></li><li><p>工作站</p><p>高端的通用微型计算机</p></li><li><p>微型计算机（个人计算机）</p><p>台式机、笔记本电脑、一体机</p></li><li><p>微型计算机</p></li></ul><h3 id="计算机的体系结构"><a href="#计算机的体系结构" class="headerlink" title="计算机的体系结构"></a>计算机的体系结构</h3><h4 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h4><p>将程序指令与数据一起存储的计算机设计概念结构</p><p>现代计算机都是冯诺依曼机</p><p>冯诺依曼结构如图所示：</p><img src="..\计算机入门（计组-计网-操作系统）\冯诺伊曼.PNG"/><p>由于CPU与存储器分开，会导致一个问题，即冯诺依曼瓶颈。</p><p>冯诺依曼瓶颈：CPU（central processing unit）和存储器速率之间的问题无法调和。CPU处理速度快，而CPU与存储器之间的传输速度慢，这就导致了CPU经常空转等待数据传输。</p><h4 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h4><p>现代计算机结构如图所示：</p><img src="..\计算机入门（计组-计网-操作系统）\现代计算机的结构.PNG"/><p>现代计算机结构解决了什么问题？</p><p>现代计算机的存储器指的是围绕CPU的更高速的设备即内存、CPU的寄存器，</p><p>现代计算机的结构可以理解为以存储器为核心的结构。</p><h3 id="计算机的层次与编程语言"><a href="#计算机的层次与编程语言" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h3><h4 id="程序翻译与程序解释"><a href="#程序翻译与程序解释" class="headerlink" title="程序翻译与程序解释"></a>程序翻译与程序解释</h4><p>程序翻译如图所示：</p> <img src="..\计算机入门（计组-计网-操作系统）\程序翻译.PNG"/><p>程序解释如图所示：</p><img src="..\计算机入门（计组-计网-操作系统）\程序解释.PNG"/><p>翻译型语言：C/C++、Object-C、Golang</p><p>解释型语言：Python、Php、Javascript</p><p>翻译型+解释型：Java、C#</p><p>Java文件经过类加载器得到class文件（字节码文件），字节码文件经过JVM得到机器码，扔给底层执行。</p><h4 id="计算机的层次与编程语言-1"><a href="#计算机的层次与编程语言-1" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h4><img src="..\计算机入门（计组-计网-操作系统）\计算机的层次.PNG"/><h3 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h3><h4 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h4><ol><li><p>在物理层面，高低电平记录信息</p></li><li><p>理论上只认识0/1两种状态</p></li><li><p>0/1能够表示的内容太少了，需要更大的容量表示方法</p><p>0/1称为bit（比特位）</p></li></ol><p>容量单位（千兆G太派艾）：</p><table><thead><tr><th align="center"></th><th align="center">bit</th><th align="center">Byte</th><th align="center">KB</th><th align="center">MB</th><th align="center">GB</th><th align="center">TB</th><th align="center">PB</th><th align="center">EB</th></tr></thead><tbody><tr><td align="center">名称</td><td align="center">比特位</td><td align="center">字节</td><td align="center">千字节</td><td align="center">兆字节</td><td align="center">G字节</td><td align="center">太字节</td><td align="center">派字节</td><td align="center">艾字节</td></tr><tr><td align="center">比例</td><td align="center">-</td><td align="center">8bits</td><td align="center">1024B</td><td align="center">1024KB</td><td align="center">1024MB</td><td align="center">1024GB</td><td align="center">1024TB</td><td align="center">1024PB</td></tr><tr><td align="center">常见设备</td><td align="center">门电路</td><td align="center">-</td><td align="center">寄存器</td><td align="center">高速缓存</td><td align="center">内存/硬盘</td><td align="center">硬盘</td><td align="center">云硬盘</td><td align="center">数据仓库</td></tr></tbody></table><ul><li><p>为什么网上买的移动硬盘500G，格式化之后只剩465G了？</p><p>硬盘厂商一般用10进制标记容量</p><p>500*（1000^3)/(1024^3)即465</p></li></ul><h4 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h4><ul><li><p>100M宽带中的100M指的是什么呢？</p><p>100M/s</p></li><li><p>为什么电信拉的100M光纤，测试峰值只有12M每秒？</p><p>网络常用单位为Mbps</p><p>100M/s = 100Mbps = 100 Mbit/s</p><p>100Mbit/s = (100/8)MB/s = 12.5MB/s</p></li><li><p>CPU的速度</p><p>CPU的速度一般体现为CPU的时钟频率</p><p>CPU的时钟频率的单位一般是赫兹（Hz）</p><p>主流CPU的时钟频率都在2GHz以上</p><p>Hz其实就是秒分之一，并不是描述计算机领域所专有的单位</p><p>它是每秒中的周期性变动重复次数的计量</p></li></ul><img src="..\计算机入门（计组-计网-操作系统）\CPU速度.PNG"/><h3 id="计算机的字符与编码集"><a href="#计算机的字符与编码集" class="headerlink" title="计算机的字符与编码集"></a>计算机的字符与编码集</h3><h4 id="字符编码集的历史"><a href="#字符编码集的历史" class="headerlink" title="字符编码集的历史"></a>字符编码集的历史</h4><ol><li><p>ASCII码</p><ul><li><p>使用7个bits就可以完全表示ASCII码</p></li><li><p>包含95个可打印字符</p></li><li><p>33个不可打印字符（包含控制字符）</p></li><li><p>33+95 = 128 = 2^7</p><img src="..\计算机入门（计组-计网-操作系统）\ASCII码.PNG"/></li></ul></li><li><p>Extended ASCII码</p><ul><li><p>很多应用或者国家中的符号都无法表示</p></li><li><p>第一次对ASCII码进行扩充，由7bits到8bits</p><img src="..\计算机入门（计组-计网-操作系统）\ExtendedASCII码.PNG"/></li></ul></li><li><p>字符编码集的国际化</p><ul><li>欧洲、中亚、东亚、拉丁美洲国家的语言多样性</li><li>语言体系不一样，不以有限字符组合的语言</li><li>中国、韩国、日本等的语言最为复杂</li></ul></li></ol><h4 id="中文编码集"><a href="#中文编码集" class="headerlink" title="中文编码集"></a>中文编码集</h4><ol><li><p>GB2312（不符合国际的标准）</p><ul><li>《信息交换用汉字编码集——基本集》</li><li>一共收录了7445个字符</li><li>包括6763个汉字和682个其他字符</li></ul></li><li><p>GBK（本地化的编码，外国友人需要下载才能使用）</p><ul><li>《汉字内码扩展规范》</li><li>向下兼容GB2312，向上支持国际ISO标准</li><li>收录了21003个汉字，支持全部中日韩汉字</li></ul></li><li><p>兼容全球的字符编码集：Unicode</p><ul><li>Unicode：统一码、万国码、单一码</li><li>Unicode定义了世界通用的符号集，UTF-*实现了编码</li><li>UTF-8以字节为单位对Unicode进行编码</li><li>Windows系统默认使用GBK编码，编程推荐使用UTF-8编码</li></ul></li></ol><h2 id="组成篇"><a href="#组成篇" class="headerlink" title="组成篇"></a>组成篇</h2><h3 id="章节导学"><a href="#章节导学" class="headerlink" title="章节导学"></a>章节导学</h3><img src="..\计算机入门（计组-计网-操作系统）\计组导学.PNG"/><h3 id="计算机的总线与IO设备"><a href="#计算机的总线与IO设备" class="headerlink" title="计算机的总线与IO设备"></a>计算机的总线与IO设备</h3><h4 id="计算机的总线"><a href="#计算机的总线" class="headerlink" title="计算机的总线"></a>计算机的总线</h4><ol><li><p>总线的概述</p><p>1.1总线是什么？</p><ul><li><p>USB</p><p>Universal Serial Bus 通用串行总线</p><p>提供了对外的接口</p><p>不同设备可以通过USB设备进行连接</p><p>连接的标准，促使外围接口的统一</p></li><li><p>SATA总线（固态硬盘总线、不超过600MB/s）、PCIE总线（固态硬盘总线，1000MB/s）、ISA总线、Thunderbolt总线…….</p></li></ul><p><em><strong>总线是为了解决不同设备之间的通信问题而存在的</strong></em></p><p>1.2总线的分类</p></li></ol><ul><li><p>片内总线</p><ul><li>芯片内部的总线</li><li>寄存器与寄存器之间</li><li>寄存器与控制器、运算器之间</li></ul><p>高集成度芯片内部的信息传输线</p></li><li><p>系统总线</p><ul><li><p>数据总线</p><ul><li>双向传输各个部件的数据信息</li><li>数据总线的位数（总线宽度）是数据总线的重要参数</li><li>一般与CPU位数相同（32位、64位）</li></ul></li><li><p>地址总线  </p><ul><li>指定源数据或目的数据在内存中的地址</li><li>地址总线的位数与存储单元有关</li><li>地址总线位数=n，寻址范围：0~2^n</li></ul></li><li><p>控制总线</p><ul><li>控制总线是用来发出各种控制信号的传输线</li><li>控制信号经由控制总线从一个组件发给另一个组件</li><li>控制总线可以监视不同组件之间的状态（就绪/未就绪）</li></ul><p><em><strong>CPU、主存储、IO设备、各组件之间的信息传输线</strong></em></p></li></ul></li></ul><ol start="2"><li>总线的仲裁</li></ol><ul><li><p>为什么需要总线仲裁</p><p>假设主存需要和硬盘、IO设备交换数据，此时硬盘与IO设备都已就绪，那么主存该给谁使用呢？</p><p>答：第三方的仲裁器来解决设备使用的冲突问题。</p></li><li><p>总线仲裁的方法</p><ul><li><p>链式查询</p><img src="..\计算机入门（计组-计网-操作系统）\链式查询.PNG"/><ul><li>好处：电路复杂度低，仲裁方式简单</li><li>坏处：优先级低的设备难以获得总线使用权</li><li>坏处：对电路故障敏感</li></ul></li><li><p>计时器定时查询</p><ul><li>仲裁控制器对设备编号并使用计数器累计计数</li><li>接收到仲裁信号，往所有设备发出计数值（1、2、3依次累计）</li><li>计数值与设备编号一致，则获得总线使用权</li></ul></li><li><p>独立请求</p><ul><li>每个设备均有总线，独立连接仲裁器</li><li>设备可单独向仲裁器发送请求和接收请求</li><li>当同时受到多个请求信号，仲裁器有权按优先级分配使用权</li><li>好处：响应速度快，优先顺序可动态变化</li><li>设备连线多，总线控制复杂</li></ul></li></ul><p><em><strong>为了解决总线使用权的冲突问题</strong></em></p></li></ul><h4 id="计算机的输入-输出设备"><a href="#计算机的输入-输出设备" class="headerlink" title="计算机的输入/输出设备"></a>计算机的输入/输出设备</h4><ol><li><p>常见的输入输出设备</p><ul><li><p>字符输入设备</p><p>键盘：薄膜键盘、机械键盘（黑轴、红轴、青轴、茶轴）、电容键盘</p></li><li><p>图像输入设备</p><p>鼠标、数位板、扫描仪</p><p>数位板：输入板和压感笔，常用于绘图设计创作</p><p>扫描仪：将图形信息转换为数字信号</p></li><li><p>图像输出设备</p><p>显示器、打印机、投影仪</p></li></ul></li><li><p>输入输出接口的通用设计</p><p>输入输出接口应该完成哪些工作呢？</p><p>读取数据、允许我们向设备发送数据、通过接口判断设备有没有被占用、通过接口判断设备是否已连接、设备是否已经启动等</p><p>面对这样的需求，我们该怎样设计输入输出接口呢？</p><ul><li>数据线<ul><li>是I/O设备与主机之间进行数据交换的传送线</li><li>单向传输数据线</li><li>双向传输数据线</li></ul></li><li>状态线<ul><li>IO设备状态向主机报告的信号线</li><li>查询设备是否已经正常连接并就绪</li><li>查询设备是否被占用</li></ul></li><li>命令线<ul><li>CPU向设备发送命令的信号线</li><li>发送读写信号</li><li>发送启动停止信号</li></ul></li><li>设备选择线<ul><li>主机选择IO设备进行操作的信号线</li><li>对连在总线上的设备进行选择</li></ul></li></ul></li><li><p>CPU与IO设备的通信</p><p><em><strong>CPU速度与IO设备速度不一致</strong></em></p><ul><li><p>程序中断</p><ul><li>当外围IO设备就绪时，向CPU发出中断信号</li><li>CPU有专门的电路响应中断信号</li><li><em><strong>提供低速设备通知CPU的一种异步方式，CPU可以高速运转同时兼顾低速设备的响应</strong></em></li></ul></li><li><p>DMA（Directed Memory Access直接存储器访问）</p><img src="..\计算机入门（计组-计网-操作系统）\DMA.PNG"/><ul><li>DMA直接连接主存与IO设备</li><li>DMA工作时不需要CPU的参与</li><li>硬盘和外置显卡都有DMA设备</li></ul></li></ul></li></ol><p>两者的比较：程序中断由程序控制，CPU有一个程序的切换与保存的过程，但DMA直接硬件控制，CPU只需要做些预处理和后处理的工作即可；程序中断应用于低速外设，而DMA用于高速外设。</p><h3 id="计算机的存储器"><a href="#计算机的存储器" class="headerlink" title="计算机的存储器"></a>计算机的存储器</h3><h4 id="计算机的存储器概览"><a href="#计算机的存储器概览" class="headerlink" title="计算机的存储器概览"></a>计算机的存储器概览</h4><ol><li><p>存储器的分类</p><ul><li>存储介质分类<ul><li>半导体存储器：内存、U盘、固态硬盘</li><li>磁存储器：磁带、磁盘</li></ul></li><li>光存储器：光盘</li><li>存取方式分类<ul><li><p>随机存储器（RAM）：随机读取、与位置无关</p></li><li><p>串行存储器：与位置有关、按顺序查找</p></li><li><p>只读存储器（ROM）：只读不写</p><img src="..\计算机入门（计组-计网-操作系统）\半导体存储器.PNG"/></li></ul></li></ul></li><li><p>存储器的层次结构</p><p>选购存储器时考虑哪些因素？</p><p>读写速度（5400转、7200转）、存储容量（2T、128G）、价格</p><p>容量+价格——&gt;位价：每比特位价格</p><p>存储器的层次结构：</p><img src="..\计算机入门（计组-计网-操作系统）\存储器的层次结构.PNG"/><img src="..\计算机入门（计组-计网-操作系统）\存储器的层次结构2.PNG"/><img src="..\计算机入门（计组-计网-操作系统）\存储器的层次结构3.PNG"/><p><strong>在主存与辅存层次的不断发展当中，也逐渐形成了虚拟存储系统，程序员编程的地址与虚存的地址是相对应的，所以我们编程时所用的空间要远远大于主存空间。</strong></p><ul><li><p>缓存-主存层次</p><p>原理：局部性原理</p><ul><li>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。（程序经常访问的一段内存会被置换到缓存，CPU在需要这段内容时直接访问缓存即可）</li></ul><p>实现：在CPU与主存之间增加一层速度快（容量小）的cache</p><p>目的：解决主存速度不足的问题，解决CPU与主存的速度不匹配问题</p></li><li><p>主存-辅存层次</p><p>原理：局部性原理</p><p>实现：主存之外增加辅助存储器（磁盘、SD卡、U盘等）</p><p>目的：解决主存容量不足的问题（大型游戏）</p></li></ul></li></ol><h4 id="计算机的主存储器与辅助存储器"><a href="#计算机的主存储器与辅助存储器" class="headerlink" title="计算机的主存储器与辅助存储器"></a>计算机的主存储器与辅助存储器</h4><p>引入：为什么计算机断电时，内存数据丢失，而磁盘数据不会丢失呢？</p><ul><li><p>主存储器——内存</p><ul><li><p>RAM（Random Access Memory）</p></li><li><p>RAM通过电容存储数据，必须隔一段时间刷新一次</p></li><li><p>如果掉电，那么一段时间后将丢失所有数据</p></li><li><p>CPU与内存交互如图所示：</p><img src="..\计算机入门（计组-计网-操作系统）\CPU内存交互.PNG"/></li><li><p>32位系统（地址总线32位）2^32^=4*2^30^=4G,32位系统可以表示4G个不同的地址，每个地址表示1Byte的位置。</p></li><li><p>64位系统（地址总线64位）2^64^=2^34^*2^30^=2^34^G</p></li></ul></li><li><p>辅助存储器——磁盘</p><ul><li><p>表面是可磁化的硬磁特性材料</p></li><li><p>移动磁头径向运动读取磁道信息</p></li><li><p>磁盘调度算法</p><p>如图所示：磁头位于第4个磁道</p><img src="..\计算机入门（计组-计网-操作系统）\磁盘.png"/><ul><li><p>先来先服务算法</p><p>按顺序进行读取：1-&gt;4-&gt;2-&gt;3-&gt;1-&gt;5</p></li><li><p>最短寻道时间优先算法</p><ul><li>与磁头当前位置有关</li><li>优先访问离磁头最近的磁道</li></ul><p>读取顺序：4-&gt;5-&gt;3-&gt;2-&gt;1-&gt;1</p></li><li><p>扫描算法（电梯算法）</p><ul><li>每次只往一个方向移动</li><li>到达一个方向需要服务的尽头再反方向移动</li></ul><p>读取顺序：4-&gt;3-&gt;2-&gt;1-&gt;1-&gt;5</p></li><li><p>循环扫描算法</p><ul><li>只往一个方向读取，由内往外读取或由外往内读取</li></ul><p>读取顺序：4-&gt;5-&gt;1-&gt;1-&gt;2-&gt;3</p></li></ul></li></ul></li></ul><h4 id="计算机的高速存储器"><a href="#计算机的高速存储器" class="headerlink" title="计算机的高速存储器"></a>计算机的高速存储器</h4><ul><li><p>高速缓存的工作原理</p><p><strong>字</strong>：指存放在一个存储单元中的二进制代码组合</p><p><strong>字块</strong>：指存储在连续的存储单元中而被看作是一个单元的一组字</p><img src="..\计算机入门（计组-计网-操作系统）\字与字块.png"/><p>字的地址包含两个部分，前<strong>m</strong>位指定字块的地址，后<strong>b</strong>位指定字在字块中的地址</p><p>一个字有32位，一个字块共有<strong>B</strong>个字，主存共<strong>M</strong>个字块</p><p>则有<strong>2^m=M, 2^b=B</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例子：假设主存用户空间容量位4G，字块大小为4M，字长为32位，则对于字地址中的块地址m和块内地址b的位数，至少应该是多少？</span></span><br><span class="line"><span class="comment">答：先确认有多少个字块，每个字块里面有多少个字</span></span><br><span class="line"><span class="comment">字块数：4GB=2^32B, 4MB=2^22B, 则有2^10个字块，m=10,则m&gt;=10</span></span><br><span class="line"><span class="comment">每个字块内的字数：4M=2^22B= 2^25bits， 32位=2^5bits，b=20,则b&gt;=20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>缓存与主存的存储的逻辑结构类似</li><li>缓存的容量较小</li><li>缓存的速度更快</li></ul><p>那么缓存是如何工作的呢？如何评价缓存工作的状况呢？</p><p>当CPU需要的数据在缓存那里时，直接从缓存拿即可，当需要的数据不在缓存时，CPU需要到主存里面去拿。对于缓存而言，这就产生了一个<strong>命中率h</strong>的概念。</p><ul><li>命中率是衡量缓存的重要性能指标</li><li>理论上CPU每次都能从高速缓存存取数据时，命中率为1</li><li>假设访问主存次数：N<del>m</del> ，访问Cache次数：N<del>c</del> ,则命中率h=N<del>c</del> /(N<del>c</del> +N<del>m</del>)。</li><li>对于缓存而言，由命中率的概念进一步得到了一个<strong>访问效率e</strong>的概念。</li><li>访问主存时间：t<del>m</del> ，访问缓存时间：t<del>c</del> ，访问Cache-主存系统平均时间：t<del>a</del> = ht<del>c</del> + (1-h)t<del>m</del> ；</li><li>访问效率e = t<del>c</del>/t<del>a</del> = t<del>c</del>/[ht<del>c</del>+(1-h)t<del>m</del>] </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">例子：假设CPU在执行某段程序时，共访问Cache2000次，访问主存50次，已知已知Cache的存取时间为50ns，主存的存取时间为200ns，求Cache主存系统的命中率、访问效率和平均访问时间。</span></span><br><span class="line"><span class="comment">命中率h=命中次数/（命中次数hc+没有命中次数hm）=2000/(2000+50)约等于0.976</span></span><br><span class="line"><span class="comment">平均访问时间ta=h*tc+(1-h)tm=0.976*50ns+0.024*200ns=53.6ns</span></span><br><span class="line"><span class="comment">访问效率e=访问Cache时间/平均访问时间ta=50/53.6=93.28%</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如何有效地提高Cache的命中率和访问效率呢？这就需要性能良好的缓存替换策略了。</p></li><li><p>高速缓存的替换策略</p><p>高速缓存的替换发生在什么样的场景下呢？</p><p>当CPU未能在高速缓存中找到数据，此时就需要从主存中载入所需的数据了，此时便是高速缓存的替换时机。</p><ul><li><p>随机算法</p><p>每次需要替换时，随机选取高速缓存里的位置，把需要的数据替换到该位置。</p></li><li><p>先进先出算法（FIFO）</p><ul><li>把高速缓存看做是一个先进先出的队列</li><li>优先替换最先进入队列的字块</li></ul></li><li><p>最不经常使用算法（LFU）</p><ul><li><p>优先淘汰最不经常使用的字块</p></li><li><p>需要额外的空间记录字块的使用频率</p></li><li><p>LFU图解：</p><img src="..\计算机入门（计组-计网-操作系统）\LFU图解.png"/></li></ul></li><li><p>最近最少使用算法（LRU）</p><ul><li><p>优先淘汰一段时间内没有使用的字块</p></li><li><p>有多种实现方法，一般使用双向链表</p></li><li><p>把当前访问节点置于链表前面（保证链表头部节点是最近使用的）</p></li><li><p>最近最少使用算法图解：</p><img src="..\计算机入门（计组-计网-操作系统）\LRU.png"/></li></ul></li></ul></li></ul><h3 id="计算机的CPU"><a href="#计算机的CPU" class="headerlink" title="计算机的CPU"></a>计算机的CPU</h3><h4 id="计算机的指令系统"><a href="#计算机的指令系统" class="headerlink" title="计算机的指令系统"></a>计算机的指令系统</h4><ul><li><p>机器指令的形式</p><ul><li><p>机器指令主要由两部分组成：操作码、地址码</p></li><li><p>操作码指明指令所要完成的操作</p></li><li><p>操作码的位数反映了机器的操作类型，假设操作码有8位，则会有2^8=256种操作种类</p></li><li><p>地址码直接给出操作数或者操作数的地址</p></li><li><p>分三地址码指令、二地址码指令和一地址码指令</p><ul><li><p>三地址指令：|操作码（OP）|addr1|addr2|addr3|</p><p>即(addr1)OP(addr2)-&gt;(addr3)    例：加法操作</p></li><li><p>二地址指令：|操作码（OP）|addr1|addr2|</p><p>即(addr1)OP(addr2)-&gt;(addr1) 或(addr2)</p></li><li><p>一地址指令：|操作码（OP）|addr1|</p><p>即(addr1)OP-&gt;(addr1) 或(addr1)OP(ACC)-&gt;(addr1)</p></li><li><p>零地址指令：</p><ul><li>在机器指令中无地址码（无敌芝麻😂😂😂）</li><li>空操作、停机操作、中断返回操作等</li></ul></li></ul></li></ul></li><li><p>机器指令的操作类型</p><ul><li><p>数据传输</p><ul><li>数据传输发生在哪里：在寄存器之间、寄存器与存储单元、存储单元之间传送</li><li>数据传输类型的操作：数据读写、交换地址数据、清零置一等操作</li></ul></li><li><p>算数逻辑操作</p><ul><li>操作数之间的加减乘除运算</li><li>操作数的与或非等逻辑位运算</li></ul></li><li><p>移位操作</p><ul><li>数据左移（乘2）、数据右移（除2）</li><li>完成数据在算术逻辑单元的必要操作</li></ul></li><li><p>控制指令</p><ul><li>等待指令、停机指令、空操作指令、中断指令等</li></ul></li></ul></li><li><p>机器指令的寻址方式</p><ul><li><p>指令寻址</p><ul><li>顺序寻址</li><li>跳跃寻址</li></ul></li><li><p>数据寻址</p><ul><li>立即寻址<ul><li>|操作码（OP）|addr1|<strong>6</strong>|    </li><li>指令直接获得操作数</li><li>无需访问存储器</li></ul></li><li>直接寻址<ul><li>|操作码（OP）|<strong>addr1</strong>|6|    </li><li>直接给出操作数在主存的地址</li><li>寻找操作数简单，无需计算数据地址</li></ul></li><li>间接寻址<ul><li>|操作码（OP）|R1|<strong>addr2</strong>|    </li><li>指令地址码给出的是操作数地址的地址</li><li>需要访问一次或多次主存来获取操作数</li></ul></li></ul></li></ul><table><thead><tr><th align="center">寻址方式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">立即寻址</td><td align="center">速度快</td><td align="center"><em>地址码位数限制操作数表示范围</em></td></tr><tr><td align="center">直接寻址</td><td align="center">寻找操作数简单</td><td align="center"><em>地址码位数限制操作数表示范围</em></td></tr><tr><td align="center">间接寻址</td><td align="center">操作数寻址范围大</td><td align="center">速度较慢</td></tr></tbody></table></li></ul><h4 id="计算机的控制器"><a href="#计算机的控制器" class="headerlink" title="计算机的控制器"></a>计算机的控制器</h4><p>控制器是协调和控制计算机运行的，控制器是由程序计数器、时序发生器、指令译码器、各种寄存器以及总线组成的。</p><ul><li><p>程序计数器</p><ul><li>程序计数器用来存储下一条指令的地址</li><li>CPU循环从程序计数器中拿出指令</li><li>当指令被拿出时，指向下一条指令</li></ul></li><li><p>时序发生器</p><ul><li>电气工程领域，用于发送时序脉冲</li><li>CPU依据不同的时序脉冲有节奏的进行工作</li></ul></li><li><p>指令译码器</p><ul><li>指令译码器是控制器的主要部件之一</li><li>计算机指令由操作码和地址码组成</li><li>翻译操作码对应的操作以及控制传输地址码对应的数据</li></ul></li><li><p>各种寄存器</p><ul><li>指令寄存器<ul><li>指令寄存器也是控制器的主要部件之一</li><li>从主存或高速缓存存取计算机指令</li></ul></li><li>主存地址寄存器<ul><li>保存当前CPU正要访问的内存单元的地址</li></ul></li><li>主存数据寄存器<ul><li>保存当前CPU正要读或写的主存数据</li></ul></li><li>通用寄存器<ul><li>用于暂时存放或传送数据或指令</li><li>可保存ALU的运算中间结果</li><li>容量比一般专用寄存器要大</li></ul></li></ul></li><li><p>总线</p></li></ul><h4 id="计算机的运算器"><a href="#计算机的运算器" class="headerlink" title="计算机的运算器"></a>计算机的运算器</h4><p>运算器是用来进行数据运算加工的，运算器是由数据缓存器、ALU、通用寄存器、状态字寄存器以及总线组成的</p><ul><li><p>数据缓冲器</p><ul><li>分为输入缓冲和输出缓冲</li><li>输入缓冲暂时存放外设送过来的数据</li><li>输出缓冲暂时存放送往外设的数据</li></ul></li><li><p>ALU</p><ul><li><p>ALU：算术逻辑单元，是运算器的主要组成</p></li><li><p>常见的位运算（左右移、与或非等）</p></li><li><p>算术运算（加减乘除等）</p></li><li><p>ALU图解：</p><img src="..\计算机入门（计组-计网-操作系统）\ALU.png"/></li></ul></li><li><p>通用寄存器</p><ul><li>用于暂时存放或传送数据或指令</li><li>可保存ALU的运算中间结果</li><li>容量比一般专用寄存器要大</li></ul></li><li><p>状态字寄存器</p><ul><li>存放运算状态（条件码、进位、溢出、结果正负等）</li><li>存放运算控制信息（调试跟踪标记位、允许中断位等）</li></ul></li><li><p>总线</p></li></ul><h4 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h4><ul><li><p>指令执行过程</p><p>取指令——&gt;分析指令——&gt;执行指令</p><img src="..\计算机入门（计组-计网-操作系统）\指令执行.png"/></li></ul><p>​        图解分析：</p><blockquote><p>程序计数器拿到第一条指令的地址101，然后通过总线拿到101地址里的内容，将其放入指令寄存器中缓存起来，指令寄存器并不能理解指令的意思，再将指令寄存器中的内容传送给指令译码器；此时程序计数器加1，变为102；指令译码器理解MOV R0,R1的意思：将R0寄存器的数据移动R1中去；理解后，指令译码器发出控制信号；控制信号通过片内总线到达运算器中；此时运算器会将R0(100)里的内容经过ALU通过总线，送到数据缓存器中，同时将R0(100)覆盖R1(100),到此地址101中的指令完成；接着从程序计数器中拿出102的指令开始执行。</p></blockquote><p>​        指令执行过程：</p><p>​        <img src="..\计算机入门（计组-计网-操作系统）\指令执行过程.png"/></p><p>小结：在计算机指令执行的过程中，取指令和分析指令是由控制器来工作的，在执行指令时，是由运算器在工作的，也就是说，控制器和运算器不能同时工作，从而导致CPU的综合利用率不高；影刺我们需要改变执行的执行过程，来提高CPU的综合利用率。</p><ul><li><p>CPU的流水线设计</p><ul><li><p>类似工厂的装配线</p></li><li><p>工厂的装配线是的多个产品可以同时被加工</p></li><li><p>在同一时刻，不同产品均位于不同的加工阶段</p><img src="..\计算机入门（计组-计网-操作系统）\CPU的流水线设计.png"/></li></ul></li></ul><h2 id="计算篇"><a href="#计算篇" class="headerlink" title="计算篇"></a>计算篇</h2><h3 id="进制运算的基本知识"><a href="#进制运算的基本知识" class="headerlink" title="进制运算的基本知识"></a>进制运算的基本知识</h3><h4 id="进制运算的基础"><a href="#进制运算的基础" class="headerlink" title="进制运算的基础"></a>进制运算的基础</h4><ul><li><p>进制的概述</p><ul><li>进位制是一种计数方式，亦称进位计数法或位值计数法</li><li>有限种数字符号来表示无限的数值</li><li>使用的数字符号的数目称为这种进位制的基数或底数</li><li>计算机喜欢二进制，但二进制表达太长了</li><li>使用大进制可以解决这个问题</li><li>八进制、十六进制满足2的n次方的要求</li></ul><p>几进制的话，顾名思义，到达几种不同的数就进一位</p></li><li><p>二进制运算的基础</p><img src="..\计算机入门（计组-计网-操作系统）\二进制的基础.png"/><p>按权展开法(整数的二进制转化为十进制)：N=0b101=1*2^2^ + 0 *2^1^ + 1 *2^0^ = 5</p><p>重复相除法（整数的十进制转化位二进制）</p><p>小数的按权展开法</p><p>小数的重复相除法</p></li></ul><h3 id="二进制数据的表示方法"><a href="#二进制数据的表示方法" class="headerlink" title="二进制数据的表示方法"></a>二进制数据的表示方法</h3><h4 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a>有符号数与无符号数</h4><ul><li><p>使用0表示正数，使用1表示负数：+237=011101101；-237=111101101</p></li><li><p>怎么判断他是数字位还是符号位呢？符号位放到数字位的最前面</p></li><li><p>原码表示法：</p><ul><li>使用0表示正数，1表示负数</li><li>规定符号位位于数值第一位</li><li>表达简单明了，是人类最容易理解的表示法</li><li>原码表示法的问题：<ul><li>0有两种表示方法：00、10</li><li>原码进行运算非常复杂，特别是两个操作数符号不同的时候<ul><li>判断两个操作数绝对值大小</li><li>使用绝对值大的书减去绝对值小的数</li><li>对于符号值，以绝对值大的为准</li></ul></li></ul></li></ul><p>希望找到不同符号操作数更加简单的运算方法</p><p>希望找到使用正数代替负数的方法</p><p>使用加法操作代替减法操作，从而消除减法</p></li></ul><h4 id="二进制的补码表示法"><a href="#二进制的补码表示法" class="headerlink" title="二进制的补码表示法"></a>二进制的补码表示法</h4><p>补码与原码的关系：</p><img src="..\计算机入门（计组-计网-操作系统）\补码.png"/><p>套用公式并没有解决使用减法的问题</p><h4 id="二进制的反码表示法"><a href="#二进制的反码表示法" class="headerlink" title="二进制的反码表示法"></a>二进制的反码表示法</h4><p>引进补码的目的：</p><ul><li>减法运算复杂，希望找到使用正数代替负数的方法</li><li>使用加法代替减法操作，从而消除减法</li><li><strong>但计算补码的过程中，还是使用了减法！！！</strong></li></ul><p>反码定义：</p><img src="..\计算机入门（计组-计网-操作系统）\反码定义.png"/><p>引进反码解决减法问题。</p><h4 id="小数的二进制补码表示"><a href="#小数的二进制补码表示" class="headerlink" title="小数的二进制补码表示"></a>小数的二进制补码表示</h4><p>小数的原补反和正数一样</p><p>负数的反码等于原码除符号位按位取反</p><p>负数的补码等于反码+1</p><h3 id="二进制数据的运算"><a href="#二进制数据的运算" class="headerlink" title="二进制数据的运算"></a>二进制数据的运算</h3><h4 id="定点数与浮点数"><a href="#定点数与浮点数" class="headerlink" title="定点数与浮点数"></a>定点数与浮点数</h4><ul><li><p>定点数的表示方法</p><ul><li>小数点固定在某个位置的数称为定点数</li></ul></li><li><p>浮点数的表示方法</p><ul><li><p>为什么要有浮点数呢？</p><ul><li>计算机处的很大程度上不是纯小数或纯正数</li><li>数据范围很大，定点数难以表达</li></ul></li><li><p>浮点数的表示格式</p><img src="..\计算机入门（计组-计网-操作系统）\浮点数的表示格式.png"/></li><li><p>浮点数的表示范围</p><p>假设阶码数值取m位，尾数数值取n位</p><p>阶码的表示范围：[-(2^m^ - 1)，2^m^ - 1]</p><p>尾数能够表示的最大值：1-2^(-n)</p><p>尾数能够表示的最小值：2^(-n)</p><p>尾数表示范围：[2^(-n), 1-2^(-n)]</p><img src="..\计算机入门（计组-计网-操作系统）\浮点数的表示范围.png"/><p>单精度浮点数：使用4字节、32位来表达浮点数（float）</p><p>双精度浮点数：使用8字节、64位表达浮点数（double）</p></li><li><p>浮点数的规格化</p><p>尾数规定使用纯小数</p><p>尾数最高位必须是1 </p><img src="..\计算机入门（计组-计网-操作系统）\浮点数例题.png"/></li></ul></li><li><p>定点数与浮点数的对比</p><ul><li>当定点数与浮点数位数相同时，浮点数表示的范围更大</li><li>当浮点数尾数为规格化数时，浮点数的精度更高</li><li>浮点数运算包含阶码和尾数，浮点数的运算更加复杂</li><li>浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数</li><li>浮点数在数的运算规则、运算速度、硬件成本方面不如定点数</li></ul></li></ul><h4 id="定点数的加减法运算"><a href="#定点数的加减法运算" class="headerlink" title="定点数的加减法运算"></a>定点数的加减法运算</h4><p>整数加法：A[补]+B[补] = [A+B] [补]（mod2^(n+1)）</p><p>小数加法：A[补]+B[补] = [A+B] [补]（mod2）</p><p>数值位与符号位一同运算，并将符号位产生的进位自然丢掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">例1：A=-110010，B=001101，求A+B</span></span><br><span class="line"><span class="comment">A[补] = 1,001110</span></span><br><span class="line"><span class="comment">B[补] = 0,001101</span></span><br><span class="line"><span class="comment">(A+B)[补] = 1,011011</span></span><br><span class="line"><span class="comment">A+B = -100101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例2：A=-1010000，B=-1110000，求A+B</span></span><br><span class="line"><span class="comment">A[补] = 1,0110000</span></span><br><span class="line"><span class="comment">B[补] = 1,0010000</span></span><br><span class="line"><span class="comment">(A+B)[补] = 0,1000000</span></span><br><span class="line"><span class="comment">A+B = 0,1000000</span></span><br><span class="line"><span class="comment">发生溢出</span></span><br><span class="line"><span class="comment">1byte的数值范围[-128~127]</span></span><br><span class="line"><span class="comment">问：-128为什么可以用1000 0000表示？（规定）</span></span><br><span class="line"><span class="comment">   这里我分析的是byte，它就8位。在无符号位的二进制中128的表示为1000 0000。有符号位的情况下byte好像无法表示+128或-128。</span></span><br><span class="line"><span class="comment">   如果我们假设现在byte不是占用8位，而是9位，最高位是符号位。那么-128就能够是1 1000 0000，其补码也是1 1000 0000，很神奇吧，一样的。-128的补码尾八位就是1000 0000。那就规定【1000 0000是-128的补码，且-128是没有原码和反码的，即不能利用1000 0000反推其原码和反码】。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>判断溢出：</p><ul><li><p>双符号位判断法</p><p>单符号位表示变为双符号位：0=&gt;00，1=&gt;11</p><p>双符号位产生的进位丢弃</p><p><strong>结果的双符号位不同则表示溢出</strong></p></li></ul><p>整数减法：A[补]-B[补] = A[补]+(-B[补]) = [A+(-B)] [补]（mod2^(n+1)）</p><p>小数减法：A[补]-B[补] = A[补]+(-B[补]) =  [A+(-B)] [补]（mod2）</p><p><strong>对于-B[补]，换一下B[补]的符号即可</strong></p><h4 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h4><p><strong>对阶——&gt;尾数求和——&gt;尾数规格化——&gt;舍入——&gt;溢出判断</strong></p><ul><li><p>对阶</p><ul><li><p>对阶的目的就是使得两个浮点数阶码一致，使得尾数可以进行运算</p></li><li><p>浮点数尾数运算简单，浮点数位数实际小数位与阶码有关</p></li><li><p>阶码按小阶看齐大阶的原则</p><img src="..\计算机入门（计组-计网-操作系统）\浮点数对阶.png"/></li></ul></li><li><p>尾数求和</p><ul><li><p>使用补码进行运算</p></li><li><p>减法运算转化为加法运算：A-B = A+(-B)</p><img src="..\计算机入门（计组-计网-操作系统）\浮点数尾数求和.png"/></li></ul></li><li><p>尾数规格化</p><ul><li><p>对补码进行规格化需要判断两种情况：S&gt;0和S&lt;0</p><ul><li>S[补] = <strong>00.1</strong>xxxxxxx(S&gt;0)</li><li>S[补] = <strong>11.0</strong>xxxxxxx(S&lt;0)</li></ul></li><li><p>如果不满足此格式（<strong>符号位与最高位不一致</strong>），需要进行左移，同时阶码相应变化，以满足规格化</p><img src="..\计算机入门（计组-计网-操作系统）\浮点数尾数规格化.png"/></li><li><p>尾数规格化右移</p><ul><li>一般情况下都是左移</li><li>双符号位不一致下需要右移（定点运算的溢出情况）</li><li>右移的话则需要进行舍入操作</li></ul></li></ul></li><li><p>舍入</p><ul><li>“0舍1入”法（二进制的四舍五入）</li></ul><img src="..\计算机入门（计组-计网-操作系统）\浮点数舍入.png"/><p>​        尾数两次右移，记得阶码+2：</p><img src="..\计算机入门（计组-计网-操作系统）\浮点数舍入2.png"/></li><li><p>溢出判断</p><ul><li>定点数运算双符号位不一致为溢出</li><li>浮点运算尾数双符号位不一致不算溢出，因为位数双符号位可以进行右规</li><li>浮点数运算主要通过阶码的双符号位判断是否溢出</li><li>如果规格化后，阶码双符号位不一致，则认为是溢出</li></ul></li></ul><h4 id="浮点数的乘除法运算（了解）"><a href="#浮点数的乘除法运算（了解）" class="headerlink" title="浮点数的乘除法运算（了解）"></a>浮点数的乘除法运算（了解）</h4><img src="..\计算机入门（计组-计网-操作系统）\浮点数乘除法.png"/><img src="..\计算机入门（计组-计网-操作系统）\浮点数乘除法2.png"/><p>阶码运算——&gt;尾数运算——&gt;尾数规格化——&gt;舍入——&gt;溢出判断</p><h2 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a>综合实践</h2><p>实践内容：实现双向链表——&gt;实现置换算法（先进先出算法、最近最少使用算法、最不经常使用算法）</p><p>实现双线链表：实现Node类——&gt;实现DoubleLinkedList类（pop()方法、append(node)方法、append_front(node)方法、remove(node)方法）</p><p>实现置换算法：实现Cache类（get(key)方法：返回value或-1）、put(key,value)方法</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="概述篇-1"><a href="#概述篇-1" class="headerlink" title="概述篇"></a>概述篇</h2><h3 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h3><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><h3 id="本章内容概览"><a href="#本章内容概览" class="headerlink" title="本章内容概览"></a>本章内容概览</h3><h2 id="网络层篇"><a href="#网络层篇" class="headerlink" title="网络层篇"></a>网络层篇</h2><h3 id="网络层IP协议相关"><a href="#网络层IP协议相关" class="headerlink" title="网络层IP协议相关"></a>网络层IP协议相关</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><h4 id="简单路由"><a href="#简单路由" class="headerlink" title="简单路由"></a>简单路由</h4><h3 id="网络层其他协议"><a href="#网络层其他协议" class="headerlink" title="网络层其他协议"></a>网络层其他协议</h3><h4 id="ARP协议与RARP协议"><a href="#ARP协议与RARP协议" class="headerlink" title="ARP协议与RARP协议"></a>ARP协议与RARP协议</h4><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><h3 id="IP的路由算法"><a href="#IP的路由算法" class="headerlink" title="IP的路由算法"></a>IP的路由算法</h3><h4 id="路由的概述"><a href="#路由的概述" class="headerlink" title="路由的概述"></a>路由的概述</h4><h4 id="内部网关路由协议"><a href="#内部网关路由协议" class="headerlink" title="内部网关路由协议"></a>内部网关路由协议</h4><h4 id="外部网关路由协议"><a href="#外部网关路由协议" class="headerlink" title="外部网关路由协议"></a>外部网关路由协议</h4><h2 id="传输层篇"><a href="#传输层篇" class="headerlink" title="传输层篇"></a>传输层篇</h2><h2 id="应用层篇"><a href="#应用层篇" class="headerlink" title="应用层篇"></a>应用层篇</h2><h2 id="综合实践-1"><a href="#综合实践-1" class="headerlink" title="综合实践"></a>综合实践</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><hr><p>操作系统的演进：</p><ol><li>无操作系统<ul><li>人工操作</li><li>用户独占</li><li>CPU等待人工操作</li><li><strong>资源利用率低</strong></li></ul></li><li>批处理系统<ul><li>无需等待人工操作</li><li>批量输入任务</li><li><strong>资源利用率提升</strong></li><li><strong>多道程序设计</strong></li></ul></li><li>分时系统<ul><li>人机交互</li><li>多用户共享</li><li><strong>及时调试程序</strong></li><li><strong>资源利用率提升</strong></li></ul></li></ol><hr><p>多道程序设计：</p><ul><li>早期批处理系统只能一次处理一个任务</li><li>多道程序设计使得批处理系统可以一次处理多个任务</li><li>多道程序设计是指在计算机内存中同时存放多个程序</li><li>多道程序在计算机的管理程序之下相互穿插运行</li><li><strong>对多道程序的管理是操作系统的重要功能</strong><ul><li>进程管理</li><li>存储管理</li><li>作业管理</li><li>文件管理</li><li>设备管理</li></ul></li></ul><hr><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="操作系统概览"><a href="#操作系统概览" class="headerlink" title="操作系统概览"></a>操作系统概览</h3><ol><li><p>What&amp;Why</p><p>操作系统是什么？</p><ul><li><p>操作系统是管理计算机硬件和软件资源的<strong>计算机程序</strong></p></li><li><p>管理配置内存、决定资源供需顺序、控制输入输出设备等</p></li><li><p>操作系统提供让用户和系统交互的操作界面</p></li><li><p>操作系统的种类是多种多样的，不局限于计算机</p></li><li><p>从手机到超级计算机，操作系统可简单也可复杂</p></li><li><p>在不同的设备上，操作系统可想用户呈现多种操作手段</p></li><li><p>手机的操作系统：Android（MIUI、ColorOS、Flyme）、iOS、华为“鸿蒙”？</p></li><li><p>常见的计算机操作系统：Windows、Linux（Centos、Ubuntu）、MacOS</p><p><strong>管理硬件、提供用户交互的软件系统</strong></p></li></ul><p>为什么需要操作系统？</p><ul><li>我们不可能直接操作计算机硬件</li><li>设备种类繁多复杂，需要统一界面</li><li>操作系统的简易性使得更多人能够使用计算机</li></ul></li><li><p>操作系统的基本功能</p><img src="..\计算机入门（计组-计网-操作系统）\操作系统的资源管理.png"/><ul><li><p><strong>操作系统统一管理着计算机资源（处理器资源、存储器资源、IO设备资源、文件资源）</strong></p></li><li><p>用户无需面向硬件接口编程</p></li><li><p>IO设备管理软件：提供读写接口</p></li><li><p>文件管理软件：提供操作文件接口</p></li><li><p><strong>操作系统实现了对计算机资源的抽象</strong></p></li><li><p><strong>操作系统提供了用户于计算机之间的接口（图像窗口形式、命令模式、系统调用模式[编程的形式]）</strong></p><img src="..\计算机入门（计组-计网-操作系统）\操作系统的基本功能.png"/></li></ul></li><li><p>操作系统相关概念</p><ul><li><p>并发性</p><ul><li><p>并行VS并发</p><ul><li><p>并行是指两个或多个事件可以在<strong>同一时刻</strong>发生</p></li><li><p>并发是指两个或多个事件可以在<strong>同一时间间隔</strong>发生</p><img src="..\计算机入门（计组-计网-操作系统）\并发与并行.png"/></li></ul></li></ul></li><li><p>共享性</p><ul><li><p>共享性表现为操作系统中的资源可供多个并发的程序共同使用</p></li><li><p>这种共同使用的形式称之为资源共享</p><img src="..\计算机入门（计组-计网-操作系统）\操作系统的共享性.png"/></li><li><p>互斥共享形式（打印机）</p><ul><li>当资源被程序A占用时，其他想使用的话只能等待</li><li>只能进程A使用完以后，其他进程才可以使用该资源</li></ul></li><li><p>同时访问形式</p><ul><li>某种资源在一段时间<strong>并发地</strong>被多个程序访问</li><li>这种“同时”是宏观的，从宏观去看该资源可以被同时访问</li></ul></li></ul></li><li><p>虚拟性</p><ul><li><p>虚拟性表现为把一个物理实体转变为若干个逻辑实体</p></li><li><p>物理实体是真实存在的，逻辑实体是虚拟的</p></li><li><p>虚拟的技术主要有<strong>时分复用技术</strong>和<strong>空分复用技术</strong></p></li><li><p><strong>时分复用技术</strong></p><ul><li><p>资源在时间上进行复用，不同程序并发使用</p></li><li><p>多道程序分时使用计算机的硬件资源</p></li><li><p>提供资源的利用率</p></li><li><p>虚拟处理器技术</p><ul><li>借助多道程序设计技术</li><li>为每个程序建立进程</li><li>多个程序分时复用处理器</li></ul></li><li><p>虚拟设备技术</p><ul><li>物理设备虚拟为多个逻辑设备</li><li>每个程序占用一个逻辑设备</li><li>多个程序通过逻辑设备并发访问</li></ul></li></ul></li><li><p><strong>空分复用技术</strong></p><ul><li><p>空分复用技术用来实现虚拟磁盘、虚拟内存等</p></li><li><p>提升资源的利用率，提升编程效率</p></li><li><p>虚拟磁盘技术</p><ul><li>物理磁盘虚拟为逻辑磁盘</li><li>C、D、E等逻辑盘</li><li>使用起来更加安全、方便</li></ul></li><li><p>虚拟内存技术</p><ul><li>在逻辑上扩大程序的存储容量</li><li>使用比实际内存更大的容量</li><li>大大提升编程效率</li></ul></li></ul></li></ul></li><li><p>异步性</p><ul><li><p>在多道程序环境下，允许多个进程并发执行</p></li><li><p>进程在使用资源时可能需要等待或放弃</p></li><li><p>进程的执行并不是一气呵成的，而是以走走停停的形式推进</p><img src="..\计算机入门（计组-计网-操作系统）\操作系统的异步性.png"/></li></ul></li></ul></li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li><p>进程管理之进程实体</p><ul><li><p>为什么需要进程</p><ul><li>没有配置OS之前，资源属于当前运行的程序</li><li>配置OS之后，引入<strong>多道程序设计</strong>的概念</li><li>合理的隔离资源、运行环境，提升资源利用率</li><li><strong>进程是系统进行资源分配和调度的基本单位</strong></li><li>进程作为程序独立运行的载体 ，保障程序正常执行</li><li>进程的存在使得操作系统资源的利用率大幅提升</li></ul></li><li><p>进程的实体</p><ul><li><p>主存中的进程形态</p><p>在主存中进程也是一段连续存储的空间，该空间称为进程控制块（PCB）</p><img src="..\计算机入门（计组-计网-操作系统）\进程控制块.png"/><p><strong>标识符</strong>：标识符唯一标记一个进程，用于区别其他进程</p><p><strong>状态</strong>：标记进程的进程状态，如：运行态</p><p>程序计数器：进程即将被执行的下一条指令的地址</p><p>内存指针：程序代码、进程数据相关指针</p><p>上下文数据：进程执行时处理器存储的数据</p><p>IO状态信息：被进程IO操作所占用的文件列表</p><p>记账信息：使用处理器时间、时钟数总和等</p><img src="..\计算机入门（计组-计网-操作系统）\主存中进程的形态.png"/><ul><li>进程控制块（PCB）：<ul><li>用于描述和控制进程运行的通用数据结构</li><li>记录进程当前状态和控制进程运行的全部信息</li><li>PCB使得进程是能够独立运行的基本单位</li><li>PCB是操作系统进行调度经常会被读取的信息</li><li>PCB是常驻内存的，存放在系统专门开辟的PCB区域内</li></ul></li></ul></li><li><p>进程与线程</p><p>一个进程（Process）可以有一个或多个线程（Thread）</p><img src="..\计算机入门（计组-计网-操作系统）\进程与线程.png"/><ul><li><strong>线程是操作系统进行运行调度的最小单位</strong></li><li>包含在进程中，是进程中实际运行工作的单位</li><li>一个进程可以并发多个线程，每个线程执行不同的任务</li></ul></li></ul><table><thead><tr><th align="center"></th><th align="center">进程</th><th align="center">线程</th></tr></thead><tbody><tr><td align="center">资源</td><td align="center">资源分配的基本单位</td><td align="center">不拥有资源</td></tr><tr><td align="center">调度</td><td align="center">独立调度的基本单位</td><td align="center">独立调度的最小单位</td></tr><tr><td align="center">系统开销</td><td align="center">进程系统开销大</td><td align="center">线程系统开销小</td></tr><tr><td align="center">通信</td><td align="center">进程IPC</td><td align="center">读写同一进程数据通信</td></tr></tbody></table></li></ul></li><li><p>进程管理之五状态模型</p><ul><li><p>创建状态</p><ul><li>分配PCB——&gt;插入就绪队列</li><li>创建进程时拥有PCB但其他资源尚未就绪的状态称为创建状态</li><li>操作系统提供fork函数接口创建进程</li></ul></li><li><p>就绪状态</p><ul><li>当进程被分配到除CPU以外的所有必要资源后</li><li>只要再获得CPU的使用权，就可以立即运行</li><li>其他资源都准备好、只差CPU资源的状态为就绪状态</li><li>在一个系统中多个处于就绪状态的进程通常排成一个队列，该队列称为就绪队列</li></ul></li><li><p>执行状态</p><ul><li>进程获取CPU，其程序正在执行称为执行状态</li><li>在单处理机中，在某个时刻只能有一个进程是处于执行状态</li></ul></li><li><p>阻塞状态</p><ul><li>进程因某种原因如：其他设备未就绪而无法继续执行</li><li>从而放弃CPU的状态称为阻塞状态</li><li>在一个系统中多个处于阻塞状态的进程通常排成一个队列，该队列称为阻塞队列</li></ul></li><li><p>终止状态</p><ul><li>系统清理——&gt;PCB归还</li><li>进程结束由系统清理或者归还PCB的状态称为终止状态</li></ul></li></ul><img src="..\计算机入门（计组-计网-操作系统）\进程的五状态模型.png"/></li><li><p>进程管理之进程同步</p><ul><li><p>为什么需要进程间同步</p><ul><li><p>生产者消费者问题</p><img src="..\计算机入门（计组-计网-操作系统）\生产者消费者问题.png"/><p>生产者往缓冲区+1，消费者往缓冲区-1，在生活中这种模型没有问题</p><p>缓冲（临界资源）是在Cache上的，生产者操作缓冲需要三个步骤：register=count;register=register+1;count=register</p><p>消费者操作缓冲需要三个步骤：register=count;register=register-1;count=register</p><p>单从生产者程序或消费者程序去看是没问题的</p><p>但两者并发执行时就可能出差错</p><img src="..\计算机入门（计组-计网-操作系统）\生产者消费者并发冲突.png"/></li><li><p>哲学家进餐问题</p><img src="..\计算机入门（计组-计网-操作系统）\哲学家进餐问题.png"/><img src="..\计算机入门（计组-计网-操作系统）\哲学家饿死.png"/><p>筷子为临界资源</p></li><li><p>根源问题：彼此相互之间没有通信，“如果生产者通知消费者我已经完成了一件产品”，“哲学家向旁边哲学家说我要进餐了”，则可以有效的解决问题</p></li><li><p>这是我们就需要进程间的同步</p></li><li><p>对竞争资源在多进程间进行使用次序的协调</p></li><li><p>使得并发执行的多个进程之间可以有效使用资源和互相合作</p></li></ul></li><li><p>进程间同步的原则</p><ul><li><p>临界资源</p><p>临界资源指的是一些虽作为共享资源却又无法同时被多个进程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源</p></li><li><p>空闲让进：资源无占用，允许使用</p></li><li><p>忙则等待：资源有占用，请求进程等待</p></li><li><p>有限等待：保证有限等待时间能够使用资源</p></li><li><p>让权等待：等待时，进程需要让出CPU</p></li><li><p>进程同步的方法：消息队列、共享存储、信号量</p></li></ul></li><li><p>线程同步</p><p>当多个线程并发使用资源时，会发生什么呢？</p><p>进程内的线程也是需要同步的。</p><ul><li>线程同步的方法<ul><li>互斥锁</li><li>读写锁</li><li>自旋锁</li><li>条件变量</li></ul></li></ul></li></ul></li><li><p>Linux的进程管理</p><ul><li><p>Linux进程的相关概念</p><ul><li><p>进程的类型</p><ul><li>前台进程<ul><li>前台进程就是具有终端（终端shell），可以和用户交互的进程</li></ul></li><li>后台进程<ul><li>与前台进程相对，没有占用终端的就是后台进程</li><li>后台程序基本上不和用户交互，优先级比前台进程低</li><li>将需要执行的命令以“&amp;”符号结束</li></ul></li><li>守护进程（特殊的后台进程）<ul><li>守护（daemon）进程是特殊的后台进程</li><li>很多守护进程在系统引导的时候启动，一直运行直到系统关闭</li><li>Linux有很多典型的守护进程</li><li>进程名字以“d”结尾的一般都是守护进程（crond、httpd、sshd、mysqld）</li></ul></li></ul></li><li><p>进程的标记</p><ul><li><p>进程ID</p><ul><li><p>进程ID是进程的唯一标记，每个进程拥有不同的ID</p></li><li><p>进程ID表现为一个非负整数，最大由操作系统限定</p></li><li><p>操作系统提供fork函数接口创建进程</p><img src="..\计算机入门（计组-计网-操作系统）\进程间fork.png"/></li><li><p>父子进程关系可以通过pstree命令查看</p></li><li><p>ID为0的进程为idle进程，是系统创建的第一个进程</p></li><li><p>ID为1的进程为init进程，是0号进程的子进程，完成系统初始化</p></li><li><p>init进程是所有用户进程的祖先进程</p></li></ul></li><li><p>进程的状态标记</p><table><thead><tr><th align="center">状态符号</th><th align="center">状态说明</th></tr></thead><tbody><tr><td align="center"><strong>R</strong></td><td align="center"><strong>（TASK_RUNNING），进程正处于运行状态</strong></td></tr><tr><td align="center"><strong>S</strong></td><td align="center"><strong>（TASK_INTERRUPTIBLE），进程正处于睡眠状态</strong></td></tr><tr><td align="center">D</td><td align="center">(TASK_UNINTERRUPTIBLE)，进程正在处于IO等待的睡眠状态</td></tr><tr><td align="center">T</td><td align="center">(TASK_STOPPED)，进程正处于暂停状态</td></tr><tr><td align="center">Z</td><td align="center">(TASK_DEAD or EXIT_ZOMBIE)，进程正处于退出状态或僵尸进程</td></tr></tbody></table></li></ul></li></ul></li><li><p>操作Linux进程的相关命令</p><ul><li><p>ps命令</p><ul><li>ps命令常用于显示当前进程的状态</li><li>ps命令常配合aux参数或ef参数和grep命令检索特定进程</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印进程详尽的信息</span></span><br><span class="line">ps -aux</span><br><span class="line"><span class="comment"># 查看root用户的进程</span></span><br><span class="line">ps -u root</span><br><span class="line"><span class="comment"># 查看当前指定进程</span></span><br><span class="line">ps -aux|grep <span class="string">&#x27;python3&#x27;</span></span><br><span class="line"><span class="comment"># 查看当前进程树</span></span><br><span class="line">ps -ef --forest</span><br><span class="line"><span class="comment"># 将进程按照cpu的使用频率进行排序后，打印在当前页面</span></span><br><span class="line">ps -aux --sort=-pcpu</span><br><span class="line"><span class="comment"># 将进程按照内存进行排序后，打印在当前页面</span></span><br><span class="line">ps -aux --sort=-pmem</span><br></pre></td></tr></table></figure></li><li><p>top命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前所有进程的状态</span></span><br><span class="line"><span class="comment"># PR:进程的优先级VIRT:进程的虚拟内存</span></span><br><span class="line"><span class="comment"># %CPU:进程占用的CPU %MEM:进程使用的内存</span></span><br><span class="line"><span class="comment"># TIME+：进程运行的时间 COMMAND：进程的命令</span></span><br><span class="line"><span class="comment"># total：总内存   free：空闲的内存  </span></span><br><span class="line"><span class="comment"># used：使用的内存   buffer/cache:已经被缓存的内存</span></span><br><span class="line">top</span><br></pre></td></tr></table></figure></li><li><p>kill命令</p><ul><li>kill命令发送指定信号给进程</li><li>kill -l可以查看操作系统支持的信号</li><li>只有（SIGKILL 9）信号可以无条件终止进程，其他信号进程有权忽略</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kill后台进程</span></span><br><span class="line"><span class="comment"># python3 running_process.py &amp;</span></span><br><span class="line"><span class="comment"># 发送9的信号给ID为62016的进程，关闭该进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 62016</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><ol><li><p>作业管理之进程调度</p><ul><li><p>进程调度概述</p><p>进程调度是指计算机通过决策，决定哪个就绪进程可以获得CPU使用权（前提：多道程序设计）</p><p>进程调度步骤一：保留旧进程的运行信息，清除旧进程（收拾包袱）</p><p>进程调度步骤二：选择新进程，准备运行环境并分配CPU（新进驻）</p><p>为了实现进程调度的这两个步骤，我们就需要了解以下三个机制：</p><ul><li><p>就绪队列的排队机制</p><p>将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程</p></li><li><p>选择运行进程的委派机制</p><p>调度程序以一定的策略选择就绪进程，将CPU资源分配给他</p></li><li><p>新老进程的上下文切换机制</p><img src="..\计算机入门（计组-计网-操作系统）\新老进程的切换机制.png"/><p>保存当前进程的上下文信息，装入被委派执行进程的运行上下文</p></li></ul><p>如果新进程进来时，老进程还没有执行完，该咋办？</p><ul><li><p>非抢占式的调度</p><ul><li>处理器一旦分配给某个进程，就让该进程一直使用下去</li><li>调度程序不以任何原因抢占正在被使用的处理器</li><li>直到进程完成工作或因为IO阻塞才会让出处理器</li></ul></li><li><p>抢占式的调度</p><ul><li>允许调度程序以一定的策略暂停当前运行的进程</li><li>保存好旧进程的上下文信息，分配处理器给新进程</li></ul><table><thead><tr><th align="center"></th><th align="center">抢占式调度</th><th align="center">非抢占式调度</th></tr></thead><tbody><tr><td align="center">系统开销</td><td align="center">频繁切换，开销大</td><td align="center">切换次数少，开销小</td></tr><tr><td align="center">公平性</td><td align="center">相对公平</td><td align="center">不公平</td></tr><tr><td align="center">应用</td><td align="center">通用系统</td><td align="center">专用系统</td></tr></tbody></table></li></ul></li><li><p>进程调度算法</p><ul><li><p>先来先服务调度算法</p><img src="..\计算机入门（计组-计网-操作系统）\先来先服务调度算法.png"/></li><li><p>短进程优先调度算法</p><p>调度程序优先选择就绪队列中运行时间最短的进程</p><p>短进程优先调度算法不利于长作业进程的执行</p></li><li><p>高优先权调度算法</p><p>进程附带优先权，调度程序优先选择权重高的进程</p><p>高优先权优先权调度算法使得紧迫的任务可以优先处理</p><p>前台进程（与用户交互）优先级&gt;后台进程优先级</p></li><li><p>时间片轮转调度算法</p><p>按照先来先服务的原则排列就绪进程</p><p>每次从队列头部取出待执行进程，分配一个时间片执行</p><p>是相对公平的调度算法，但不能保证及时响应用户</p></li></ul></li></ul></li><li><p>作业管理之死锁</p><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><ul><li><p>死锁的产生</p><ul><li><p>竞争资源</p><ul><li><p>共享资源数量不满足各个进程需求</p></li><li><p>各个进程之间发生资源竞争导致死锁</p><img src="..\计算机入门（计组-计网-操作系统）\资源竞争.png"/></li></ul></li><li><p>进程调度顺序不当</p><img src="..\计算机入门（计组-计网-操作系统）\进程调度顺序不当.png"/></li></ul></li><li><p>死锁的处理</p><ul><li><p>死锁的四个必要条件（4个条件任一 &lt;= 死锁）</p><ul><li><p>互斥条件</p><p>进程对资源的使用是排他性的使用</p></li></ul><p>​       某资源只能由一个进程使用，其他进程需要使用只能等待</p><ul><li><p>请求保持条件</p><p>进程至少保持一个资源，又提出新的资源请求</p><p>新资源被占用，请求被阻塞</p><p>被阻塞的进程不释放自己保持的资源</p></li><li><p>不可剥夺条件</p><p>进程获得的资源在未完成使用前不能被剥夺</p><p>获得的资源只能由进程自身释放</p></li><li><p>环路等待条件</p><p>发生死锁时，必然存在进程-资源环形链</p><img src="..\计算机入门（计组-计网-操作系统）\进程资源环形链.png"/></li></ul></li><li><p>预防死锁的方法</p><ul><li><p>摒弃请求保持条件</p><p>系统规定进程运行之前，一次性申请所有需要的资源</p><p>进程在运行期间不会提出资源请求，从而摒弃请求保持条件</p></li><li><p>摒弃不可剥夺条件</p><p>当一个进程请求新的资源得不到满足时，必须释放占有的资源</p><p>进程运行时占有的资源可以被释放，意味着可以被剥夺</p></li><li><p>摒弃环路等待条件</p><p>可用资源线性排序，申请必须按照需要递增申请</p><p>线性申请不再形成环路，从而摒弃了环路等待条件</p></li></ul></li><li><p>银行家算法</p><ul><li><p>是一个可操作的著名的避免死锁的算法</p></li><li><p>以银行借贷系统分配策略为基础的算法</p></li><li><p>客户申请的贷款是有限的，每次申请需声明最大资金量</p></li><li><p>银行家在能够满足贷款时，都应该给用户贷款</p></li><li><p>客户在使用贷款后，能够及时归还贷款</p><p>已分配资源表：</p><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">4</td></tr><tr><td align="center">P2</td><td align="center">1</td><td align="center">4</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">P3</td><td align="center">1</td><td align="center">3</td><td align="center">5</td><td align="center">4</td></tr><tr><td align="center">P4</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>所需资源表：</p><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center">0</td><td align="center">6</td><td align="center">5</td><td align="center">6</td></tr><tr><td align="center">P2</td><td align="center">1</td><td align="center">9</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">P3</td><td align="center">1</td><td align="center">3</td><td align="center">5</td><td align="center">6</td></tr><tr><td align="center">P4</td><td align="center">1</td><td align="center">7</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>可分配资源表：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">5</td><td align="center">2</td><td align="center">0</td></tr></tbody></table><p>银行家算法：</p><p>所需资源表与已分配资源表做相减运算：</p><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center">0</td><td align="center">6</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">P2</td><td align="center">0</td><td align="center">5</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">P3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">P4</td><td align="center">0</td><td align="center">7</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>对照该表与可分配资源表：只有P2有足够的运行条件，于是给P2分配资源，等待P2执行完，归还资源。</p></li></ul></li></ul></li></ul></li></ol><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><ol><li><p>存储管理之内存分配与回收（物理内存的角度）</p><p>早期计算机编程并不需要过多的存储管理，随着计算机和程序越来越复杂，存储管理成为必要</p><p>确保计算机有足够的内存处理数据</p><p>确保程序可以从可用内存中获取一部分内存使用</p><p>确保程序可以归还使用后的内存以供其他程序使用</p><ul><li><p>内存分配的过程</p><ul><li><p>单一连续分配（过时）</p><p>单一连续分配是最简单的内存分配方式</p><p>只能在单用户、单进程的操作系统中使用</p></li><li><p>固定分区分配</p><p>固定分区分配是支持多道程序的最简单存储分配方式</p><p>内存空间被划分为若干固定大小的区域</p><p>每个分区只提供一个程序使用，互不干扰</p></li><li><p>动态分区分配（常用）</p><p>根据进程实际需要，动态分配内存空间</p><p>相关数据结构、分配算法</p><img src="..\计算机入门（计组-计网-操作系统）\动态分区分配.png"/><img src="..\计算机入门（计组-计网-操作系统）\动态分区链表结构.png"/><p>动态分区分配算法：</p><ul><li><p>首次适应算法（FF算法）</p><ul><li><p>分配内存时从开始顺序查找适合内存区</p></li><li><p>若没有适合的空闲区，则该次分配失败</p></li><li><p>每次从头部开始，使得头部地址空间不断被划分</p></li><li><p>改进的算法：循环适应算法</p><p>不是从头部开始分配，而是从上一次分配的位置开始。</p></li></ul></li><li><p>最佳适应算法（BF算法）</p><ul><li><p>最佳适应算法要求空闲区链表按照容量大小排序</p></li><li><p>遍历空闲区链表找到最佳合适空闲区</p><img src="..\计算机入门（计组-计网-操作系统）\最佳适应分配.png"/></li></ul></li><li><p>快速适应算法（QF算法）</p><ul><li><p>快速适应算法要求有多个空闲区链表</p></li><li><p>每个空闲区链表存储一种容量的空闲区</p><img src="..\计算机入门（计组-计网-操作系统）\快速适应算法.png"/></li></ul></li></ul></li></ul></li><li><p>内存回收的过程</p><p>四种回收区与空闲区的位置关系：</p><img src="..\计算机入门（计组-计网-操作系统）\回收区与空闲区的四种情况.png"/><p>情况一：</p><ul><li>不需要新建空闲链表节点</li><li>只需要把空闲区1的容量增大为空闲区即可</li></ul><p>情况二：</p><ul><li>将回收区与空闲区合并</li><li>新的空闲区使用回收区的地址</li></ul><p>情况三：</p><ul><li>将空闲区1、空闲区2和回收区合并</li><li>新的空闲区使用空闲区1的地址</li></ul><p>情况四：</p><ul><li>为回收区创建新的空闲节点</li><li>插入到相应的空闲区链表中去</li></ul></li></ul></li><li><p>存储管理之段页式存储管理</p><p>上一节主要从物理内存的角度聊内存管理，这一节主要从进程的角度聊进程的存储管理。</p><p>也就是问：操作系统如何管理进程的存储空间的呢？</p><p><strong>字块</strong>是相对物理设备的定义</p><p><strong>页面</strong>则是相对逻辑空间的定义</p><ul><li><p>页式存储管理</p><ul><li><p>将进程逻辑空间等分成若干大小的页面</p></li><li><p>相应的把物理内存空间分成也页面大小相等的物理块</p></li><li><p>以页面为单位把进程空间装进物理内存中分散的物理块</p></li><li><p>页面大小应该适中，过大难以分配，过小内存碎片过多</p></li><li><p>页面大小通常512B~8K</p><img src="..\计算机入门（计组-计网-操作系统）\内存碎片.png"/></li><li><p><strong>页表</strong>记录进程逻辑空间与物理空间的映射</p><img src="..\计算机入门（计组-计网-操作系统）\页表.png"/></li><li><p>页式存储管理存在的问题：</p><p>现代计算机系统中，可以支持非常大的逻辑地址空间（2^32 ~ 2^ 64），这样，页表就变得非常大，要占用非常大的内存空间，如，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M（2^20）个，如果每个页表项占用1Byte，故每个进程仅仅页表就要占用1MB的内存空间。</p></li></ul></li><li><p>段式存储管理</p></li><li><p>段页式存储管理</p></li></ul></li><li><p>存储管理之虚拟内存</p></li><li><p>Linux的存储管理</p></li></ol><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ol><li>操作系统的文件管理</li><li>Linux的文件系统</li><li>Linux文件的基本操作</li></ol><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><ul><li>操作系统的设备管理</li></ul><h2 id="提升篇"><a href="#提升篇" class="headerlink" title="提升篇"></a>提升篇</h2><h2 id="综合实践-2"><a href="#综合实践-2" class="headerlink" title="综合实践"></a>综合实践</h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/BV1pt4y1B72b?p=3&spm_id_from=pageDriver">程序员计算机编程入门基础知识（ 计算机组成原理／操作系统／计算机网络）_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1LJ41137HP?from=search&seid=3851297754132103474&spm_id_from=333.337.0.0">第三章：存储器_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> 计组计网操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组计网操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺</title>
      <link href="/2021/10/10/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2021/10/10/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html笔记（狂神）</title>
      <link href="/2021/10/02/html%E7%AC%94%E8%AE%B0%EF%BC%88%E7%8B%82%E7%A5%9E%EF%BC%89/"/>
      <url>/2021/10/02/html%E7%AC%94%E8%AE%B0%EF%BC%88%E7%8B%82%E7%A5%9E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML笔记（狂神说Java）"><a href="#HTML笔记（狂神说Java）" class="headerlink" title="HTML笔记（狂神说Java）"></a>HTML笔记（狂神说Java）</h2><p>​    Hyper Text Markup Language（超文本标记语言）</p><p>​    讲师：秦疆</p><h3 id="一、初识HTML"><a href="#一、初识HTML" class="headerlink" title="一、初识HTML"></a>一、初识HTML</h3><h3 id="二、网页基本标签"><a href="#二、网页基本标签" class="headerlink" title="二、网页基本标签"></a>二、网页基本标签</h3><h3 id="三、图像，超链接，网页布局"><a href="#三、图像，超链接，网页布局" class="headerlink" title="三、图像，超链接，网页布局"></a>三、图像，超链接，网页布局</h3><h3 id="四、列表，表格，媒体元素"><a href="#四、列表，表格，媒体元素" class="headerlink" title="四、列表，表格，媒体元素"></a>四、列表，表格，媒体元素</h3><h3 id="五、表单及表单应用"><a href="#五、表单及表单应用" class="headerlink" title="五、表单及表单应用"></a>五、表单及表单应用</h3><h3 id="六、表单初级验证"><a href="#六、表单初级验证" class="headerlink" title="六、表单初级验证"></a>六、表单初级验证</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础查漏补缺</title>
      <link href="/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2021/09/05/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><a href="#Java%E6%A6%82%E8%BF%B0">Java概述</a></p><p><a href="#%E5%8F%98%E9%87%8F">变量</a></p><p><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></p><p><a href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">控制结构</a></p><p><a href="#%E6%95%B0%E7%BB%84">数组</a></p><p><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a></p><p><a href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3">枚举和注解</a></p><p><a href="#%E5%BC%82%E5%B8%B8">异常</a></p><p><a href="#%E5%B8%B8%E7%94%A8%E7%B1%BB">常用类</a></p><p><a href="#%E9%9B%86%E5%90%88">集合</a></p><p><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></p><p><a href="#%E7%BA%BF%E7%A8%8B">线程</a></p><p><a href="#IO">IO</a></p><p><a href="#Mysql%E5%9F%BA%E7%A1%80">Mysql基础</a></p><p><a href="#JDBC%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0">JDBC和连接池</a></p><p><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></p><p><a href="#Java8%E5%92%8CJava11%E6%96%B0%E7%89%B9%E6%80%A7">Java8和Java11新特性</a></p><h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="如何快速学习新技术"><a href="#如何快速学习新技术" class="headerlink" title="如何快速学习新技术"></a>如何快速学习新技术</h2><ol><li>需求<ul><li>工作需要</li><li>跳槽</li><li>技术控</li></ul></li><li>看看能否使用传统技术解决<ul><li>能解决，但是不完美</li><li>解决不了</li></ul></li><li>引出我们学习的新技术和知识点</li><li>学习新技术或者知识点的基本原理和基本语法（不要考虑细节）</li><li>快速入门（基本程序，crud）</li><li>开始研究技术的注意事项，使用细节，使用规范，如何优化——&gt;没有止境，技术魅力</li></ol><h2 id="Java的应用领域"><a href="#Java的应用领域" class="headerlink" title="Java的应用领域"></a>Java的应用领域</h2><ul><li><p>企业级应用</p><p>主要指复杂的大企业的软件系统、各种类型的网站。应用领域包括金融、电信、交通、电子商务等</p></li><li><p>Android平台应用</p><p>Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实</p></li><li><p>移动领域应用</p><p>主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括机顶盒、车载的大屏影音娱乐设备、汽车通信设备、扫码的pos机等</p></li></ul><h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><p>程序：计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p><p>举例说明：</p><img src="..\Java基础查漏补缺\什么是程序.png"/><h2 id="Java历史"><a href="#Java历史" class="headerlink" title="Java历史"></a>Java历史</h2><ul><li>1990sun公司启动绿色计划</li><li>1992创建oak（橡树）语言——&gt;Java</li><li>1994gosling参加硅谷大会演示Java功能，震惊世界</li><li>1995sun正式发布Java第一个版本</li><li>2009年，甲骨文公司宣布收购sun，2011年，发布Java7</li><li><a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">其他Java版本发布详情</a></li></ul><h2 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h2><ul><li><p>Java SE（Java Standard Edition）标准版</p><p>支持面向桌面级应用（如windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</p></li><li><p>Java EE（Java Enterprise Edition）企业版</p><p>是为开发企业环境下的应用程序提供的一套解决方案，该技术体系种包含的技术如：servlet、Jsp等，主要针对于web应用程序开发，版本以前称为J2SE</p></li><li><p>Java ME（Java Micro Edition）小型版</p><p>支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME</p></li></ul><h2 id="Java重要特点"><a href="#Java重要特点" class="headerlink" title="Java重要特点"></a>Java重要特点</h2><ol><li><p>Java语言是面向对象的（oop）</p></li><li><p>Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证</p></li><li><p>Java语言是跨平台性的</p><p>即一个编译好的.class文件可以在多个系统下运行，这种特性称为跨平台性</p><img src="..\Java基础查漏补缺\跨平台性.png"/></li><li><p>Java语言是解释型的【了解】</p><p>解释型语言：Javascript、PHP、Java    编译型语言：C/C++</p><p>区别是：</p><p>解释型语言：解释后的代码不能直接被机器执行，需要解释器来执行</p><p>编译型语言：编译后的代码可以直接被机器执行</p></li></ol><h2 id="Java的开发工具"><a href="#Java的开发工具" class="headerlink" title="Java的开发工具"></a>Java的开发工具</h2><ul><li>editplus、notepad++</li><li>sublime Text</li><li>IDEA</li><li>eclipse</li></ul><h2 id="Java运行机制及运行过程"><a href="#Java运行机制及运行过程" class="headerlink" title="Java运行机制及运行过程"></a>Java运行机制及运行过程</h2><ul><li><p>Java语言的特点：跨平台性</p><img src="..\Java基础查漏补缺\Java语言的特点.png"/><p>说明：因为有了JVM，同一个Java程序在三个不同的操作系统种都可以执行，这样就实现了Java程序的跨平台性</p></li><li><p>Java核心机制——Java虚拟机（java virtual machine）</p><ol><li>基本介绍<ul><li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令、管理数据、内存、寄存器，包含在JDK中</li><li>对于不同的平台，有不同的虚拟机</li><li>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li></ul></li></ol></li></ul><h2 id="什么是JDK，JRE"><a href="#什么是JDK，JRE" class="headerlink" title="什么是JDK，JRE"></a>什么是JDK，JRE</h2><ul><li><p>JDK基本介绍</p><ol><li><p>JDK的全程（Java Development Kit Java开发工具包）</p><p>JDK = JRE + Java的开发工具【java，javac，javadoc，javap等】</p></li><li><p>JDK是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE，所以安装了JDK，就不用再单独安装JRE了</p></li></ol></li><li><p>JRE基本介绍</p><ol><li>JRE（Java Runtime Environment Java运行时环境）</li><li>包括Java虚拟机（JVM Java Virtual Machine）和Java程序所需的核心类库等。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可</li></ol></li><li><p>JDK、JRE和JVM的包含关系</p><ol><li>JDK = JRE + 开发工具集（例如Javac、Java编译工具等）</li><li>JRE = JVM + Java SE标准类库（Java核心类库）</li><li>JDK = JVM + Java SE标准类库 + 开发工具集</li><li>如果只想运行开发好的.class文件只需要JRE</li></ol></li></ul><h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>歪比巴布</p><h2 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h2><ul><li><p>Java执行流程分析</p><img src="..\Java基础查漏补缺\Java执行流程.png"/></li><li><p>什么是编译</p><p><code>javac Hello.java</code></p><ol><li>有了Java源文件，通过编译将其编译成JVM可以识别的字节码文件</li><li>在该文件目录下，通过javac编译工具对Hello.java文件进行编译</li><li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Hello.class文件，该文件称为字节码文件，也是可以执行的java的程序</li></ol></li><li><p>什么是运行</p><ol><li>有了可执行的java程序（Hello.class字节码文件）</li><li>通过运行工具java.exe对字节码文件进行执行，本质就是将.class文件装在到JVM上执行</li></ol></li><li><p>java程序开发注意事项</p><p>对修改后的Hello.java源文件需要重新编译，生成新的class文件后，再进行执行，才能生效</p></li></ul><h2 id="Java开发注意事项和细节说明"><a href="#Java开发注意事项和细节说明" class="headerlink" title="Java开发注意事项和细节说明"></a>Java开发注意事项和细节说明</h2><ol><li><p>Java源文件以.class为扩展名。该文件的基本组成部分是类（class），如本类中的Hello类</p></li><li><p>Java应用程序的执行入口是main（）方法，它有固定的书写格式：</p><p><code>public static void main(String[] args)&#123;……&#125;</code></p></li><li><p>Java语言严格区分大小写</p></li><li><p>Java方法由一条条语言构成，每个语句以“；”结束。</p></li><li><p>大括号都是成对出现的，缺一不可。【习惯：先写{}再写代码】</p></li><li><p>一个源文件中最多只能有一个public类。其他类的个数不限</p></li><li><p>如果源文件中包含一个public类。则文件名必须按该类名命名</p></li><li><p>一个源文件中最多只能有一个public类，其他类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        ((UserServiceImpl)userService).setUserDao(<span class="keyword">new</span> UserDaoImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,小狗狗！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Java转义字符"><a href="#Java转义字符" class="headerlink" title="Java转义字符"></a>Java转义字符</h2><ul><li><p>Java常用的转义字符</p><ol><li><p>\t：一个制表位，实现对齐的功能</p></li><li><p>\n：换行符</p></li><li><p>\\：一个\</p></li><li><p>\“：一个“</p></li><li><p>\‘：一个‘</p></li><li><p>\r：一个回车</p><p><code>System.out.println(&quot;韩顺平教育\r北京&quot;);</code></p></li></ol><p>回车与换行：<br>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，<strong>告诉打字机把打印头定位在左边界</strong>；另一个叫做“换行”，<strong>告诉打字机把纸向下移一行</strong>。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；<br>Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车&gt;”，即“\n\r”；<br>Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。<br>\r回车是将光标移到一行的前面<br>\n是移到下一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">转义字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,小\n狗狗！！！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;世界真大\r，我想去看看！！！&quot;</span>);<span class="comment">//回车符会使得之后的内容输出在同一行第一个位置</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;\\&quot;</span>+<span class="string">&quot;\&quot;&quot;</span>+<span class="string">&quot;\&#x27;&quot;</span>+<span class="string">&quot;hualala-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">Hello,小</span></span><br><span class="line"><span class="comment">狗狗！！！</span></span><br><span class="line"><span class="comment">，我想看看</span></span><br><span class="line"><span class="comment">Hello\&quot;&#x27;hualala-2</span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="注释（comment）"><a href="#注释（comment）" class="headerlink" title="注释（comment）"></a>注释（comment）</h2><ul><li><p>介绍：</p><p>用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性），注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现</p></li><li><p>Java中的注释类型</p><ol><li><p>单行注释</p></li><li><p>多行注释</p></li><li><p>文档注释</p></li></ol><ul><li><p>单行注释</p><p>基本格式：</p><p>//注释文字</p></li><li><p>多行注释</p><p>基本格式：</p><p>/* 注释文字 */</p></li><li><p>使用细节</p><ol><li>被注释的文字不会被JVM（java虚拟机）解释执行</li><li>多行注释里面不允许有多行注释嵌套</li></ol></li><li><p>文档注释：</p><p>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类</p><ul><li><p>基本格式</p></li><li><p>如何生成对应的文档注释</p></li><li><p>应用实例</p><p><code>javadoc -d 文件夹名 -xx -yy Demo.java</code></p><p><code>javadoc -d d:\\temp -author -version Comment02.java</code></p></li><li><p>javadoc标签</p></li></ul></li></ul></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ol><li>类、方法的注释要以javadoc的方式来写</li><li>非Java Doc的注释，往往是给代码的维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等</li><li>使用tab操作，实现缩进，默认整体向右移动；用shift+tab整体向左移动</li><li>运算符和 = 两边习惯性各加一个空格</li><li>源文件使用utf-8编码</li><li>行宽度不要超过80字符</li><li>代码编写次行风格（大括号位置：下一行起始）和尾行风格（大括号位置：行尾）</li></ol><h2 id="DOS命令（了解）"><a href="#DOS命令（了解）" class="headerlink" title="DOS命令（了解）"></a>DOS命令（了解）</h2><ul><li><p>DOS介绍</p><p>DOS：Disk Operating System 磁盘路径系统，简单说一下windows的目录结构</p><img src="..\Java基础查漏补缺\dos的基本原理.png"/></li><li><p>相关的只是补充：相对路径，绝对路径</p><p>相对路径：从当前目录开始定位，形成的一个路径<br>绝对路径：从顶级目录开始定位，形成的路径</p></li><li><p>常用的dos命令</p><ol><li><p>查看当前目录有什么</p><p><code>dir d:\abc2\test200</code></p></li><li><p>切换到其他盘下：盘符号（cd）</p><p>切换到c盘：<code>cd /D c</code></p></li><li><p>切换到当前盘的其他目录下（使用相对论路径和绝对路径演示）</p><p><code>cd d:\abc2\test200</code></p><p><code>cd ..\..\abc2\abc2\test200</code></p></li><li><p>切换到上一级</p><p><code>cd ..</code></p></li><li><p>切换到根目录</p><p><code>cd \</code></p></li><li><p>查看指定的目录下所有的子级目录</p><p><code>tree</code></p></li><li><p>清屏</p><p><code>cls</code></p></li><li><p>退出</p><p><code>exit</code></p></li><li><p>说明：因为小伙伴后面使用dos非常少，所以下面的几个指令，大家了解即可（md、rd、copy、del、echo、type、move）</p></li></ol></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java概述讲了什么呢？<br>首先Java是由一个叫高斯林的人在95年推出的，Java的运行机制；jvm、jre、jdk三者的关系；写代码的一些注意事项；基础的dos命令；转义字符；jdk的安装</p><p>tips：先完成功能，再优化细节。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>为什么需要变量？</p><p>一个程序就是一个世界</p><p>变量是程序的基本组成单位</p><p>不论是使用哪种高级程序语言编写程序，变量都是其程序的基本组成单位</p><p>变量有三个基本要素（类型+名称+值）</p><ul><li><p>概念</p><p>变量相当于内存中的一个数据存储空间的表示，你可以把变量看作是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量（值）</p></li><li><p>变量使用的基本步骤</p><ol><li><p>声明变量</p><p>int a;</p></li><li><p>赋值</p><p>a = 60;</p></li><li><p>使用System.out.println(a);</p><p>也可以一步到位    int a = 60;</p></li></ol></li><li><p>变量使用注意事项</p><ol><li>变量表示内存中的一个存储区域【不同的变量，类型不同】</li><li>该区域有自己的名称【变量名】和类型【数据类型】</li><li>变量必须先声明，后使用，即有顺序</li><li>该区域的数据可以在同一类型范围内不断变化</li><li>变量在同一个作用域内不能重名</li><li>变量=数据类型+名称+值，这一点请大家注意，变量的三要素</li></ol></li></ul><h2 id="号的使用"><a href="#号的使用" class="headerlink" title="+号的使用"></a>+号的使用</h2><ol><li>当左右两边都是数值型，则做加法运算</li><li>当左右两边有一方为字符串，则做拼接运算</li><li>运算顺序是从左到右的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">100</span>+<span class="number">99</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;100&quot;</span>+<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//100+2先正常执行变为102，遇到字符串后，变为字符串，运算顺序从左到右</span></span><br><span class="line">System.out.println(<span class="number">100</span>+<span class="number">2</span>+<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>+<span class="number">100</span>+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">199</span></span><br><span class="line"><span class="comment">10099</span></span><br><span class="line"><span class="comment">102Hello</span></span><br><span class="line"><span class="comment">Hello1002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><img src="..\Java基础查漏补缺\数据类型.png"/><p>然后就是数据类型介绍，分为基本数据类型和引用数据类型，</p><p>基本数据类型：byte（-128 ~ 127）、short（-32768 ~ 32767）（-2^15~ 2^ 15-1）、int(-2^31 <del>2^ 31-1)、long(-2^ 63</del>2^ 63-1)、float（4字节）、double（8字节）、boolean(1个字节)、char（2字节）；引用数据类型：类、接口、数组等。</p><ul><li><p>整数类型</p><p>Java的整数类型就是用于存放整数值的，比如12，2，2345等</p><img src="..\Java基础查漏补缺\整数类型.png"/><p>万一需要表示比long类型最大的值都要大的数，咋表示呢，有常用类中的BigInteger和BigDecimal可以使用。</p><ul><li>整数类型的使用细节<ol><li>Java各整数类型有固定的范围和字段长度，不受具体OS【操作系统】的影响，以保证Java程序的可移植性</li><li>Java的整型常量默认为int型，声明long型常量须在后面加‘l’或‘L’</li><li>Java程序中变量常声明为int型，除非不足以表示大数，才使用long</li><li>bit：计算机中的最小存储单位，byte：计算机中基本存储单位，1byte=8bit</li></ol></li></ul></li><li><p>浮点类型</p><p>Java的浮点型可以表示一个小数不如123.4，7.8，0.12等</p><p>使用long型时，加上“l”或“L”，如int id = 1L；编译器先看到1L确定给它分配8个字节，然后再进行赋值操作。</p><p>然后就浮点数嘛，单精度4字节和双精度8字节，浮点数=符号位+指数位+尾数位。小数都是近似值。</p><p>float num1 = .002；报错，.002没啥问题，但小数默认double双精度，使用float类型，加上“f”或“F”。</p><p>float类型保留小数点后7位。double保留小数点后16位左右。</p><p>科学计数法：5.12e2表示5.12*（10^2）；e不是2.7。</p><img src="..\Java基础查漏补缺\浮点型.png"/><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    浮点型数值使用陷阱：2.7和8.1/3是否相等（小数比较）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> num1 = <span class="number">1.12345678901F</span>;</span><br><span class="line">        <span class="keyword">double</span> num2 = <span class="number">1.123456789012121211232323123231</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> num3 = <span class="number">2.7</span>;</span><br><span class="line">        <span class="keyword">double</span> num4 = <span class="number">8.1</span>/<span class="number">3</span>;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(num4);</span><br><span class="line"></span><br><span class="line">        System.out.println(num3-num4);</span><br><span class="line">        <span class="comment">//那如何比较两个小数是否相等呢？</span></span><br><span class="line">        <span class="comment">//显然if(num3==num4)肯定是不可取的</span></span><br><span class="line">        <span class="comment">//当比较的两小数的绝对值在默认相等的范围内，即可认为两数相等</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(num3-num4)&lt;<span class="number">0.000001</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;差值在默认范围内，可以认为相等！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1.1234568</span></span><br><span class="line"><span class="comment">    1.1234567890121212</span></span><br><span class="line"><span class="comment">    2.7</span></span><br><span class="line"><span class="comment">    2.6999999999999997</span></span><br><span class="line"><span class="comment">    4.440892098500626E-16</span></span><br><span class="line"><span class="comment">    差值在默认范围内，可以认为相等！！！</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure></li><li><p>字符类型</p><p>字符型可以表示单个字符，字符类型是char，两个字节（可以存放汉字），多个字符我们用字符串String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;韩&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c4 = <span class="number">97</span>;<span class="comment">//当输出c4时，会输出97表示的字符</span></span><br></pre></td></tr></table></figure><ul><li><p>字符类型使用细节</p><ol><li>字符常量是用单引号（‘’）括起来的单个字符</li><li>Java中还允许使用转义字符‘ \ ‘来将其后的字符转变为特殊字符型常量</li><li>在Java中，char的本质是一个整数，在输出时，是unicode码对应的字符</li><li>可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</li><li>char类型是可以进行运算的，相当于一个整数，因为它都对应有unicode码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> char1 = <span class="string">&#x27;b&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)char1);<span class="comment">//99</span></span><br><span class="line">        System.out.println(char1);<span class="comment">//c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符类型本质探讨</p><p>字符型存储到计算机中，需要将字符对应的码值（整数）找出来，比如‘a’</p><p>存储：‘a’——&gt;码值97——&gt;二进制——&gt;存储</p><p>读取：二进制——&gt;97——&gt;’a’——&gt;显示</p><p>字符和码值的对应关系是通过字符编码集决定的</p></li><li><p>介绍一下字符编码集</p><p>ASCII编码集（一个字节表示，一共128个字符，实际上一个字符可以表示256个字符，只用128个）</p><ul><li>ASCII码：上世纪60年代，美国制定了一套字符编码（是用一个字节），对英语字符与二进制之间的关系做了统一规范，这被称为ASCII码，ASCII码一共规定了128个字符的编码，只占用了一个字节的后面7位，最前面的1位统一规定为0</li><li>缺点：不能表示所有字符</li></ul><p>unicode（固定大小的编码，使用两个字节来表示字符，字母和汉字统一占用两个字节，这样浪费空间）</p><p>utf-8（编码表，大小可变的编码，字母是用一个字节，汉字是用三个字节）</p><p>gbk（可以表示汉字，而且范围广，字母是用一个字节，汉字两个字节）</p><p>gb2312（可以表示汉字，gb2312&lt;gbk）</p><p>big5码（繁体中文，台湾，香港）</p></li></ul></li><li><p>布尔类型：boolean</p><ol><li><p>布尔类型也叫boolean类型，boolean类型只允许取值true和false，无null</p></li><li><p>boolean类型占一个字节</p></li><li><p>boolean类型适于逻辑运算，一般用于程序流程控制：</p><p>if条件控制语句；</p><p>while循环控制语句；</p><p>do-while循环控制语句；</p><p>for循环控制语句</p></li></ol><ul><li><p>使用细节说明</p><p>不可以用0或非0的整数替代false和true，这点和C语言不同</p></li></ul></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li><p>自动类型转换</p><p>当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这就是自动类型转换</p><p>数据类型按精度（容量）大小排序为（背，规则）：</p><p>byte——&gt;short——&gt;int——&gt;long——&gt;float——&gt;double</p><p>char——&gt;int——&gt;long——&gt;float——&gt;double</p></li><li><p>自动类型转换注意和细节</p><ol><li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行运算</p></li><li><p>当我们把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换</p></li><li><p>（byte、short）和char之间不会相互自动转换</p></li><li><p>byte、short、char他们三者可以计算，在计算时首先转换为int类型</p></li><li><p>boolean不参与运算</p></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当把具体数赋给byte时，先判断该数是否在byte范围内，如果是就可以</span></span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">10</span>;</span><br><span class="line">======================</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//错，b2 + s1 =&gt; int</span></span><br><span class="line"><span class="keyword">short</span> = b2 + s1;</span><br><span class="line">======================</span><br><span class="line"><span class="keyword">byte</span> b3 = <span class="number">2</span>; </span><br><span class="line"><span class="comment">//错，b2 + b3 =&gt; int</span></span><br><span class="line"><span class="keyword">byte</span> b4 = b2 + b3;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>强制类型转换</p><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符（），但可能造成精度降低或溢出，格外要注意。</p></li><li><p>强制类型转换细节说明</p><ol><li><p>当进行数据的大小    从大——&gt;小，就需要使用强制转换</p></li><li><p>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int x = (int)10*3.5+6*1.5;</span></span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>)(<span class="number">10</span>*<span class="number">3.5</span>+<span class="number">6</span>*<span class="number">1.5</span>);</span><br><span class="line">System.out.println(y);</span><br></pre></td></tr></table></figure></li><li><p>char类型可以保存int的常量值，但不能保存int的变量值，需要强转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = m;<span class="comment">//错</span></span><br><span class="line"><span class="keyword">char</span> c3 = (<span class="keyword">int</span>)m;</span><br><span class="line">System.out.println(c3);<span class="comment">//100对应的字符</span></span><br></pre></td></tr></table></figure></li><li><p>byte和short类型在进行运算时，当做int类型处理</p></li></ol></li><li><p>基本数据类型和String类型的转换</p><ul><li><p>介绍</p><p>在程序开发中，我们经常需要将基本数据类型转成String类型，或者将String类型转成基本数据类型</p></li><li><p>基本类型转String类型</p><p>语法：将基本类型的值+“”即可</p></li><li><p>String类型转基本数据类型</p><p>语法：通过基本数据类型的包装类用parseXX方法即可</p></li></ul></li><li><p>注意事项</p><ul><li>在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如我们可以把“123”，转成一个整数，但是不能把“hello”转成一个整数</li><li>如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理</li></ul></li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符是对数值类型的变量进行运算的，在Java程序中使用的非常多</p><img src="..\Java基础查漏补缺\算术运算符.png"/><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//讲解以下除号/和取模%和自增++</span></span><br><span class="line">System.out.println(<span class="number">10</span>/<span class="number">4</span>);<span class="comment">//2</span></span><br><span class="line">System.out.println(<span class="number">10.0</span>/<span class="number">4</span>);<span class="comment">//2.5</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10</span> / <span class="number">4</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取模的本质：a%b = a-a/b*b</span></span><br><span class="line"><span class="comment">//当a是小数时：a%b = a-(int)a/b*b;</span></span><br><span class="line"><span class="comment">//注意：有小数参与运算，得到的结果是近似值</span></span><br><span class="line">System.out.println(<span class="number">10</span>%<span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span>%<span class="number">3</span>);<span class="comment">//-1</span></span><br><span class="line">System.out.println(<span class="number">10</span>%-<span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span>%-<span class="number">3</span>);<span class="comment">//-1</span></span><br><span class="line">System.out.println(-<span class="number">10.5</span>%<span class="number">3</span>);<span class="comment">//-1.5    </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">作为独立的语句使用：</span></span><br><span class="line"><span class="comment">前++和后++完全等价于i=i+1</span></span><br><span class="line"><span class="comment">作为表达式使用</span></span><br><span class="line"><span class="comment">前++：++i先自增后赋值</span></span><br><span class="line"><span class="comment">后++：i++先赋值后自增</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、面试题1</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = i++;<span class="comment">//规则使用临时变量——&gt;1)temp = i 2)i = i+1 3)i = temp;</span></span><br><span class="line">System.out.println(i);<span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、面试题2</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = ++i;<span class="comment">//i=i+1;temp=i;i=temp;</span></span><br><span class="line">System.out.println(i);<span class="comment">//输出2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、题三</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">66</span>；</span><br><span class="line">System.out.println(++i+i);<span class="comment">//134</span></span><br></pre></td></tr></table></figure><h2 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h2><ul><li><p>介绍</p><ul><li><p>关系运算符的结果都是boolean型，也就是要么是true，要么是false</p></li><li><p>关系表达式经常用在if结构的条件中或循环结构的条件中</p><img src="..\Java基础查漏补缺\关系运算符.png"/></li></ul></li><li><p>细节说明</p><ul><li>关系运算符的结果都是boolean型，也就是要么是true，要么是false</li><li>关系运算符组成的表达式，我们称为关系表达式，如：a&gt;b</li><li>比较运算符“==”不能误写成“=”</li></ul></li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>用于连接多个条件（多个表达式），最终的结果也是一个boolean值</p><ul><li><p>逻辑运算符一览</p><ul><li><p>短路与&amp;&amp;，短路或||，取反！</p></li><li><p>逻辑与&amp;，逻辑或|，逻辑异或^</p><img src="..\Java基础查漏补缺\逻辑运算符.png"/><img src="..\Java基础查漏补缺\逻辑运算规则.png"/></li></ul></li><li><p>&amp;&amp;和&amp;使用区别</p><ul><li>&amp;&amp;短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高</li><li>&amp;逻辑与：不管第一个条件是否为false，第二个条件都会判断，效率低</li><li>开发中，我们使用的基本是短路与&amp;&amp;，效率高</li></ul></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul><li><p>介绍</p><p>赋值运算符就是将某个运算后的值，赋给指定的变量</p></li><li><p>赋值运算符的分类</p><ul><li><p>基本赋值运算符</p><p>=</p><p>int a = 1；</p></li><li><p>复合赋值运算符</p><p>+=    -=    /=    *=    %=等，重点讲解一个+=，其他的使用是一个道理</p><p>a += b;等价于a = a+b;</p></li></ul></li><li><p>案例演示</p><p>外皮巴普</p></li><li><p>赋值运算符特点</p><ul><li><p>运算顺序从右往左 int num = a+b+c；</p></li><li><p>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值</p></li><li><p>复合赋值运算符等价于下面的效果</p><p>a += 3;等价于a = a+3;</p></li><li><p>复合赋值运算符会进行类型转换</p><p>byte b = 2；b += 3；b++；</p><p>其中b += 3；没有问题，等价于b = (byte)(b+3)；</p><p>b++；等价于b = (byte)(b+1);</p></li></ul></li></ul><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ul><li><p>基本语法</p><p>条件表达式？表达式1：表达式2；</p><ol><li>如果条件表达式为true，运算后的结果是表达式1；</li><li>如果条件表达式为false，运算后的结果是表达式2</li></ol></li><li><p>案例演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> res = a&gt;b?a++:b--;</span><br><span class="line">System.out.println(res);<span class="comment">//99</span></span><br></pre></td></tr></table></figure></li><li><p>使用细节</p><ul><li>表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转型）</li><li>三元运算符可以转换成if–else语句</li></ul></li></ul><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ol><li><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优于下一行</p></li><li><p>只有单目运算符、赋值运算符是从右向左运算的</p><img src="..\Java基础查漏补缺\优先级.png"/><ul><li>（）, {}等</li><li>单目运算符 ++ –</li><li>算术运算符</li><li>位移运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>三元运算符</li><li>赋值运算符</li></ul></li></ol><h2 id="标识符的命名规则和规范"><a href="#标识符的命名规则和规范" class="headerlink" title="标识符的命名规则和规范"></a>标识符的命名规则和规范</h2><ul><li><p>标识符概念</p><ol><li>Java对各种变量、方法和类等命名时使用的字符序列称为标识符</li><li>凡是自己可以起名字的地方都叫标识符</li></ol></li><li><p>标识符的命名规则（必须遵守）</p><ol><li>由26个英文字母大小写，0-9，_或$组成</li><li>数字不可以开头</li><li>不可以使用关键字和保留字，但能包含关键字和保留字</li><li>Java中严格区分大小写，长度无限制</li><li>标识符不能包含空格</li></ol></li><li><p>标识符命名规范（更加专业）</p><ol><li><p>包名：多单词组成时，所有字母都小写</p></li><li><p>类名、接口名：多单词组成时，所有单词的首字母大写【大驼峰法】</p></li><li><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写【小驼峰法、驼峰法】</p></li><li><p>常量名：所有字母都大写。多单词时每个单词用下划线连接</p><img src="..\Java基础查漏补缺\关键字.png"/><img src="..\Java基础查漏补缺\关键字2.png"/><img src="..\Java基础查漏补缺\保留字.png"/></li></ol></li><li><p>键盘输入语句</p><ul><li><p>介绍</p><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取</p></li><li><p>步骤</p><ol><li>导入该类的所在包，java.util.*</li><li>创建该类对象（声明变量）</li><li>调用里面的功能</li></ol></li></ul></li></ul><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><img src="..\Java基础查漏补缺\进制介绍.png"/><ul><li>原码、反码、补码（重点 难点）<ol><li>二进制的最高位是符号位：0表示正数，1表示负数</li><li>正数的原码、反码、补码都一样（三码合一）</li><li>负数的反码 等价于  它的原码符号位不变，其他位取反</li><li>负数的补码  等价于  它的反码+1</li><li>0的反码、补码都是0</li><li>Java没有无符号数，换言之，Java中的数都是有符号的</li><li>在计算机运行时，都是以补码的方式来运算的</li><li>当我们看运算结果的时候，要看他的原码（重点）</li></ol></li></ul><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java中有7个位运算符（&amp;、|、^、~、&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;）</p><p>按位异或：两位一个为0，一个为1，结果为1，否则为0（不同为true，C语言中的非0）</p><p>计算题：2&amp;3、~-2、 ~2、2|3、2^3</p><p>整型2:</p><p>原补反：00000000 00000000 00000000 00000010</p><p>整型3：</p><p>原补反：00000000 00000000 00000000 00000011</p><p>2&amp;3：</p><p>00000000 00000000 00000000 00000010（2）</p><p>2|3：</p><p>00000000 00000000 00000000 00000011（3）</p><p>2^3：</p><p>00000000 00000000 00000000 00000001（1）</p><p>整型-2：</p><p>原码：10000000 00000000 00000000 00000010</p><p>反码：11111111 11111111 11111111 11111101</p><p>补码：11111111 11111111 11111111 11111110</p><p>运算：00000000 00000000 00000000 00000001</p><p>原补反合一，故    ~-2 == 1</p><p>2：</p><p>原补反：00000000 00000000 00000000 0010</p><p>​    取反：11111111 11111111 11111111 1101</p><p>结果补码：11111111 11111111 11111111 1101</p><p>结果反码：11111111 11111111 11111111 1100</p><p>结果原码：10000000 00000000 00000000 0011（-3）</p><p>故（~2）== -3</p><ul><li>还有三个位运算符&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;，运算规则：<ol><li>算术右移&gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位</li><li>算术左移&lt;&lt;：符号位不变，低位补0</li><li>逻辑右移&gt;&gt;&gt;：也叫无符号右移，运算规则是：低位溢出，高位补0</li><li>特别说明：没有&lt;&lt;&lt;符号</li></ol></li></ul><h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><p>在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程</p><ol><li>顺序控制</li><li>分支控制</li><li>循环控制</li></ol><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>程序从上到下逐行地执行，中间没有任何判断和跳转</p><h2 id="分支（if-else-switch）"><a href="#分支（if-else-switch）" class="headerlink" title="分支（if else switch）"></a>分支（if else switch）</h2><ul><li><p>分支控制if-else介绍</p><p>让程序有选择的执行，分支控制有三种</p><ol><li>单分支</li><li>双分支</li><li>多分支</li></ol></li><li><p>单分支</p><p>基本语法</p><p>if(条件表达式){</p><p>​        执行代码块；（可以有多条语句）</p><p>}</p><p>说明：当条件表达式为true时，就会执行{}的代码块，如果为false，就不执行，特别说明，如果{}中只有一条语句，则可以不用{}，建议写上{}</p></li><li><p>双分支</p><p>基本语法</p><p>if（条件表达式）{</p><p>​    执行代码块1；</p><p>}else{</p><p>​    执行代码块2；</p><p>}</p><p>说明：当条件表达式成立，即执行代码块1，否则执行代码块2，如果执行代码块只有一条语句，则{}可以省略，否则，不能省略</p></li><li><p>多分支</p><p>基本语法</p><p>if（条件表达式1）{</p><p>​    执行代码块1；</p><p>}else if{</p><p>​    执行代码块2；</p><p>}</p><p>…………</p><p>else{</p><p>​    执行代码块n；</p><p>}</p><ul><li><p>嵌套分支</p><ul><li><p>基本介绍</p><p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支，外面的分支结构称为外层分支。规范：不要超过3层（可读性不好）</p></li><li><p>基本语法</p><p>if(){</p><p>​    if(){</p><p>​    }else{</p><p>​    }</p><p>}</p></li></ul></li></ul><p>示意图：</p><img src="..\Java基础查漏补缺\多分支.png"/></li><li><p>switch分支结构</p><ul><li><p>基本语法</p><p>switch（表达式）{</p><p>​    case 常量1：</p><p>​        语句块1；</p><p>​        break；</p><p>​    case 常量2：</p><p>​        语句块2；</p><p>​        break；    </p><p>​    ………………</p><p>​    default:</p><p>​        default语句块；</p><p>​        break；</p><p>}</p></li></ul><ol><li>switch关键字，表示switch分支</li><li>表达式对应一个值</li><li>case 常量1：当表达式的值等于常量1，就执行语句块1</li><li>break：表示退出switch</li><li>如果和case常量1匹配。就执行语句块1，如果没有匹配，就继续匹配case常量2</li><li>如果一个都没有匹配上，执行default</li></ol><img src="..\Java基础查漏补缺\switch.png"/></li><li><p>switch注意事项和使用细节</p><ol><li>表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是int</li><li>switch（表达式）中表达式的返回值必须是：（byte、short、int、char、enum、String）</li><li>case子句中的值必须是常量，而不能是变量</li><li>default子句是可选的，当没有匹配的case时，执行default</li><li>break语句用来执行完一个case分支后，使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾</li></ol></li><li><p>switch和if的比较</p><ol><li>如果判断的具体数值不多，而且符合byte、short、int、char、enum、String这6这类型。虽然两个语句都可以使用，建议使用switch</li><li>其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更加广</li></ol></li></ul><h2 id="循环（for，while，do-while）"><a href="#循环（for，while，do-while）" class="headerlink" title="循环（for，while，do while）"></a>循环（for，while，do while）</h2><ul><li><p>for循环控制</p><p>基本介绍：听其名而知其意，就是让你的代码可以循环的执行</p><p>基本语法：</p><p>for（循环变量初始化；循环条件；循环变量迭代）{</p><p>​    循环操作（语句）；</p><p>}</p><p>说明：</p><ol><li>for关键字，表示循环控制</li><li>for有四要素：1）循环变量初始化2）循环条件3）循环操作4）循环变量迭代</li><li>循环操作，这里可以有多条语句，也就是我们要循环执行的代码</li><li>如果循环操作（语句）只有一句语句，可以省略{}，建议不要省略</li></ol><p>注意事项和细节说明：</p><ol><li>循环条件是返回一个布尔值的表达式</li><li>for（；循环判断条件；）中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略</li><li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for的死循环写法</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while循环控制</p><p>循环变量初始化；</p><p>while（循环条件）{</p><p>​    循环体（语句）；</p><p>​    循环变量迭代；</p><p>}</p><p>说明：</p><ol><li>while循环也有四个要素</li><li>只是四要素放的位置不一样</li></ol></li><li><p>do……while循环控制</p><p>循环变量初始化；</p><p>do{</p><p>​    循环体（语句）；</p><p>​    循环变量迭代；</p><p>}while（循环条件）；</p><p>说明：</p><ol><li>do while是关键字</li><li>也有循环四要素。只是位置不一样</li><li>最后有一个分号</li><li>while和do……while区别，举例：要账</li></ol></li></ul><h2 id="跳转控制语句-break"><a href="#跳转控制语句-break" class="headerlink" title="跳转控制语句-break"></a>跳转控制语句-break</h2><ul><li><p>基本介绍</p><p>break语句用于终止某个语句块的执行，一般使用在switch或者循环【for、while、do-while】中</p></li><li><p>基本语法</p><p>{</p><p>​    ……</p><p>​    break；</p><p>​    ……</p><p>}</p></li><li><p>注意事项和使用细节</p><ol><li><p>break语句出现在多次嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</p></li><li><p>标签的基本使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    label2:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> label1;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>break语句可以指定退出哪层</li><li>label1是标签，由程序员指定</li><li>break后指定哪个label就退出哪里</li><li>在实际的开发中，尽量不要使用标签</li><li>如果没有指定break，默认推出最近的循环体</li></ul></li></ol></li></ul><h2 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句-continue"></a>跳转控制语句-continue</h2><ul><li><p>基本介绍</p><ol><li>continue语句用于结束本次循环，继续执行下一次循环</li><li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的使用规则一样</li></ol></li><li><p>基本语法：</p><p>{</p><p>​    ……</p><p>​    continue;</p><p>​    ……</p><p>}</p><img src="..\Java基础查漏补缺\continue例题.png"/></li></ul><h2 id="跳转控制语句-return"><a href="#跳转控制语句-return" class="headerlink" title="跳转控制语句-return"></a>跳转控制语句-return</h2><p>return使用在方法里，表示跳出所在的方法，在讲解方法的时候，会详细讲解</p><p>注意：return写在main方法里，退出程序</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h2><p>数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用数据类型，即数组就是一组数据</p><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><ul><li><p>使用方式1-动态初始化</p><ol><li><p>数组的定义</p><p>数据类型    数组名【】 = new    数据类型【大小】</p><p>int    a[]    =    new    int[5]；//创建了一个数组，名字a，存放了5个int类型的数据</p></li><li><p>数组的引用（使用）</p><p>数组名【下标/索引】</p></li><li><p>快速入门</p><p>外皮巴普</p></li></ol></li><li><p>使用方式2-动态初始化</p><ol><li><p>先声明数组</p><p>语法：数组类型    数组名【】；也可以    数组类型【】 数组名；</p></li><li><p>创建数组</p><p>语法：数组名    =    new    数组类型【大小】；</p></li></ol></li><li><p>使用方式3-静态初始化</p><img src="..\Java基础查漏补缺\数组静态初始化.png"/></li><li><p>数组使用注意事项和使用细节</p><img src="..\Java基础查漏补缺\数组使用细节.png"/></li><li><p>数组的赋值机制</p><ol><li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</li><li>数组在默认情况下是引用传递，赋的是地址</li></ol></li></ul><p><a href="https://www.jianshu.com/p/4c80a972aedb">图解Java数组的内存分配 - 简书 (jianshu.com)</a></p><h2 id="数组的拷贝、反转、扩容、缩减"><a href="#数组的拷贝、反转、扩容、缩减" class="headerlink" title="数组的拷贝、反转、扩容、缩减"></a>数组的拷贝、反转、扩容、缩减</h2><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul><li><p>使用方式1：动态初始化</p><ol><li>语法：类型【】【】    数组名 = new 类型【大小】【大小】；</li><li>二维数组在内存中的存在形式</li></ol></li><li><p>使用方式2：动态初始化</p><p>先声明再定义赋值</p></li></ul><img src="..\Java基础查漏补缺\二维数组的内存分析.png"/><ul><li><p>使用方式3：动态初始化-列数不确定</p><p>二维数组即“数组数组”，一个存放数组的数组，当列数不确定时，数组也是对象嘛，里面的数组默认为null，抛开列数的概念，里面存放的数组的长度是可以不同的</p></li><li><p>使用方式4：静态初始化</p><p>直接对二维数组赋值即可</p></li><li><p>二维数组的使用细节和注意事项</p><img src="..\Java基础查漏补缺\二维数组的使用细节.png"/></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>一个程序就是一个世界，有很多事物</p><ol><li>类就是数据类型，比如Cat</li><li>对象就是一个具体的实例</li></ol><ul><li><p>对象在内存中的存在形式（重要的）</p><img src="..\Java基础查漏补缺\对象在内存中的形式.png"/></li><li><p>属性/成员变量</p><ul><li><p>基本介绍</p><ol><li>从概念或叫法上看：成员变量 = 属性 = field</li><li>属性是类的一个组成部分，一般是基本数据类型，也可以是引用数据类型（对象，数组）。</li></ol></li><li><p>注意事项和细节说明</p><ol><li>属性的定义语法同变量，示例：访问修饰符    属性类型    属性名；</li><li>属性的定义类型可以为任意类型，包含基本类型或引用类型</li><li>属性如果不赋值，有默认值，规则和数组一致。具体而言：byte 0，short 0，int 0，long 0，float 0.0，double 0.0，boolean false，char \u0000，String null</li></ol></li></ul></li><li><p>如何创建对象</p><ol><li><p>先声明再创建</p><p>Cat cat；</p><p>cat = new Cat（）；</p></li><li><p>直接创建</p><p>Cat cat = new Cat();</p></li></ol></li><li><p>如何访问属性</p><p>基本语法：对象名.属性名；</p></li><li><p>类与对象的分配机制（重要）</p><ul><li><p>Java内存的结构分析</p><ol><li><p>栈：一般存放基本数据类型（局部变量）</p></li><li><p>堆：存放对象（Cat cat，数组等）</p></li><li><p>方法区：常量池（常量，比如字符串），类加载信息</p></li><li><p>示意图</p><img src="..\Java基础查漏补缺\对象的内存分析.png"/></li></ol></li><li><p>Java创建对象的简单流程分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先加载Person类信息（属性和方法信息，只加载一次）</li><li>在堆中分配空间，进行默认初始化（看规则）、显式初始化、构造器初始化</li><li>把地址赋给person，person指向对象</li><li>进行指定初始化，比如p.name = “Jack” p.age = 10</li></ol></li></ul></li></ul><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p>基本介绍</p><p>在某些情况下，我们定义成员方法（简称方法）。比如人类：除了一些属性外，我们人类还有一些行为：可以说话，跑步等</p></li><li><p>成员方法快速入门</p><p>在Person类中添加方法</p></li><li><p>方法调用机制原理【重要】</p><img src="..\Java基础查漏补缺\方法的调用机制.png"/><ol><li>当程序执行到方法时，就会开辟一个独立的栈空间，执行方法</li><li>当方法执行结束或者遇到return时，就会返回</li><li>返回到调用方法的地方</li><li>返回后，继续执行方法后面的代码</li><li>当main方法（栈）执行完毕后，整个程序也就结束</li></ol></li><li><p>为什么需要成员方法（好处）</p><ol><li>提高代码的复用性</li><li>可以将实现的细节封装起来，然后供其他用户来调用即可。</li></ol></li><li><p>成员方法的定义</p><ol><li>形参列表：表示成员方法输入</li><li>数据类型（返回类型）：表示成员方法输出，void表示没有返回值</li><li>方法主体：表示为了实现某一功能代码块</li><li>return语句不是必须的</li></ol></li><li><p>注意事项和使用细节</p><ol><li><p>修饰符（作用是控制方法使用的范围）</p></li><li><p>返回类型</p><ul><li>一个方法最多有一个返回值</li><li>返回类型可以为任意类型，包含基本类型或引用类型（数组、对象）</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return值；而且要求返回类型必须和return的值类型一致或兼容</li><li>如果方法是void，则方法体中可以没有return语句，或者只写return；</li></ul></li><li><p>方法名</p><p>遵循驼峰命名法，最好见名知义，表达出该功能的意思即可</p></li><li><p>参数列表</p><ul><li>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开</li><li>参数类型可以为任意类型，包含基本类型或引出类型</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li><li>方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致</li></ul></li><li><p>方法体</p><p>里面写完成功能的具体语句，可以为输出、输入、变量、运算、分支、循环、方法调用，但是不能再定义方法！即方法不能嵌套定义。</p></li><li><p>方法调用细节说明</p><ul><li>同一个类中的方法调用：直接调用即可</li><li>跨类中的方法调用：需要通过对象名调用</li></ul></li></ol></li></ul><h3 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h3><p>方法的传参机制对我们今后的编程非常重要，一定要搞的清清楚楚</p><ul><li><p>基本数据类型的传参机制</p><img src="..\Java基础查漏补缺\传参有效范围测试.png"/><p>结论：基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！</p></li><li><p>引用数据类型的传参机制</p><img src="..\Java基础查漏补缺\方法形参传递.png"/><p>结论：引用数据类型传递的是地址（传递的也是值，但是值是地址），可以通过形参影响实参！</p></li></ul><h3 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h3><ul><li><p>基本介绍</p><p>Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致</p></li><li><p>重载的好处</p><ol><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ol></li><li><p>注意事项和使用细节</p><ol><li>方法名：必须相同</li><li>参数列表：必须不同（参数类型或个数顺序，至少有一样不同，参数名无要求）</li><li>返回类型：无要求</li></ol></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li><p>基本概念</p><p>Java允许将同一个类中的多个同名功能但参数个数不同的方法封装成一个方法</p></li><li><p>基本语法</p><p>访问修饰符    返回值    方法名（数据类型**…**    形参名）{</p><p>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVariablePar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VariablePar variablePar = <span class="keyword">new</span> VariablePar();</span><br><span class="line">        <span class="keyword">int</span> res = variablePar.sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariablePar</span></span>&#123;</span><br><span class="line">    <span class="comment">//int... 表示接收的是可变参数，类型是int，即可以接受多个int（0~n）</span></span><br><span class="line">    <span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以当作数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项和使用细节</p><ol><li>可变参数的实参可以为0个或任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ol></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li><p>基本使用</p><p>面向对象中，变量作用域是非常重要的知识点</p><ol><li><p>在Java编程中，主要的变量就是属性（成员变量）和局部变量。</p></li><li><p>我们说的局部变量一般是指成员方法中定义的变量</p></li><li><p>Java中作用域的分类</p><p>全局变量：也就是属性，作用域为整个类体</p><p>局部变量：也就是除了属性之外的其他变量，作用域为定义他的代码块中！</p></li><li><p>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</p></li></ol></li><li><p>注意事项和细节使用</p><ol><li><p>属性和局部变量可以重名，访问时遵循就近原则</p></li><li><p>在同一个作用域中，比如在同一个成员方法中，两个局部变量不能重名</p></li><li><p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的消亡而消亡，局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。</p></li><li><p>作用域范围不同</p><p>全局变量/属性：可以被本类使用，或其它类使用（通过对象调用）</p><p>局部变量：只能在本类中对应的方法中使用</p></li><li><p>修饰符不同</p><p>全局变量/属性可以加修饰符</p><p>局部变量不可以加修饰符</p></li></ol></li></ul><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul><li><p>引入</p><p>我们来看一个需求：在创建人类对象时，就直接指定这个对象的年龄和姓名，该怎么做？这时就可以使用构造器</p></li><li><p>基本介绍</p><p>构造方法又叫构造器（Constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的初始化，它有几个特点：</p><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li></ol></li><li><p>基本语法</p><p>【修饰符】    方法名（形参列表）{</p><p>​            方法体；</p><p>}</p><p>说明：</p><ol><li>构造器的修饰符可以默认</li><li>构造器没有返回值</li><li>方法名和类名必须一样</li><li>参数列表和成员方法一样的原则</li><li>构造器的调用系统完成</li></ol></li><li><p>注意事项和使用细节</p><ol><li>一个类可以定义多个不同的构造器，即构造器重载</li><li>构造器名和类名相同</li><li>构造器没有返回值</li><li>构造器是完成对象的初始化，并不是创建对象</li><li>在创建对象时，系统自动的调用该类的构造方法</li><li>如果程序员没有定义构造器方法，系统会自动给类生成一个默认无参构造方法（也叫默认构造方法），使用javap指令反编译看看</li><li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式地定义一下</li></ol></li><li><p>对象创建的流程分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析：</p><p>一个堆、栈、方法区、常量池的模型</p><p>先在方法区加载Person.class的相关信息，只会加载一次</p><p>new的时候在堆中开辟一块空间（地址），创建对象</p><p>对属性和方法进行默认初始化    ——&gt;    name = null；age = 0</p><p>然后再类里属性的信息进行显式的初始化    ——&gt;    name = null；age = 90</p><p>根据构造器进行初始化    ——&gt;    name = “小明”；age = 12</p><p>将对象在堆中的地址返回给person（栈中的对象名指向对象）</p></li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul><li><p>什么是this</p><p>Java虚拟机会给每个对象分配this，代表当前对象</p><p>简单地说，哪个对象调用，this就代表哪个对象</p></li><li><p>this的使用</p><p>使用this可以解决构造器中局部变量的问题</p></li><li><p>this的注意事项和使用细节</p><ol><li>this关键字可以用来访问本类的属性、构造器和方法</li><li>this关键字用来区分当前类的属性和局部变量</li><li>访问成员方法的语法：this.方法名（参数列表）</li><li>访问构造器语法：this（参数列表）；注意只能在构造器中使用（只能在一个构造器中调用另一个构造器）</li><li>this不能再类定义的外部使用，只能在类定义的方法中使用</li></ol></li></ul><p>tips：</p><ul><li>recursive：adj.递归的</li><li>invovation：n.调用</li></ul><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><ul><li>IDEA快捷键<ol><li>ctrl+d：删除当前行</li><li>ctrl+alt+向下的光标：复制当前行</li><li>alt+/：补全代码</li><li>ctrl+/：添加注释和取消注释</li><li>导入该行需要的类： 先配置auto import，然后使用alt+enter即可</li><li>ctrl+shift+L：快速格式化代码</li><li>alt+insert：生成构造方法等</li><li>ctrl+H：查看一个类的层级关系</li><li>ctrl+J：显示所有快捷键</li><li>ctrl+B：将光标放在一个方法上，输入ctrl+B，可以选择定位到哪个类的方法</li><li>.var：自动的分配变量名，通过在后面.var</li><li>ctrl+Alt+t：包裹代码</li><li>itit：快速建立迭代器</li></ol></li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li><p>场景引入</p><p>现有两个程序员，小明和小强，共同开发一个Java项目，两人都想定义一个名为Dog的类，两人为此还吵了起来，怎么办呢？</p><p>=+=+=+=+====&gt;包</p></li><li><p>包的三大作用</p><ul><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类【看Java API文档】</li><li>控制访问范围</li></ul></li><li><p>包的基本语法</p><p>package com.hspedu;</p><ul><li>pcakage：关键字，表示打包</li><li>com.hspedu：表示包名</li></ul></li><li><p>包的本质分析（原理）</p><p>包的本质：实际上就是创建不同的文件夹来保存类文件</p></li><li><p>快速入门</p><p>使用打包技术来解决上面的问题，不同包下Dog类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pcakage com.xiaoming;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaoqiang.Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        com.xiaoming.Dog dog1 = <span class="keyword">new</span> com.xiaoming.Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包的命名</p><ul><li><p>命名规则</p><p>只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</p></li><li><p>命名规范</p><p>一般是小写字母+小圆点</p><p>com.公司名.项目名.业务模块名</p><p>比如：</p><p>com.sina.crm.user    //用户模块</p><p>com.sina.crm.order    //订单名</p><p>com.sina.crm.utils    //工具类</p></li></ul></li><li><p>常用的包</p><p>一个包下，包含很多的类。Java中常用的包有：</p><p>java.lang.*    //lang包是基本包，默认引入，不需要再引入</p><p>java.util.*    //util包，系统提供的工具包，工具类，Scanner</p><p>java.net.*    //网络包，网络开发</p><p>java.awt.*    //是做Java的界面开发，GUI</p></li><li><p>如何引入包</p><p>语法：import 包；</p><p>我们引入一个包的主要目的是要使用该包下的类</p><p>比如：import java.util.Scanner;    就是引入一个类Scanner</p><p>​            import java.util.*;        表示将java.util所有包都引入</p><p>案例：使用系统提供的Arrays完成数组排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">123</span>,<span class="number">33</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项和使用细节</p><ul><li>package的作用是声明当前类所在的包，需要放在class的最上面，一个类中最多只有一句package</li><li>import指令位置放在package下面，在类定义前面，可以有多句且没有顺序要求。</li></ul></li></ul><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul><li><p>基本介绍</p><p>Java提供四种访问控制修饰符号来控制方法和属性（成员变量）的访问权限（范围）：</p><ol><li>公开级别：用public修饰，对外公开</li><li>受保护级别：用protected修饰，对子类和同一包中的类公开</li><li>默认级别：没有修饰符号，向同一个包的类公开</li><li>私有级别：用private修饰，只有类本身可以访问</li></ol></li><li><p>4种访问修饰符的访问范围</p><table><thead><tr><th align="center">访问级别</th><th align="center">访问控制修饰符</th><th align="center">同类</th><th align="center">同包</th><th align="center">子类</th><th align="center">不同包</th></tr></thead><tbody><tr><td align="center">公开</td><td align="center">public</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">受保护</td><td align="center">protected</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">默认</td><td align="center">没有修饰符</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="center">私有</td><td align="center">private</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr></tbody></table></li><li><p>使用的注意事项</p><ol><li>修饰符可以用来修饰类中的属性，成员方法以及类</li><li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li><li>继承相关</li><li>成员方法的访问规则和属性完全一样</li></ol></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>封装介绍</p><p>封装（encapsulation）就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作。</p><p>对电视机的操作就是典型封装，输入一个参数返回一个结果</p></li><li><p>封装的理解和好处</p><ol><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol></li><li><p>封装的步骤</p><ol><li>将属性进行私有化private【不能直接修改属性】</li><li>提供一个公共的（public）Set方法，用于对属性判断并赋值</li><li>提供一个公共的（public）Get方法，用于获取属性的值</li><li>构造器+Set方法 做预处理</li></ol></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>为什么需要继承？</p><p>代码复用</p></li><li><p>继承基本介绍和示意图</p><p>继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</p><img src="..\Java基础查漏补缺\继承.png"/></li><li><p>继承的基本语法</p><p>class 子类 extends 父类{</p><p>}</p><ol><li>子类会自动拥有父类定义的属性和方法</li><li>父类又称超类、基类</li><li>子类又叫派生类</li></ol></li><li><p>继承给编程带来的便利</p><ol><li>代码的复用性提高了</li><li>代码的扩展性和维护性提高了</li></ol></li><li><p>继承的深入讨论/细节问题</p><ol><li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问</p></li><li><p>子类必须调用父类的构造器，完成父类的初始化</p></li><li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super()去指定使用父类的哪个构造器完成对父类的初始化，否则编译不会通过。</p></li><li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)</p></li><li><p>super只能在构造器中使用，且需要放在构造器的第一行</p></li><li><p>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p></li><li><p>Java所有类都是Object的子类，Object是所有类的基类</p><p><strong>CTRL+h：可以看到类的继承关系</strong></p></li><li><p>父类构造器的调用不限于直接父类！可以一直往上追溯到Object类（顶级父类）</p></li><li><p>子类最多只能继承一个父类（指直接继承），即Java中是单继承机制</p></li><li><p>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p></li></ol></li><li><p>继承的本质分析（重要）</p><p>案例：当子类继承父类，创建子类对象时，内存中到底发生了什么？提示：当子类对象建造好后，建立查找关系</p></li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li><p>基本介绍</p><p>super代表父类的引用，用于访问父类的属性、方法、构造器</p></li><li><p>基本语法</p><ol><li><p>访问父类的属性，但不能访问父类的private属性</p><p>super.属性名；</p></li><li><p>访问父类的方法，不能访问父类的private方法</p><p>super.方法名（参数列表）；</p></li><li><p>访问父类的构造器：</p><p>super（参数列表）；只能放在构造器的第一句，只能出现一句！</p></li></ol></li><li><p>super给编程带来的便利/细节</p><ol><li>调用父类的构造器的好处（分工明确，父类属性有父类初始化，子类的属性由子类初始化）</li><li>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！</li><li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。A&gt;B&gt;C</li></ol></li><li><p>super和this的比较</p><table><thead><tr><th align="center">No.</th><th align="center">区别点</th><th align="center">this</th><th align="center">super</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">访问属性</td><td align="center">访问本类中的属性，如果本类没有此属性，则从父类中继续查找</td><td align="center">从父类中查找有无该属性</td></tr><tr><td align="center">2</td><td align="center">调用方法</td><td align="center">访问本类中的方法，如果本类没有此方法，则从父类中继续查找</td><td align="center">从父类中查找有无该方法</td></tr><tr><td align="center">3</td><td align="center">调用构造器</td><td align="center">调用本类构造器，必须放在构造器的首行</td><td align="center">调用父类构造器，必须放在子类构造器的首行</td></tr><tr><td align="center">4</td><td align="center">特殊</td><td align="center">表示当前对象</td><td align="center">子类中访问父类对象</td></tr></tbody></table><p>tips：</p><p>一个类是如何找调用的方法的：</p><ol><li><p>先找本类，如果有，则直接调用</p></li><li><p>如果没有则找父类（如果有，并可以调用，则调用）</p></li><li><p>如果父类没有，则继续找父类的父类，整个规则，就是一样的，直到Object类</p></li><li><p>如果查找方法的过程中，找到了，但不能访问，则报错，cannot access</p></li><li><p>如果最终没有找到，则提示方法不存在</p></li><li><p>cal（）== this.cal（）</p></li><li><p>super.cal()：直接从父类开始找</p><img src="..\Java基础查漏补缺\继承的内存布局.png"/></li></ol></li></ul><h3 id="override（覆盖）"><a href="#override（覆盖）" class="headerlink" title="override（覆盖）"></a>override（覆盖）</h3><ul><li><p>基本介绍</p><p>简单的说：方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法</p></li><li><p>注意事项和使用细节</p><p>方法重写也叫方法覆盖，需要满足下面的条件</p><ol><li>子类的方法的参数、方法名称，要和父类方法的参数、方法名称完全一样</li><li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回类型是Object，子类方法返回类型是String</li><li>子类方法不能缩小父类方法的访问权限</li></ol></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>多态基本介绍</p><p>方法或者对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的</p></li><li><p>多态的具体体现</p><ol><li><p>方法的多态</p><p>重载和覆盖就体现多态</p></li><li><p>对象的多态（核心、困难、重点）</p><ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时，就确定了，不能改变</li><li>运行类型是可以变化的</li><li>编译类型看定义时 = 号的左边，运行类型看 = 号的右边</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();<span class="comment">//animal编译类型是Animal，运行类型Dog</span></span><br><span class="line">animal = <span class="keyword">new</span> Cat();<span class="comment">//animal的运行类型变成了Cat，但编译类型仍然是Animal</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>多态注意事项和细节讨论</p><p>多态的前提：两个对象（类）存在继承关系</p><p>多态的向上转型</p><ol><li><p>本质：父类的引用指向了子类的对象</p></li><li><p>语法：父类类型   引用名 =  new     子类类型（）；</p></li><li><p>特点：编译类型看左边，运行类型看右边</p><p>可以调用父类中的所有成员（需遵守访问权限）</p><p>不能调用子类中特有成员</p><p>最终效果看子类的具体实现！</p></li></ol><p>多态的向下转型</p><ol><li>语法：子类类型    引用名    =    （子类类型）父类引用；</li><li>只能强转父类的引用，不能强转父类的对象</li><li>要求父类的引用必须指向的是当前目标类型的对象</li><li>可以调用子类类型中所有的成员</li></ol><p>属性的值看编译类型</p><p>instanceof比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</p></li><li><p><strong>Java的动态绑定机制（非常非常重要）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="comment">//问：</span></span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(a.sum());<span class="comment">//?——&gt;40</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//?——&gt;30</span></span><br><span class="line"><span class="comment">//问：B类中的方法sum()注销后</span></span><br><span class="line"><span class="comment">//a.sum()调用到父类A的方法sum(),此时在A中有方法getI(),该方法指向哪儿呢？</span></span><br><span class="line"><span class="comment">//引出动态绑定机制：</span></span><br><span class="line"><span class="comment">//1.当调用对象方法的时候，该方法会和对象的内存地址/运行类型绑定</span></span><br><span class="line"><span class="comment">//2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</span></span><br><span class="line"><span class="comment">//getI（）指向运行类型，也就是B类的方法</span></span><br><span class="line"><span class="comment">//则有结果</span></span><br><span class="line">System.out.println(a.sum());<span class="comment">//?——&gt;20+10=30</span></span><br><span class="line"><span class="comment">//问：而注销B类中的sum1（）后</span></span><br><span class="line"><span class="comment">//属性的调用没有动态绑定机制，则有结果</span></span><br><span class="line">System.out.println(a.sum1());<span class="comment">//?——&gt;10+10=20</span></span><br></pre></td></tr></table></figure></li><li><p>多态的应用</p><ol><li><p>多态数组</p><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p></li><li><p>多态参数</p><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p></li></ol></li></ul><h3 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h3><ul><li><p>equals方法</p><ol><li><p>==：既可以判断基本类型，又可以判断引用类型</p></li><li><p>==：如果判断基本类型，判断的是值是否相等</p></li><li><p>==：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象</p></li><li><p>equals：是Objects类中的方法，只能判断引用类型</p></li><li><p>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，比如：Integer、String</p><img src="..\Java基础查漏补缺\question1.png"/></li></ol></li><li><p>hashCode方法</p><ol><li>提高具有哈希结构的容器效率</li><li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li><li>两个引用，如果指向的是不同的对象，则哈希值是不一样的</li><li>哈希值主要根据地址号来的，不能完全将哈希值等价于地址</li><li>后面在集合中的hashCode（）如果需要的话，也会重写</li></ol></li><li><p>toString方法</p><ul><li><p>基本介绍：</p><p>默认返回：全类名+@+哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息</p></li><li><p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</p></li><li><p>当直接输出一个对象时，toString方法会被默认的调用</p></li></ul></li><li><p>finalize方法</p><ul><li><p>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一些释放资源的操作</p></li><li><p>什么时候被回收：当某个对象没有任何引用时，贼JVM就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法</p></li><li><p>垃圾回收机制的调用是由系统决定的，也可以通过System.gc()主动触发垃圾回收机制</p></li><li><p>老韩提示：我们在实际开发中几乎不会运用finalize方法，为了应付面试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalize_</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;程序结束。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;回收就车辆。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="断点调试（debug）"><a href="#断点调试（debug）" class="headerlink" title="断点调试（debug）"></a>断点调试（debug）</h3><ul><li><p>一个实际需求</p><ol><li>在开发中，新手程序员在查找错误时，老程序员会温馨提示，可以用断电调试，一步步看源码执行过程，从而发现错误所在。</li><li>重要提示：在断点调试过程中，是运行状态，是以对象的运行类型执行的。</li></ol></li><li><p>断点调试介绍</p><ol><li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停止，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下，进行分析从而找到这个Bug</li><li>断点调试也是程序员必须掌握的技能。</li><li>断点调试也能帮助我们查看Java底层源代码的执行过程，提高程序员的Java水平。</li></ol></li><li><p>断点调试的快捷键：</p><p>F7（跳入）    F8（跳过）    shift+F8（跳出）    F9（resume，执行到下一个断点）</p><p>F7：跳入方法内</p><p>F8：逐行执行代码</p><p>shift+F8：跳出方法</p></li><li><p>断点调试应用案例</p><p>巴拉巴拉，歪比巴卜</p><img src="..\Java基础查漏补缺\断点调试.png"/><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7483471.html">IDEA调试总结（设置断点进行调试） - fcyh - 博客园 (cnblogs.com)</a></p></li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="类变量与类方法"><a href="#类变量与类方法" class="headerlink" title="类变量与类方法"></a>类变量与类方法</h3><ul><li><p>什么是变量</p><p>类变量也叫静态变量、静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量</p></li><li><p>如何定义变量</p><p>定义语法：</p><p>访问修饰符    static    数据类型    变量名；【推荐】</p><p>static    访问修饰符    数据类型    变量名；</p></li><li><p>如何访问类变量</p><p>类名.类变量【类变量是随着类加载而创建的，所以即使没有创建对象实例也可以访问】</p><p>或者对象名.类变量名【静态变量的访问修饰符的访问权限和范围华人普通属性是一样的】</p><p>推荐使用：类名.类变量名</p></li><li><p>类变量的内存布局</p><p>有些书上说在方法区，…………jdk版本有关系，</p><p>记住一点：static变量是对象共享，不管static变量在哪里，</p><p>共识1、static变量是同一个类所有对象共享</p><p>共识2、static变量在类加载的时候就生成了</p></li><li><p>类变量使用注意事项和细节讨论</p><ol><li><p>什么时候需要用类变量</p><p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>类变量与实例变量的区别</p><p>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</p></li><li><p>加上static称为类变量或静态变量，否则称为实例变量、普通变量、非静态变量</p></li><li><p>类变量的生命周期随着类的加载开始，随着类消亡而销毁</p></li></ol></li></ul><p>类方法同理</p><ul><li><p>类方法经典的使用场景</p><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率</p><p>比如：工具类的方法utils、Maths类、Arrays类、Collections集合类</p><p>小结：在程序员实际开发时，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象，就可以使用了，比如打印一维数组，排序算法等</p></li><li><p>类方法使用注意事项和细节讨论</p><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区，类方法中无this参数，普通方法中隐含this的参数</li><li>类方法可以通过类名调用。也可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</li><li>类方法中不允许使用和对象有关的关键字，比如this和super，普通方法（成员方法）可以</li><li>类方法（静态方法）中只能访问静态变量或静态方法</li><li>普通成员方法，既可以访问普通变量（方法），也可以访问静态变量（方法）</li></ol><p>小结：静态方法，只能访问静态的成员；非静态的方法，可以访问静态成员和非静态成员。（必须遵守访问权限）</p></li></ul><h3 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h3><ul><li><p>深入理解main方法</p><p>解释main方法的形式：public static void main（String【】 args）{}</p><ol><li>Java虚拟机需要调用类的main（）方法，所以该方法的访问权限必须是public</li><li>Java虚拟机在执行main（）方法时不必创建对象，所以该方法必须是static</li><li>该方法接收String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数</li><li>Java     执行的程序    参数1    参数2     参数3</li></ol><img src="..\Java基础查漏补缺\main方法的参数列表.png"/></li><li><p>特别提示</p><ol><li>在main（）方法中，我们可以直接调用main方法所在类的静态方法或静态属性</li><li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol><p>如何使用IDEA中的main方法的传参列表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testmain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\Java基础查漏补缺\main加入参数.png"/></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><img src="..\Java基础查漏补缺\代码块.png"/><ul><li>代码块的好处<ol><li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li><li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li></ol></li></ul><p>代码块调用的顺序优先于构造器</p><ul><li><p>代码块的使用细节</p><ol><li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行</p></li><li><p>类什么时候被加载【重要】</p><ul><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性、静态方法）</li></ul></li><li><p>普通的代码块，在创建对象实例时，会被隐式的调用</p><p>被创建一次，就会调用一次</p><p>如果只是使用类的静态成员时，普通代码块并不会执行</p></li><li><p>创建一个对象时，在一个类调用顺序是：（重点难点）</p><ul><li>调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</li><li>调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</li><li>调用构造方法</li></ul></li><li><p>构造方法的最前面其实隐含了super（）和调用普通代码块</p></li><li><p>我们看一下创建一个子类时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</p><ul><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和成员属性</li><li>父类的构造方法</li><li>子类的普通代码块和成员属性</li><li>子类的构造方法</li></ul></li><li><p>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p></li></ol></li></ul><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul><li><p>基本介绍</p><p>final：最后的、最终的</p><p>final可以修饰类、属性、方法和局部变量</p><p>在某些情况下，程序员可能有以下需求，就会使用final：</p><ol><li>当不希望类被继承时，可以使用final修饰</li><li>当不希望父类的某个方法被子类覆盖时，可以用final关键字修饰</li><li>当不希望类的某个属性的值被修改，可以用final修饰</li><li>当不希望某个局部变量被修改，可以使用final修饰</li></ol></li><li><p>final使用注意事项和细节讨论</p><ol><li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p></li><li><p>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】：</p><ul><li><p>定义时：public final double TAX_RATE = 0.08;</p></li><li><p>在构造器中</p></li><li><p>在代码块中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE = <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE3;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TAX_RATE3 = <span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果final修饰的属性时静态的，则初始化的位置只能是</p><ul><li>定义时</li><li>在静态代码块可以，不能在构造器中赋值【根据加载顺序，静态属性会被先加载，如果在构造器中才赋初值的话，此时静态常量没有值，故不能在构造器中给静态常量赋值】</li></ul></li><li><p>final类不能继承，但是可以实例化对象</p></li><li><p>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</p></li><li><p>一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法</p></li><li><p>final不能修饰构造方法【即构造器】</p></li><li><p>final和static往往搭配使用，效率更高，底层编译器做了优化处理【不会导致类的加载】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(AA.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是静态代码块！！！&quot;</span>+num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包装类（Integer、Double、Float、Boolean等都是final），String也是final类</p></li></ol><p>习题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">something</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//final可以放该位置</span></span><br><span class="line"><span class="comment">//x++;//不行</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">1</span>;<span class="comment">//可以，常量x的值并没有发生改变</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>当父类的某些方法需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p><ul><li><p>抽象类的介绍</p><ol><li><p>用abstract关键字来修饰一个类时，这个类就叫抽象类</p><p>访问修饰符    abstract    类名{}</p></li><li><p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p><p>访问修饰符    abstract    返回类型    方法名（参数列表）；//没有方法体</p></li><li><p>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类（）</p></li><li><p>抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多</p></li></ol></li><li><p>抽象类使用的细节事项和细节讨论</p><ol><li>抽象类不能被实例化</li><li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</li><li>一旦类包含了abstract方法，则这个类必须声明为abstract</li><li>abstract只能修饰类和方法，不能修饰属性和其他的</li><li>抽象类可以有任意成员【因为抽象类还是类】，比如：非抽象方法、构造器、静态属性等</li><li>抽象方法不能有主体，即不能实现</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明abstract类</li><li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li></ol></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>为什么有接口</p><p>usb插槽就是现实中的接口</p></li><li><p>基本介绍</p><p>接口就是给出一些没有实现的方法封装在一起，等到某个类要使用时，再根据具体情况把这些方法写出来，语法：</p><p>interface    接口名{</p><p>​    //属性</p><p>​    //方法（1、抽象方法    2、默认实现方法    3、静态方法）</p><p>}</p><p>class    类名    implements    接口{</p><p>​    自己的属性；</p><p>​    自己的方法；</p><p>​    必须实现的接口的抽象方法</p><p>}</p><p>在接口中，抽象方法可以省略abstract关键字</p><p>小结：</p><ol><li>在JDK7.0前，接口里的所有方法都没有方法体</li><li>JDK8.0后，接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</li></ol></li><li><p>注意事项和使用细节</p><ol><li><p>接口不能被实例化</p></li><li><p>接口中所有的方法是public方法，接口中抽象方法可以不用abstract修饰</p></li><li><p>一个普通抽象类实现接口，就必须将该接口的所有方法实现</p></li><li><p>抽象类实现接口，可以不用实现接口的方法</p></li><li><p>一个类同时可以实现多个接口</p></li><li><p>接口中的属性只能是final的，而且是public static final 修饰符。比如：int a=1；实际上是public static final int a = 1；（必须初始化）</p></li><li><p>接口中属性的访问形式：接口名.属性名</p></li><li><p>一个接口不能继承其他的类，但是可以继承多个别的接口</p><p>interface A extends B，C{}</p></li><li><p>接口的修饰符只能是public和默认，这点和类的修饰符是一样的</p></li></ol></li><li><p>实现接口VS继承类</p><p>接口和继承解决的问题不同</p><ul><li>继承的价值主要在于：解决代码的复用性和可维护性</li><li>接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法</li></ul><p>接口比继承更加灵活</p><ul><li>接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系</li></ul><p>接口在一定程度上实现了代码解耦【即：接口规范性+动态绑定】</p></li><li><p>接口的多态特性</p><ol><li>多态参数</li><li>多态数组</li><li>接口存在多态传递现象</li></ol></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li><p>基本介绍</p><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p></li><li><p>基本语法</p><p>class    Outer{//外部类</p><p>​    class    Inner{//内部类</p><p>​    }</p><p>}</p><p>class    Other{//外部其他类</p><p>}</p></li><li><p>内部类的分类</p><ul><li>定义在外部类局部位置上（比如方法内）<ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名，重点！！！！！！！！！！！）</li></ol></li><li>定义在外部类的成员位置上<ol><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ol></li></ul></li><li><p>局部内部类的使用</p><p>说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p><ol><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用访问修饰符的。但是可以使用final修饰，因为局部变量也可以使用final</p></li><li><p>作用域：仅仅在定义它的方法或代码块中</p></li><li><p>局部内部类——访问——&gt;外部类的成员【访问方式：直接访问】</p></li><li><p>外部类——访问——&gt;局部内部类的成员</p><p>访问方式：创建对象，再访问（注意：必须放在作用域内）</p></li><li><p>外部其他类——不能访问——&gt;局部内部类（因为局部内部类地位是一个局部变量）</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问【Outer02.this本质就是外部类的对象，即哪个对象调用m1，Outer02.this就是哪个对象】</p></li></ol><p>记住：</p><ol><li>局部内部类定义在方法中/代码块</li><li>作用域在方法体或者代码块中</li><li>本质仍然是一个类</li></ol></li><li><p>匿名内部类的使用【重要！！！】</p><p>【1、本质是类    2、内部类    3、该类没有名字    4、同时还是一个对象】</p><p>说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名</p><ol><li><p>匿名内部类的基本语法</p><p>new 类或接口（参数列表）{</p><p>​    类体</p><p>};</p></li><li><p>匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，因此可以直接调用匿名内部类方法。</p></li><li><p>可以直接访问外部类的所有成员，包括私有的</p></li><li><p>不能添加访问修饰符，因为它的定位就是一个局部变量</p></li><li><p>作用域：仅仅在定义他的方法或代码块中</p></li><li><p>外部其他类不能访问匿名内部类（因为匿名内部类地位是一个局部变量）</p></li><li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类.this.成员）去访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是局部内部类！！！&quot;</span>+<span class="string">&quot;就近原则访问方法里的属性：&quot;</span>+i+<span class="string">&quot;访问外部类的属性&quot;</span>+Outer.<span class="keyword">this</span>.i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.hi();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="comment">//tiger的编译类型是IA</span></span><br><span class="line">        <span class="comment">//tiger的运行类型是Outer$1</span></span><br><span class="line">        IA tiger = <span class="keyword">new</span> IA()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.shout();</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型：&quot;</span>+tiger.getClass());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> IA()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小狗叫！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.shout();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>匿名内部类的最佳实践</p><p>当做实参直接传递，简洁高效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(AA a)</span> </span>&#123;</span><br><span class="line">a.cry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">show(<span class="keyword">new</span> AA() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;隔壁王大爷在吃面条~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成员内部类的使用</p><p>说明：成员内部类是定义在外部类的成员位置，并且没有static修饰</p><ol><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员。</p></li><li><p>作用域</p><p>和外部类的其他成员一样，为整个类体</p></li><li><p>成员内部类——访问——&gt;外部类（比如：属性）【访问方式：直接访问】</p></li><li><p>外部类——访问——&gt;内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类——访问——&gt;成员内部类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他外部类访问Outer的内部类</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner1 inner1 = outer.<span class="function">new <span class="title">Inner1</span><span class="params">()</span></span>;</span><br><span class="line">inner1.say();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">Outer.Inner1 inner11 = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner1</span><span class="params">()</span></span>;</span><br><span class="line">inner11.say();</span><br><span class="line"><span class="comment">//方式三:使用一个方法来获取，更加简洁</span></span><br><span class="line">Outer.Inner1 inner3 = outer.getInstance();</span><br><span class="line">inner3.say();</span><br></pre></td></tr></table></figure></li><li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类.this.成员）去访问</p></li></ol></li><li><p>静态内部类</p><p>说明：静态内部类是定义再外部类的成员位置，并且有static修饰</p><ol><li><p>可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问非静态成员</p></li><li><p>可以添加任意访问修饰符（private、默认、protected、public），因为它的地位就是一个成员</p></li><li><p>作用域：同其他的成员一样，为整个类体</p></li><li><p>静态内部类——访问——&gt;外部类（比如：静态属性）【访问方式：直接访问】</p></li><li><p>外部类——访问——&gt;静态内部类【访问方式：创建对象，再访问】</p></li><li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问静态内部类</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">Outer.Inner2 inner1 = <span class="keyword">new</span> Outer.Inner2();</span><br><span class="line">inner1.say();</span><br><span class="line"><span class="comment">//方式二:编写一个方法返回静态内部类</span></span><br><span class="line">Outer.Inner2 instance2 = <span class="keyword">new</span> Outer().getInstance2();</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><ol><li>枚举对应英文（enumeration，简称enum）</li><li>枚举是一组常量的集合</li><li>可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象</li><li>枚举的两种实现方式<ul><li>自定义实现枚举</li><li>使用enum关键字实现枚举</li></ul></li></ol><h2 id="自定义注解实现枚举"><a href="#自定义注解实现枚举" class="headerlink" title="自定义注解实现枚举"></a>自定义注解实现枚举</h2><ol><li>不需要提供setXXX方法，因为枚举对象值通常只读</li><li>对枚举对象/属性使用final+static共同修饰，实现底层优化。</li><li>枚举对象通常使用全部大写，常量的命名规范</li><li>枚举对象根据需要，也可以有多个属性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Season.SPRING.getSeason()+<span class="string">&quot;:&quot;</span>+Season.SPRING.getDesc());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String season;</span><br><span class="line"><span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;和煦&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;丰收&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String season, String desc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.season = season;</span><br><span class="line"><span class="keyword">this</span>.desc = desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeason</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> season;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小结：进行自定义类实现枚举，有如下特点：<ul><li>构造器私有化</li><li>本类内部创建一组对象</li><li>对外暴露对象（通过为对象添加public final static 修饰符）</li><li>可以提供get方法，但是不要提供set</li></ul></li></ul><h2 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Season2.SPRING);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">SPRING(<span class="string">&quot;春&quot;</span>,<span class="string">&quot;和煦&quot;</span>),</span><br><span class="line">    <span class="comment">//WHAT,</span></span><br><span class="line">SUMMER(<span class="string">&quot;夏&quot;</span>,<span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">AUTUMN(<span class="string">&quot;春&quot;</span>,<span class="string">&quot;和煦&quot;</span>),</span><br><span class="line">WINTER(<span class="string">&quot;春&quot;</span>,<span class="string">&quot;和煦&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String season;</span><br><span class="line"><span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Season2()&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Season2</span><span class="params">(String season,String desc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.season = season;</span><br><span class="line"><span class="keyword">this</span>.desc = desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeason</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> season;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Season2&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;season=&#x27;&quot;</span> + season + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用关键字enum替代class，当我们使用enum关键字开发一个枚举类时，默认会继承Enum类【如何证明】</p><p>反编译javap：</p><img src="..\Java基础查漏补缺\枚举的继承.png"/></li><li><p>语句被简化，直接使用SPRING（”春天”,”温暖”），这里必须知道，它调用的是哪个构造器</p></li><li><p>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</p></li><li><p>如果有多个常量（对象），使用逗号（，）间隔即可，最后有一个分号结尾</p></li><li><p>如果使用enum来实现枚举，要求将定义常量对象，写在行首</p></li></ol><img src="..\Java基础查漏补缺\枚举练习.png"/><img src="..\Java基础查漏补缺\枚举练习2.png"/><ul><li><p>enum常用方法说明</p><p>说明：使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类相关的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><img src="..\Java基础查漏补缺\enum常用方法.png"/></li><li><p>enum实现接口</p><ol><li><p>使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum，而Java是单继承机制</p></li><li><p>枚举类和普通类一样，可以实现接口，如下形式。</p><p>enum    类名    implements    接口1，接口2{}</p></li></ol></li></ul><h2 id="JDK内置的基本注解类型"><a href="#JDK内置的基本注解类型" class="headerlink" title="JDK内置的基本注解类型"></a>JDK内置的基本注解类型</h2><ol><li>注解（Annotation）也被称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</li><li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等</li></ol><ul><li><p>基本的Annotation介绍</p><p>使用Annotation时要在其前面加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素</p><p>三个基本的Annotation：</p><ul><li><p>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</p><ul><li>@Override表示指定重写父类的方法（从编译层面验证，如果父类没有对应的方法，则会报错）</li><li>如果不写@Override注解，而父类仍有对父类方法重写的方法，仍然构成重写</li><li>@Override只能修饰方法，不能修饰其他类、包、属性等</li><li>查看@Override注解源码为@Target（ElementType.METHOD），说明只能修饰方法</li><li>@Target是修饰注解的注解，称为元注解</li></ul></li><li><p>@Deprecated：用于表示某个程序元素（类、方法等）已过时</p><ul><li><p>可以修饰方法、类、字段、包、参数等</p></li><li><p>@Deprecated的作用可以做到新旧版本的兼容和过渡</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>@SuppressWarnings：抑制编译器警告</p><ul><li>unchecked：忽略没有检查的警告</li><li>rawtypes：忽略没有指定泛型的警告（传参时没有指定泛型的警告错误）</li><li>unused：忽略没有使用某个变量的警告错误</li><li>生成@SuppressWarnings时，不用背，直接点击左侧的黄色提示，就可以选择（注意可以指定生成的位置）</li></ul></li></ul></li></ul><h2 id="元注解：对注解进行注解"><a href="#元注解：对注解进行注解" class="headerlink" title="元注解：对注解进行注解"></a>元注解：对注解进行注解</h2><ul><li><p>元注解的基本介绍</p><p>JDK的元Annotation用于修饰其他Annotation</p><p>元注解：本身作用不大，将这个原因是希望同学们看源码时，可以知道它是干什么的</p></li><li><p>元注解的种类（使用不多，了解，不用深入研究）</p><ul><li><p>Retention     //指定注解的作用范围，三种SOURCE、CLASS、RUNTIME</p><ul><li><p>说明</p><p>只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间</p><p>@Retention包含一个RetentionPolicy类型的成员变量，使用@Retention时，必须为该value成员变量指定值</p></li><li><p>Retention的三种值</p><ol><li>RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注解</li><li>RetentionPolicy.CLASS：编译器将把注释记录在class文件中，当运行Java程序时，JVM不会保留注解，这是默认值</li><li>RetentionPolicy.RUNTIME：编译器将把注释记录在class文件中，当运行Java程序时，JVM会保留注释，程序可以通过反射获取该注释</li></ol><p>说明：Override的作用域在SOURCE，当编译器编译时生效，不会写入到.class文件，也不会再runtime（运行时）生效</p></li></ul></li><li><p>Target        //指定注解可以在哪些地方使用</p><p>用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素，@Target也包含一个名为value的成员变量</p></li><li><p>Documented        //指定该注解是否会在javadoc体现</p><p>用于指定被该元注解修饰的Annotation类将被javadoc工具提取成文档，即在生成文档时，可以看到该注解</p><p>说明：定义为Documented的注解必须设置Retention值为RUNTIME</p></li><li><p>Inherited    //子类会继承父类注解</p><p>被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p><p>说明：实际应用中，使用较少，了解即可</p></li></ul></li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h2><ul><li><p>基本概念</p><p>Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p></li><li><p>执行过程中所发生的异常事件可分为两类</p><ol><li>Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError【栈溢出】和OOM（out of memory），Error是严重错误，程序会崩溃。</li><li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等，Exception分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】。</li></ol></li></ul><h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><img src="..\Java基础查漏补缺\异常的继承.png"/><img src="..\Java基础查漏补缺\异常体系图.png"/><ul><li>异常体系图的小结<ol><li>异常分为两大类，运行时异常和编译时异常</li><li>运行时异常，编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常</li><li>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li><li>编译时异常是编译器要求必须处理的异常</li></ol></li></ul><h2 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h2><ul><li><p>运行时异常</p><ol><li><p>NullPointerException空指针异常</p><p>当应用程序试图在需要对象的地方使用null时</p></li><li><p>ArithmeticException数学运算异常</p><p>当出现异常的运行条件时，抛出异常，例如，一个整数除以零时</p></li><li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p><p>用非法索引访问数组时抛出的异常，如果索引为负或大于等于数组大小，则该索引为非法索引</p></li><li><p>ClassCastException类型转换异常</p><p>当试图将对象强制转换为不是实例的子类时，抛出异常</p></li><li><p>NumberFormatException数字格式不正确异常</p><p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出异常 =&gt; 使用异常我们可以确保输入是满足条件的数字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">Double d = Double.parseDouble(s);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>编译时异常</p><ul><li><p>介绍</p><p>编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译，一般发生在<strong>网络、数据库、文件操作时</strong></p></li><li><p>常见的编译异常</p><ol><li>SQLException     //操作数据库时，查询表可能发生的异常</li><li>IOException     //操作文件时，发生的异常</li><li>FileNotFoundException     //当操作一个不存在的文件时，发生异常</li><li>ClassNotFoundException     //加载类而该类不存在时，异常</li><li>EOFException     //操作文件，到文件末尾，发生异常</li><li>IllegalArguementException     //参数异常</li></ol></li></ul></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><p>基本介绍</p><p>异常处理就是当异常发生时，对异常处理的方式</p></li><li><p>异常处理的方式</p><ol><li><p>try-catch-finally</p><p>程序员在代码中捕获发生的异常，自行处理</p></li><li><p>throws</p><p>将发生的异常抛出，交给调用者（方法）来处理，最顶尖的处理者就是JVM（将异常抛给上一级处理）</p><p>默认采用throws方法</p><img src="..\Java基础查漏补缺\throws处理异常的方式.png"/></li></ol></li><li><p>try-catch异常处理</p><ol><li><p>Java提供try和catch块来处理异常，try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个数量的try·····catch块</p></li><li><p>基本语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可疑代码</span></span><br><span class="line"><span class="comment">//将异常生成对应的异常对象，传递给catch块</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>（异常）&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对异常的处理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</li><li>如果异常没有发生，则顺序执行try的代码块，不会进入到catch</li><li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用finally{}</li></ul></li></ol></li><li><p>throws异常处理</p><ol><li>如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式的声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</li><li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ol></li><li><p>throws注意事项和使用细节</p><ol><li>对于编译异常，程序中必须处理，比如try-catch或者throws</li><li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常的类型的子类型</li><li>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</li></ol></li></ul><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul><li><p>基本概念</p><p>当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理。这个时候可以自己设计异常类，用于描述该错误信息</p></li><li><p>自定义异常的步骤</p><ol><li>定义类：自定义异常类名（程序员自己写）继承Exception或RuntimeException</li><li>如果继承Exception，属于编译异常</li><li>如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）</li></ol></li></ul><h2 id="throw和throws的对比"><a href="#throw和throws的对比" class="headerlink" title="throw和throws的对比"></a>throw和throws的对比</h2><ul><li><p>一览表</p><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table></li></ul><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>包装类的分类</p><ol><li><p>针对八种基本定义相应的引用类型——包装类(Wrapper)</p></li><li><p>有了类的特点，就可以调用类中的方法</p><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr></tbody></table><p>包装类的继承体系：</p><img src="..\Java基础查漏补缺\包装类1.png"/><img src="..\Java基础查漏补缺\包装类2.png"/><img src="..\Java基础查漏补缺\包装类3.png"/></li></ol></li><li><p>包装类和基本数据类型的转换</p><ol><li><p>jdk5前，手动装箱和拆箱，装箱：基本类型——&gt;包装类型，反之，拆箱</p></li><li><p>jdk5（含jdk5）后，自动装箱和拆箱方式</p></li><li><p>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">Integer integer1 = <span class="keyword">new</span> Integer(n1);<span class="comment">//方式一</span></span><br><span class="line">Integer integer2 = Integer.valueOf(n1);<span class="comment">//方式二</span></span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = integer1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">100</span>;</span><br><span class="line">Integer integer3 = n2;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> n3 = integer3;</span><br></pre></td></tr></table></figure><p>习题：</p><img src="..\Java基础查漏补缺\包装类习题1.png"/></li></ol></li><li><p>包装类型和String类型的互相转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类型——&gt;String类型</span></span><br><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line">String s1 = i.toString();<span class="comment">//方式一</span></span><br><span class="line">String s2 = String.valueOf(i);<span class="comment">//方式二</span></span><br><span class="line">String s3 = i+<span class="string">&quot;&quot;</span>;<span class="comment">//方式三：对i本身的值无影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String类型——&gt;包装类</span></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(s1);<span class="comment">//方式1</span></span><br><span class="line">Integer j2 = Integer.valueOf(s2);<span class="comment">//方式2</span></span><br></pre></td></tr></table></figure></li><li><p>Integer和Character类的常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE);</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符包装类Character</span></span><br><span class="line"><span class="comment">//判断是不是字母</span></span><br><span class="line">System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是数字</span></span><br><span class="line">System.out.println(Character.isDigit(<span class="string">&#x27;1&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是大写</span></span><br><span class="line">System.out.println(Character.isUpperCase(<span class="string">&#x27;W&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是小写</span></span><br><span class="line">System.out.println(Character.isLowerCase(<span class="string">&#x27;q&#x27;</span>));</span><br><span class="line"><span class="comment">//判断是不是空格</span></span><br><span class="line">System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line"><span class="comment">//转成大写</span></span><br><span class="line">System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">//转成小写</span></span><br><span class="line">System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure><p>习题：</p><img src="..\Java基础查漏补缺\包装类习题2.png"/><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            ······························</span><br><span class="line">            ······························</span><br></pre></td></tr></table></figure><p>习题：</p><img src="..\Java基础查漏补缺\包装类练习3.png"/></li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li><p>String类的理解和创建对象</p><ol><li><p>String对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号括起的字符序列，例如：“你好”、“12.12”、“boy”等</p></li><li><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p></li><li><p>String类比较常用的构造方法（其他看手册）：</p><ul><li>String str1 = new String（）；</li><li>String str2 = new String（String original）；</li><li>String str3 = new String（char【】 a）；</li><li>String str4 = new String（char【】 a，int startIndex，int count）；</li><li>String str5 = new String（byte【】 b）；</li></ul></li><li><p>String类实现了接口Serializable【String可以串行化：可以在网络传输】</p><p>String类实现了接口Comparable【String对象可以比较大小】</p></li><li><p>String是final类，不能被其他的类继承</p></li><li><p>String有属性private final char value【】，用于存放字符串内容，一个字符串对象一旦被分配，其内容是不可变的</p></li><li><p>一定要注意：value是一个final类型，不可以修改（重点:指向不能被修改）：即value不能指向新的地址，但是单个字符内容是可以变化的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">char</span>[] value = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>[] value2 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">value[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"><span class="comment">//value = value2;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>创建String对象的两种方式</p><ol><li>方式一：直接赋值   String s = “hsp”；</li><li>方式二：调用构造器   String s = new String（“hsp”）；</li></ol></li><li><p>两种创建String对象的区别</p><ol><li><p>方式一：先从常量池查看是否有“hsp”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p></li><li><p>方式二：先在堆中创建对象，里面维护了value属性，指向常量池的hsp空间。如果常量池没有“hsp”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</p><img src="..\Java基础查漏补缺\String的内存布局.png"/><p>习题：</p><img src="..\Java基础查漏补缺\String练习3.png"/><img src="..\Java基础查漏补缺\String练习4.png"/><img src="..\Java基础查漏补缺\String练习5-1.png"/><img src="..\Java基础查漏补缺\String练习5.png"/></li></ol></li><li><p>String类的常用方法</p><p>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此，Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p><p>String类的常见方法一览：</p><ul><li>equals：区分大小写，判断内容是否相等</li><li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li><li>length：获取字符的个数，字符串的长度</li><li>indexOf：获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到，返回-1</li><li>lastIndexOf：获取字符在字符串中最后一次出现的索引，索引从0开始，如找不到，返回-1</li><li>substring：截取指定范围的子串</li><li>trim：去除前后空格</li><li>charAt：获取某索引处字符，注意不能使用Str【index】这种方式</li><li>toUpperCase：转换成大写</li><li>toLowerCase：转换成小写</li><li>concat：拼接字符串</li><li>replace：替换字符串中的字符</li><li>split：分割字符串，对于某些分割字符，我们需要转义</li><li>compareTo：比较两个字符串大小，如果前者大，则返回正数；后者大，则返回负数；相等返回0</li><li>toCharArray：将字符串转换成字符数组</li><li>format：格式字符串    占位符：%s【字符串】    %c【字符】      %d【整型】      %.2f【浮点型】</li></ul></li></ul><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul><li><p>基本介绍</p><ul><li>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</li><li>很多方法与String相同，但StringBuffer是可变长度的</li><li>StringBuffer是一个容器</li><li>StringBuffer的直接父类是AbstractStringBuilder</li><li>StringBuffer实现了Serialzable，即StringBuffer的对象可以串行化</li><li>在父类中AbstractStringBuilder有属性char【】 value，不是final</li><li>该value数组存放的字符串内容，放在堆中</li><li>StringBuffer是一个final类，不能被继承</li><li>String   VS   StringBuffer<ul><li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低      //private final char value[]</li><li>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高      //这个放在堆里</li></ul></li></ul></li><li><p>String和StringBuffer互相转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String ——&gt; StringBuffer：返回的才是StringBuffer对象，对str本身没有影响</span></span><br><span class="line">String s = <span class="string">&quot;qwer&quot;</span>;</span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(s);<span class="comment">//方式一</span></span><br><span class="line">StringBuffer stringBuffer1 = <span class="keyword">new</span> StringBuffer();<span class="comment">//方式二</span></span><br><span class="line">stringBuffer1.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer ——&gt; String</span></span><br><span class="line">String s1 = stringBuffer.toString();<span class="comment">//方式一</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(s1);<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li><p>StringBuffer的常见方法</p><ul><li>append：增</li><li>delete（start，end）：删除</li><li>replace（start，end，string）：将start——end间 [start，end）的内容替换掉，不含end</li><li>indexOf：查找子串在字符串第一次出现的索引，如果找不到返回-1</li><li>insert：插入</li><li>length：获取长度</li></ul></li><li><p>练习</p><img src="..\Java基础查漏补缺\StringBuffer练习1.png"/></li></ul><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><ul><li><p>基本介绍</p><ul><li>一个不是线程安全的、可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步，该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候，如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快</li><li>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以便接收任意类型的数据。</li><li>StringBuilder继承AbstractStringBuilder类</li><li>实现了Serialzable，说明StingBuilder对象是可以串行化（对象可以网络传输，可以保存文件）</li><li>StringBuilder是final类，不能被继承</li><li>StringBuilder对象字符序列仍然是存放在其父类AbstractStringBuilder的char【】 final，因此，字符序列在堆中</li><li>StringBuilder的方法，没有做互斥的处理，即没有synchronized关键字，因此在单线程的情况下使用</li></ul></li><li><p>String、StringBuffer和StringBuilder的比较</p><ol><li><p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p></li><li><p>String：不可变字符序列，效率低，但是复用率高</p></li><li><p>StringBuffer：可变字符序列、效率较高（增删）、线程安全</p></li><li><p>StringBuilder：可变字符序列、效率最高、线程不安全</p></li><li><p>String使用注意说明：</p><p>String s=“a”；//创建了一个字符串</p><p>s += “b”；//实际上原来的“a”字符串对象已经被遗弃，现在又产生了一个字符串s+“b”（也就是“ab”），如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能==&gt;结论：如果我们对String做大量修改，不要使用String</p></li></ol></li><li><p>String、StringBuffer和StringBuilder的选择</p><p>使用的原则，结论：</p><ol><li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li><li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li><li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li><li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li></ol></li></ul><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul><li><p>基本介绍</p><p>Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数</p></li><li><p>方法一览（均为静态方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;abs:绝对值&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> abs = Math.abs(-<span class="number">12.1</span>);</span><br><span class="line">System.out.println(abs);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;ceil:向上转型&quot;</span>);</span><br><span class="line">System.out.println(Math.ceil(<span class="number">12.1</span>));</span><br><span class="line">System.out.println(Math.ceil(<span class="number">12.9</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;floor:向下转型&quot;</span>);</span><br><span class="line">System.out.println(Math.floor(<span class="number">12.1</span>));</span><br><span class="line">System.out.println(Math.floor(<span class="number">12.9</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;round:四舍五入&quot;</span>);</span><br><span class="line">System.out.println(Math.round(<span class="number">12.1</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">12.9</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;max:最大值&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> max = Math.max(<span class="number">12</span>, <span class="number">111</span>);</span><br><span class="line">System.out.println(max);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;函数曲线cos：输入x轴，返回y轴&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> cos = Math.cos(Math.PI);</span><br><span class="line">System.out.println(cos);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;sqrt:开方&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> sqrt = Math.sqrt(<span class="number">4</span>);</span><br><span class="line">System.out.println(sqrt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;pow:求幂&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> pow = Math.pow(<span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(pow);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;======= 随机数[0,1) 100次========&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">double</span> random = Math.random();</span><br><span class="line">   System.out.println(random);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回[2，7]之间的随机整数</span></span><br><span class="line"><span class="comment">//(int)(a + Math.random()*(b-a+1))</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">6</span> + <span class="number">2</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Date、Calendar、LocalDate…"><a href="#Date、Calendar、LocalDate…" class="headerlink" title="Date、Calendar、LocalDate…"></a>Date、Calendar、LocalDate…</h2><ul><li><p>第一代日期类</p><ol><li>Date：精确到毫秒，代表特定的瞬间</li><li>SimpleDateFormat：格式和解析日期的类，它允许进行格式化（日期——&gt;文本）、解析（文本——&gt;日期）和规范化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date1 = <span class="keyword">new</span> Date();<span class="comment">//获取当前的系统时间</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">43434</span>);<span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(date1.getTime());<span class="comment">//获得某个时间的对应毫秒数</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日hh:mm:ss E&quot;</span>);</span><br><span class="line">String format = sdf.format(date1);</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;1923年01月23日11:11:11 星期一&quot;</span>;</span><br><span class="line">Date date3 = sdf.parse(s);</span><br></pre></td></tr></table></figure><img src="..\Java基础查漏补缺\SimpleDateFormat字母定义.png"/></li><li><p>第二代日期类</p><ol><li><p>第二代日期类主要是Calendar类（日历）</p><p>public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt; Calender&gt;</p></li><li><p>Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Calendar没有提供对应的格式化的类，因此需要程序员自己组合</span></span><br><span class="line">Calendar instance = Calendar.getInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;年:&quot;</span>+instance.get(Calendar.YEAR));</span><br><span class="line">System.out.println(<span class="string">&quot;月:&quot;</span>+(instance.get(Calendar.MONTH)+<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;日:&quot;</span>+instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;时:&quot;</span>+instance.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(<span class="string">&quot;分:&quot;</span>+instance.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒:&quot;</span>+instance.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure></li><li><p>第三代日期类</p><p>JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用，而Calendar也存在问题：</p><ol><li>可变性</li><li>偏移性：Date中的年份从1900开始，而月份都是从0开始(month需要加1)</li><li>格式化：格式化对Date有用，Calendar则不行</li><li>此外，它们也不是线程安全的，不能处理闰秒等（每隔2天，多出1s）</li></ol><ul><li><p>第三代日期类常见方法</p><p>LocalDate（日期）、LocalTime（时间）、LocalDateTime（日期时间）JDK8加入</p><p>LocalDate只包含日期，可以获取日期字段</p><p>LocalTime只包含时间，可以获取时间字段</p><p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p></li><li><p>DateTimeFormatter格式日期类</p><p>类似于SimpleDateFormat</p></li><li><p>Instant时间戳</p><p>类似于Date</p><p>提供了一系列和Date类转换的方式</p></li><li><p>第三代日期类更多方法</p><ul><li>LocalDateTime类</li><li>MonthDay类：检查重复事件</li><li>是否是闰年</li><li>增加日期的某个部分</li><li>使用plus方法测试增加时间的某个部分</li><li>使用minus方法测试查看一年前和一年后的日期</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span>+localDateTime.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+localDateTime.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+localDateTime.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+localDateTime.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时：&quot;</span>+localDateTime.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分：&quot;</span>+localDateTime.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span>+localDateTime.getSecond());</span><br><span class="line"></span><br><span class="line"><span class="comment">//DateTimeFormatter</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;</span>);</span><br><span class="line">String format1 = dateTimeFormatter.format(localDateTime);</span><br><span class="line">System.out.println(format1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳Instant</span></span><br><span class="line">Instant now = Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"><span class="comment">//Instant——&gt;date</span></span><br><span class="line">Date date2 = Date.from(now);</span><br><span class="line">System.out.println(date2);</span><br><span class="line"><span class="comment">//Date——&gt;Instant</span></span><br><span class="line">Instant instant = date2.toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus增加</span></span><br><span class="line">System.out.println(<span class="string">&quot;plus使用======显示100天以后的时间=======&quot;</span>);</span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.plusDays(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;100天以后的时间：&quot;</span>+dateTimeFormatter.format(localDateTime1));</span><br></pre></td></tr></table></figure></li></ul><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><ul><li><p>System类常见方法和案例</p><ol><li><p>exit：退出当前程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;ok1&quot;</span>);</span><br><span class="line"><span class="comment">//1、exit(0)表示程序退出</span></span><br><span class="line"><span class="comment">//2、0表示一个状态，正常的状态</span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ok2&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//当前&#123;0，0，0&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">src      the source array.原数组</span></span><br><span class="line"><span class="comment">srcPos   starting position in the source array.开始拷贝的原数组的起始位置</span></span><br><span class="line"><span class="comment">dest     the destination array.目标数组</span></span><br><span class="line"><span class="comment">destPos  starting position in the destination data.目标数据开始存放的位置</span></span><br><span class="line"><span class="comment">length   the number of array elements to be copied.拷贝元素的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,src.length);</span><br></pre></td></tr></table></figure></li><li><p>currentTimeMillens：返回当前时间距离1970-1-1的毫秒数</p></li><li><p>gc：运行垃圾回收机制System.gc()</p></li></ol></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><ul><li><p>Arrays类常见方法</p><p>Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p><ol><li><p>toString：返回数组的字符串形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a string representation of the contents of the specified array.</span></span><br><span class="line"><span class="comment">   * 返回指定数组内容的字符串表示形式</span></span><br><span class="line"><span class="comment">   * The string representation consists of a list of the array&#x27;s elements,</span></span><br><span class="line"><span class="comment">   * enclosed in square brackets(用方括号括起来) (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).</span></span><br><span class="line"><span class="comment">   * Adjacent[əˈdʒeɪs(ə)nt]相邻的 elements are</span></span><br><span class="line"><span class="comment">   * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma[ˈkɒmə]逗号 followed by a</span></span><br><span class="line"><span class="comment">   * space).  Elements are converted to strings as by</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;String.valueOf(int)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt; is</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;null&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> a the array whose string representation to return</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a string representation of &lt;tt&gt;a&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  System.out.println(Arrays.toString(ints));</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>sort：排序（自然排序和定制排序）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sorts the specified array into ascending numerical order.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort(双枢轴快速排序)</span></span><br><span class="line"><span class="comment">   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. </span></span><br><span class="line"><span class="comment">   * This algorithm offers O(n log(n)) performance on many data sets(数据集) that cause other</span></span><br><span class="line"><span class="comment">   * quicksorts to degrade to quadratic performance, </span></span><br><span class="line"><span class="comment">   * 该算法在许多数据集上提供了O(n log(n))的性能，而这些数据集导致其他快速排序的性能下降到二次级</span></span><br><span class="line"><span class="comment">   * and is typically faster than traditional (one-pivot) Quicksort implementations.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span>[] arr1 = &#123;<span class="number">21</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  Arrays.sort(arr1);</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sort的定制排序(从大到小排序)</span></span><br><span class="line"><span class="comment">//体现接口编程的方式</span></span><br><span class="line"><span class="comment">//接口编程+动态绑定+匿名内部类的综合使用</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;Object&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">      Integer i1 = (Integer) o1;</span><br><span class="line">      Integer i2 = (Integer) o2;</span><br><span class="line">      <span class="keyword">return</span> i2 - i1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>binarySearch：通过二分搜索法进行查找，要求必须排好序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">int</span>[] arr = &#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">111</span>,<span class="number">123</span>,<span class="number">132</span>,<span class="number">1132</span>&#125;;</span><br><span class="line"> <span class="comment">/*binarySearch：只有已经排序好的数组可以使用该方法</span></span><br><span class="line"><span class="comment">  * @param a the array to be searched</span></span><br><span class="line"><span class="comment">  * @param key the value to be searched for</span></span><br><span class="line"><span class="comment">  * @return index of the search key, if it is contained in the array;</span></span><br><span class="line"><span class="comment">  *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</span></span><br><span class="line"><span class="comment">  *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</span></span><br><span class="line"><span class="comment">  *         key would be inserted into the array: the index of the first</span></span><br><span class="line"><span class="comment">  *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</span></span><br><span class="line"><span class="comment">  *         elements in the array are less than the specified key.  Note</span></span><br><span class="line"><span class="comment">  *         that this guarantees that the return value will be &amp;gt;= 0 if</span></span><br><span class="line"><span class="comment">  *         and only if the key is found.</span></span><br><span class="line"><span class="comment">  * 1.使用binarySearch二叉查找</span></span><br><span class="line"><span class="comment">  * 2.要求该数组有序的，如果该数组是无序的，不能使用binarySearch</span></span><br><span class="line"><span class="comment">  * 3.如果数组中不存在该元素，就返回 return -（low + 1）;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(Arrays.binarySearch(arr,<span class="number">123</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. copyOf：数组元素复制</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   /*</span><br><span class="line">    * @param original the array to be copied</span><br><span class="line">    * @param newLength the length of the copy to be returned</span><br><span class="line">    * @return a copy of the original array, truncated or padded with zeros</span><br><span class="line">    * to obtain the specified length</span><br><span class="line">    * 1.从数组arr中拷贝arr.length个元素到数组ints中</span><br><span class="line">    * 2.如果拷贝的长度 &gt; arr.length，就再新数组的后面 增加 null</span><br><span class="line">    * 3.该方法的底层使用的是 System.arraycopy()</span><br><span class="line">   */</span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">int[] ints = Arrays.copyOf(arr, 20);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br></pre></td></tr></table></figure></li><li><p>fill：数组填充</p></li><li><p>equals：比较俩个数组元素内容是否完全一致</p></li><li><p>asList：将一组值转换成list</p></li></ol><h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><ul><li><p>BigInteger和BigDecimal介绍</p><p>应用场景：</p><ol><li><p>BigInteger适合保存比较大的整数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bigInteger = <span class="keyword">new</span> BigInteger(<span class="string">&quot;11111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line">BigInteger bigInteger1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;8888888888888889&quot;</span>);</span><br><span class="line"><span class="comment">//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接进行+、-、*、/</span></span><br><span class="line">BigInteger bigInteger2 = bigInteger.add(bigInteger1);</span><br><span class="line">System.out.println(bigInteger2);</span><br><span class="line">BigInteger subtract = bigInteger.subtract(bigInteger1);</span><br><span class="line">BigInteger multiply = bigInteger.multiply(bigInteger1);</span><br><span class="line">BigInteger divide = bigInteger.divide(bigInteger1);</span><br></pre></td></tr></table></figure></li><li><p>BigDecimal适合保存精度较高的浮点型（小数）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当我们需要保存一个精度很高的数时，double不够用，可以用BigDecimal</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">12.111111111111111111111111111111111</span>;</span><br><span class="line">System.out.println(d);</span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.111111111111111111111111111111111&quot;</span>);</span><br><span class="line">System.out.println(bigDecimal);</span><br><span class="line"></span><br><span class="line">BigDecimal bigDecimal1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//可能抛出异常（除不尽）：java.lang.ArithmeticException:Non-terminating decimal expansion</span></span><br><span class="line">System.out.println(bigDecimal.divide(bigDecimal1));</span><br><span class="line"><span class="comment">//解决方法：在divide后指定一个精度即可</span></span><br><span class="line">System.out.println(bigDecimal.divide(bigDecimal1,BigDecimal.ROUND_CEILING));</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>前面我们保存多个数据使用的是数组，那么数组有什么不足之处呢？</p><ol><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行扩容并增加元素的——比较麻烦</li></ol><ul><li>集合<ol><li>可以动态保存任意多个对象，使用比较方便</li><li>提供了一系列方便的操作对象的方法：add、remove、set、get等</li><li>使用集合添加删除新元素——简洁</li></ol></li></ul><h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><ol><li>集合主要有两组（单列集合，双列集合）</li><li>Collection接口有两个重要子接口List Set，他们实现的子类都是单列集合</li><li>Map接口实现的子类是双列集合，存放K-V</li></ol><img src="..\Java基础查漏补缺\Collection继承体系图.png"/><img src="..\Java基础查漏补缺\Map继承体系图.png"/><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li><p>Collection接口实现类的特点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>collection实现子类可以存放多个元素，每个元素可以是Object</li><li>有些Collection的实现类，可以存放重复的元素，有些不可以</li><li>有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）</li><li>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</li></ol></li><li><p>Collection接口和常用方法</p><ol><li>add：添加单个元素</li><li>remove：删除指定元素</li><li>contains：查找元素是否存在</li><li>size：获取元素个数</li><li>isEmpty：判断是否为空</li><li>clear：清空</li><li>addAll：添加多个元素</li><li>containsAll：查找多个元素是否存在</li><li>removeAll：删除多个元素</li></ol></li><li><p>Collection接口遍历元素方式1——使用Iterator（迭代器）</p><ol><li><p>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</p></li><li><p>所有实现了Collection接口的集合类都有一个iterator（）方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</p></li><li><p>Iterator的结构</p></li><li><p>Iterator仅用于遍历集合，Iterator本身并不存放对象</p><img src="..\Java基础查漏补缺\迭代器的执行原理.png"/><img src="..\Java基础查漏补缺\Iterator接口方法.png"/><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器原理：</span></span><br><span class="line">Iterator iterator = coll.iterator();<span class="comment">//得到一个集合的迭代器</span></span><br><span class="line"><span class="comment">//hasNext()：判断是否还有下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  <span class="comment">//next()：1、指针下移2、将下移以后集合位置上元素返回</span></span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">iterator = col.iterator();</span><br></pre></td></tr></table></figure><p>注意：在调用it.next()方法之前必须调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</p><p>迭代器快捷键：itit</p></li></ol></li><li><p>Collection接口遍历对象方式2——增强for循环</p><p>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组。增强for底层仍然是迭代器，增强for也可以直接在数组使用</p><ul><li><p>基本语法</p><p>for（元素类型    元素名：集合名或数组名）{</p><p>​    访问元素</p><p>}</p></li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>List接口基本介绍</p><ul><li>List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li><li>JDK API中List接口常用的实现类有：ArrayList、LinkedList和Vector</li></ul></li><li><p>List接口的常用方法</p><p><strong>List集合里添加了一些根据索引来操作集合元素的方法</strong></p><ul><li>void add(int index, Object ele)：在index位置插入ele元素</li><li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来</li><li>Object get(int index)：获取指定index位置的元素</li><li>int indexOf(Object obj)：返回obj在当前集合中首次出现的位置</li><li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置</li><li>Object remove(int index)：移除指定index位置的元素，并返回此元素</li><li>Object set(int index, Object ele)：设置指定index位置的元素为ele</li><li>List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合</li></ul></li><li><p>List的三种遍历方式</p><ul><li>使用迭代器</li><li>使用增强for循环</li><li>使用普通for</li></ul></li></ul><ol><li><p>ArrayList</p><ul><li><p>ArrayList的注意事项</p><ul><li>permits all elements,including null,ArrayList可以加入null，并且可以加入多个</li><li>ArrayList是由数组来实现数组存储的</li><li>ArrayList基本等同于Vector，除了ArrayList是线程不安全的（执行效率高），在多线程情况下，不建议使用ArrayList</li></ul></li><li><p>ArrayList的底层操作机制源码分析（重点、难点）</p><ol><li><p>ArrayList中维护了一个Object[]类型的数组elementData。</p><p>transient Object【】 elementData；</p><p>transient：表示瞬间的，短暂的，表示该属性不会被序列化</p></li><li><p>当创建对象时，如果使用的时无参构造器，则初始elementData容器为0（jdk7是10）</p></li><li><p>当添加元素时，先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适的位置</p></li><li><p>如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍</p></li><li><p>如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity</p></li><li><p>如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍</p></li></ol></li></ul></li><li><p>LinkedList</p><ul><li><p>LinkedList的全面说明</p><ol><li>LinkedList实现了底层双向链表和双端队列的特点</li><li>可以添加任意元素（元素可以重复），包括null</li><li>线程不安全，没有实现同步</li></ol></li><li><p>LinkedList的底层操作机制</p><ol><li>LinkedList底层维护了一个双向链表</li><li>LinkedList中维护了两个属性，first和last，分别指向首节点和尾节点</li><li>每个节点（Node对象），里面又维护了prev、next、item三个属性，</li></ol></li></ul></li><li><p>Vector</p><ul><li><p>Vector的基本介绍</p><ol><li><p>Vecotr类的定义说明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></li><li><p>Vector底层也是一个对象数组，protected Object[] elementData</p></li><li><p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</p></li><li><p>在开发中，需要线程同步安全时，考虑使用Vector</p></li></ol></li><li><p>Vector和ArrayList的比较</p><table><thead><tr><th align="center"></th><th align="center">底层结构</th><th align="center">版本</th><th align="center">线程安全（同步）效率</th><th align="center">扩容倍数</th></tr></thead><tbody><tr><td align="center">ArrayList</td><td align="center">可变数组</td><td align="center">jdk1.2</td><td align="center">不安全，效率高</td><td align="center">如果是无参构造器，第一次10，第二次开始按1.5倍扩容；如果是有参构造器，根据capacity按2倍扩容</td></tr><tr><td align="center">Vector</td><td align="center">可变数组</td><td align="center">jdk1.0</td><td align="center">安全，效率不高</td><td align="center">如果是无参。默认10，满后，按两倍扩容；如果指定大小，则每次直接按2倍扩容</td></tr></tbody></table></li></ul></li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol><li>HashMap</li><li>Hashtable</li><li>LinkedHashMap</li><li>TreeMap</li><li>Properties</li></ol><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><h2 id="泛型继承和通配符"><a href="#泛型继承和通配符" class="headerlink" title="泛型继承和通配符"></a>泛型继承和通配符</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h2><h2 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h2><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><h3 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h3><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li><p>文件是什么</p><p>文件，我们并不陌生，文件是<strong>保存数据的地方</strong>，比如大家经常使用的word文档，txt文档，excel文件……都是文件。它既可以保存一张图片。也可以保存视频、声音……</p></li><li><p>文件流</p><p>文件在程序是以流的形式来操作的</p><img src="..\Java基础查漏补缺\文件流.png"/><p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p><p>输入流：数据从数据源（文件）到程序（内存）的路径</p><p>输出流：数据从程序（内存）到数据源（文件）的路径</p></li><li><p>创建文件对象相关构造器和方法</p><ul><li><p>相关方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(String pathName)<span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> File(File parent, String child)<span class="comment">//根据父目录文件+子路径构建</span></span><br><span class="line"><span class="keyword">new</span> File(String parent, String child)<span class="comment">//根据父目录+子路径构建</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//注意细节：d:\\不能写成d</span></span><br><span class="line"><span class="comment">//这里的file对象，在Java程序中只是一个对象</span></span><br><span class="line"><span class="comment">//只有执行了createNewFile方法，才会真正的在磁盘中创建该文件</span></span><br><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;./testio2.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file1.createNewFile()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;创建testio2成功！！！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取文件的相关信息</p><p>getName、getAbsolutePath、getParent、length(文件大小)、exists、isFile、isDirectory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;文件名：&quot;</span>+file.getName());</span><br><span class="line">System.out.println(<span class="string">&quot;绝对路径：&quot;</span>+file.getAbsoluteFile());</span><br><span class="line">System.out.println(<span class="string">&quot;是否存在：&quot;</span>+file.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;父目录的绝对路径：&quot;</span>+file.getParent());</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小：&quot;</span>+file.length());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是文件：&quot;</span>+file.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是目录：&quot;</span>+file.isDirectory());</span><br></pre></td></tr></table></figure></li><li><p>目录的操作和文件删除</p><p>mkdir：创建一级目录、mkdirs：创建多级目录、delete：删除空目录或文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\demo\\a\\b\\c&quot;</span>);</span><br><span class="line"><span class="comment">//判断d:\\demo\\a\\b\\c目录是否存在，如果存在就提示已经存在，否则就创建</span></span><br><span class="line"><span class="keyword">if</span> (file2.exists()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;d:\\demo\\a\\b\\c文件存在,不用创建&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file2.mkdirs()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\demo\\a\\b\\c文件创建成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\demo\\a\\b\\c文件创建失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deleteFile(file2);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不存在该文件！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.delete())&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><ul><li><p>Java IO流原理</p><ol><li>I/O是Input/Output的缩写，I/O技术是非常使用的技术，用于处理数据传输，如读/写文件，网络通讯等</li><li>Java程序中。对于数据的输入/输出操作以”流（Stream）“的方式进行</li><li>java.io包下提供了各种”流“类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li><li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li><li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li></ol></li><li><p>流的分类</p><ul><li><p>按操作数据单位不同分为：字节流（8bit）（二进制文件），字符流（按字符）（文本文件）</p></li><li><p>按数据流的流向不同分为：输入流，输出流</p></li><li><p>按流的角色的不同分为：节点流、处理流/包装流</p><table><thead><tr><th align="center">（抽象基类）</th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">输入流</td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center">输出流</td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><ol><li>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的</li><li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</li></ol></li></ul></li></ul><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><ul><li><p>基本介绍</p><ol><li><p>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</p><img src="..\Java基础查漏补缺\节点流.png"/></li><li><p>处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，BufferedReader、BufferedWriter</p><img src="..\Java基础查漏补缺\处理流.png"/></li></ol></li></ul><ul><li><p>节点流和处理流一览图</p><img src="..\Java基础查漏补缺\节点流处理流一览图.png"/></li><li><p>节点流和处理流的区别和联系</p><ol><li>节点流是底层流/低级流，直接跟数据源相接</li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相接</li></ol></li><li><p>处理流的功能主要体现在以下两个方面：</p><ol><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率。</li><li>操作的便捷：处理流可能提供了一系列便捷的方法来一次性输入输出大批量数据，使用更加灵活方便</li></ol></li><li><p>处理流——BufferedReader和BufferedWriter</p><ol><li>BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的</li><li>关闭时，只需要关闭外层流即可</li></ol></li><li><p>处理流——BufferedInputStream和BufferedOutputStream</p><p>BufferedInputStream是字节流，在创建BufferedInputStream时，会创建一个内部缓冲区数组</p><p>BufferedOutputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统</p></li><li><p>对象流——ObjectInputStream和ObjectOutputStream</p><ul><li>看一个需求<ol><li>将int num = 100这个int数据保存到文件中，注意不是100数字，而是int 100，并且能够从文件中直接恢复int 100</li><li>将Dog dog=new Dog(“小黄”，3)这个Dog对象保存到文件中，并且能够从文件中恢复</li><li>上面的要求，就是能够将基本数据类型或者对象进行序列化和反序列化操作</li></ol></li><li>序列化和反序列化<ol><li>序列化就是在保存数据时，保存数据的值和数据类型</li><li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：<ul><li>Serializable//这是一个标记接口（没有方法）</li><li>Externalizable//该接口有方法要实现，因此我们一般实现上面的</li></ul></li></ol></li><li>基本介绍<ol><li>功能：提供了对基本数据类型或对象类型序列化或反序列化的方法</li><li>ObjectOutputStream提供序列化功能</li><li>ObjectInputStream提供反序列化功能</li></ol></li><li>注意事项和细节说明<ol><li>读写顺序要一致</li><li>要求实现序列化或反序列化的对象，需要实现Serialzable</li><li>序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性</li><li>序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li></ol></li></ul></li><li><p>标准输入输出流</p><ul><li><p>介绍</p><table><thead><tr><th align="center"></th><th align="center">类型</th><th align="center">默认设备</th></tr></thead><tbody><tr><td align="center">System.in标准输入</td><td align="center">InputStream</td><td align="center">键盘</td></tr><tr><td align="center">System.out标准输出</td><td align="center">PrintStream</td><td align="center">显示器</td></tr></tbody></table></li><li><p>标准输入输出流</p><ul><li><p>案例1</p><p>传统方法<code>System.out.println(&quot;&quot;);</code>是使用out对象将数据输出到显示器</p></li><li><p>案例2</p><p>传统的方法：Scanner是从标准输入键盘接收数据</p></li></ul></li></ul></li><li><p>转换流——InputStreamReader和OutputStreamWriter</p><ul><li>介绍<ol><li>InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</li><li>OutputStreamWriter：Writer的子类，实现将OutputStream（字节流）包装成Writer（字符流）</li><li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流</li><li>可以在使用时，指定编码格式（比如：utf-8，gbk，gb2312，ISO8859-1等）</li></ol></li></ul></li><li><p>打印流——PrintStream和PrintWriter</p><p>打印流只有输出流，没有输入流</p></li></ul><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>InputStream(字节输入流)抽象类是所有类字节输入流的超类</p><img src="..\Java基础查漏补缺\InputStream.png"/><ol><li><p>FileInputStream（文件输入流）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求：请使用FileInputStream读取testio2.txt文件，</span></span><br><span class="line"><span class="comment">// 并将文件内容显示到控制台</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prac</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建FileInputStream对象，用于读取文件</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\testio2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> readData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从该输入流读取一个字节的数据，如果没有输入可用，此方法将阻止</span></span><br><span class="line">        <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">        <span class="comment">//read()是一个字节一个字节读取，利用utf8读取汉字必然出错，</span></span><br><span class="line">        <span class="comment">//因为此时汉字由三个字节组成</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)readData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭文件流释放资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文件：利用read(new Byte[])</span></span><br><span class="line"><span class="comment">//read(new Byte[]):返回读取的字节数量或-1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prac2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];<span class="comment">//每次读取8个字节</span></span><br><span class="line">    <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\testio2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BufferedInputStream（缓冲字节输入流）</p></li><li><p>ObjectInputStream（对象字节输入流）</p></li></ol><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><ol><li><p>FileReader</p><p>FileReader和FileWriter是字符流，即按照字符来操作io</p><p>FileReader相关方法：</p><ul><li>new FileReader(File/String)</li><li>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</li><li>read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li></ul><p>相关API：</p><ul><li>new String(char[])：将char[]转换成String</li><li>new String(char[],off,len)：将char[]的指定部分转换成String</li></ul></li><li><p>BufferedReader</p></li><li><p>InputStreamReader</p></li></ol><p>##输出流</p><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><ol><li><p>FileOutputStream</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件写入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    String pathName = <span class="string">&quot;d:\\testio.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(pathName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不需要创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//构造对象，准备对文件就行操作</span></span><br><span class="line">        <span class="comment">//fos = new FileOutputStream(pathName);//默认写入内容时，进行覆盖</span></span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(pathName,<span class="keyword">true</span>);<span class="comment">//append为true时，进行追加</span></span><br><span class="line">        String str = <span class="string">&quot;hhhhhh&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        <span class="comment">//fos.write(&#x27;h&#x27;);</span></span><br><span class="line">        <span class="comment">//fos.write(&quot;sdasasa流域aaaa&quot;.getBytes());</span></span><br><span class="line">        <span class="comment">//将字节数组，从偏移量offset开始的指定数组写入到此文件输入流中</span></span><br><span class="line">        fos.write(bytes,<span class="number">2</span>,bytes.length-<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完成图片的拷贝</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\明日香.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\temp\\明日香.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1.读取要拷贝的数据</span></span><br><span class="line">        <span class="comment">//2.向指定文件写入数据</span></span><br><span class="line">        <span class="keyword">while</span>((readLen = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//String str = new String(buf,0,readLen);</span></span><br><span class="line">            <span class="comment">//fos.write(str.getBytes());</span></span><br><span class="line">            fos.write(buf,<span class="number">0</span>,readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BufferedOutputStream</p></li><li><p>ObjectOutputStream</p></li></ol><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><ol><li><p>FileWriter</p><p>FileWriter常用方法</p><ul><li>new FileWriter(File/String)：覆盖模式，相当于流的指针在首端</li><li>new FileWriter(File/String，true)：追加模式，相当于流的指针在尾端</li><li>write(int)：写入单个字符</li><li>write(char[])：写入指定数组</li><li>write(char[],off,len)：写入指定数组的指定部分</li><li>write(string)：写入整个字符串</li><li>write(string,off,len)：写入字符串的指定部分</li></ul><p>相关API：Stirng类：toCharArray：将String转换成char[]</p><p>FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件中</p></li><li><p>BufferedWriter</p></li><li><p>OutputStreamWriter</p></li></ol><h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2><ul><li><p>引入</p><p>如下一个配置文件mysql.properties</p><p>ip = 192.168.0.13</p><p>user = root</p><p>pwd = 12345</p><p>请问编程读取ip、user和pwd的值是多少</p><p>分析：</p><p>1、传统的方法</p><p>2、使用Properties类可以方便实现</p></li><li><p>基本介绍</p><ol><li><p>专门用于读写配置文件的集合类</p><p>配置文件的格式：</p><p>键 = 值</p><p>键 = 值</p></li><li><p>注意：键值对不需要又空格，值不需要用引号一起来，默认类型是String</p></li><li><p>Properties的常见方法</p><p>load：加载配置文件的键值对到Properties对象</p><p>list：将数据显示到指定设备/流对象</p><p>getProperty(key)：根据键获取值</p><p>setProperty(key,value)：设置键值对到Properties对象</p><p>store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</p><p><a href="http://tool.chinaz.com/tools/unicode.aspx">unicode码查询工具</a></p></li></ol></li></ul><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h2 id="反射获取类的结构信息"><a href="#反射获取类的结构信息" class="headerlink" title="反射获取类的结构信息"></a>反射获取类的结构信息</h2><ol><li>Class</li><li>Field</li><li>Method</li><li>Constructor</li><li>访问属性</li><li>访问方法</li></ol><h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p>为什么要学习数据库？</p><p>引出（一个问题）：</p><p>淘宝、京东、微信、抖音都有各自的功能，那么当我们退出系统的时候，下次再访问时，为什么信息还存在？</p><p>答：数据库，可以更有效的管理数据</p><h2 id="MySQL安装和配置"><a href="#MySQL安装和配置" class="headerlink" title="MySQL安装和配置"></a>MySQL安装和配置</h2><ul><li><p>使用命令行窗口连接Mysql数据库</p><ol><li><p><code> mysql -h 主机名 -P 端口 -u用户名 -p密码</code></p></li><li><p>登陆前保证服务启动</p><p>启动mysql数据库的常用方式【Dos命令】</p><ul><li>服务方式启动（界面）</li><li><code>net stop mysql（服务名）</code></li><li><code>net start mysql（服务名）</code></li></ul></li></ol></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><p>数据库三层结构——破除MySQL神秘</p><ol><li><p>所谓安装MySQL数据库，就是在主机上安装一个数据库管理系统（DBMS），这个管理程序可以管理多个数据库。DBMS（database manage system）</p></li><li><p>一个数据库中可以创建多个表，以保存数据（信息）</p></li><li><p>数据库管理系统（DBMS）、数据库和表的关系如图所示：</p><img src="..\Java基础查漏补缺\MySQL三层结构.png"/></li></ol></li></ul><p>MySQL数据库——<strong>普通表的本质仍然是文件</strong></p><ul><li><p>SQL语句分类</p><p>DDL：数据定义语言（create 表、库……）</p><p>DML：数据操作语句（增加insert、修改update、删除delete）</p><p>DQL：数据查询语言（select）</p><p>DCL：数据控制语言（管理数据库：比如用户权限 grant revoke）</p></li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] db_name</span><br><span class="line">[create_specification...]</span><br><span class="line"></span><br><span class="line">create_specification:</span><br><span class="line">[DEFAULT] CHARACTER SET charset_name</span><br><span class="line">[DEFAULT] COLLATE collation_name</span><br></pre></td></tr></table></figure><ol><li>CHARACTER SET：指定数据库采用的字符集，如果不指定字符集，默认utf8</li><li>COLLATE：指定数据库字符集的校对规则（常用的utf8_bin【区分大小写】、utf8_general_ci【不区分大小写】【默认utf8_general_ci】）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个使用utf8字符集，并带校对规则的hsp_db数据库</span><br><span class="line">CREATE DATABASE hsp_db CHARACTER SET utf8 COLLATE utf8_bin;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看、删除数据库"><a href="#查看、删除数据库" class="headerlink" title="查看、删除数据库"></a>查看、删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"># 显示某个数据库的创建语句</span><br><span class="line"># 查看前面创建的数据库的定义信息</span><br><span class="line">SHOW CREATE DATABASE db_name;</span><br><span class="line">#数据库删除语句</span><br><span class="line">DROP DATABASE [IF EXISTS] db_name;</span><br></pre></td></tr></table></figure><h3 id="备份恢复数据库"><a href="#备份恢复数据库" class="headerlink" title="备份恢复数据库"></a>备份恢复数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份hsp_db02和hsp_db03库中的数据，并恢复</span><br><span class="line"># 备份要在Dos下执行mysqldump指令其实在mysql安装目录\bin</span><br><span class="line"># 这个备份的文件，就是对应的sql语句</span><br><span class="line"># -B：表示接下来的内容都是数据库名称</span><br><span class="line">mysqldump -u root -p -B hsp_db02 hsp_db03 &gt; d:\\bak.sql</span><br><span class="line"></span><br><span class="line"># 恢复数据库（注意：进入MySQL命令行再执行）</span><br><span class="line">source d:\\bak.sql</span><br><span class="line"># 第二种恢复方法</span><br><span class="line"># 直接将bak.sql的内容放到查询编辑器中，执行</span><br><span class="line"></span><br><span class="line"># 备份数据库中的表</span><br><span class="line">mysqldump -u 用户名 -p密码 数据库 表1 表2 表n &gt; d:\\文件名.sql</span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">field1 datatype,</span><br><span class="line">    field2 datatype,</span><br><span class="line">    field3 datatype</span><br><span class="line">)character set 字符集 collate 校验规则 engine 存储引擎; </span><br><span class="line"></span><br><span class="line">############</span><br><span class="line"># field：指定列名datatype：指定列类型（字段类型）</span><br><span class="line"># character set：如不指定，则为所在数据库字符集</span><br><span class="line"># collate：如不指定，则为所在数据库的校验规则</span><br><span class="line"># engine：引擎（这个涉及内容较多，后面单独讲解）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示表的结构</span><br><span class="line">desc tableName;</span><br></pre></td></tr></table></figure><p>练习：</p><p>创建一个员工表emp，选用适当的数据类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">    id INT UNSIGNED,</span><br><span class="line">    `name` VARCHAR(20),</span><br><span class="line">    sex BIT(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATE,</span><br><span class="line">    job VARCHAR(200),</span><br><span class="line">    salary FLOAT unsigned,</span><br><span class="line">    `resume` TEXT </span><br><span class="line">) CHARSET utf8 COLLATE utf8_general_ic ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp VALUES(1,&#x27;海绵宝宝&#x27;,1,&#x27;2011-1-1&#x27;,&#x27;2021-1-1&#x27;,&#x27;蟹王堡面点师&#x27;,100.1,&#x27;是派大星的朋友&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除列</span><br><span class="line">alter table table1_name</span><br><span class="line">drop (column);</span><br></pre></td></tr></table></figure><ul><li><p>删除sex列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">drop sex;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 追加列</span><br><span class="line">alter table tablename</span><br><span class="line">add (colum datatype [default expr],</span><br><span class="line">         colum datatype</span><br><span class="line">         ......);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改列</span><br><span class="line">alter table tablename</span><br><span class="line">modify (colum datatype [default expr],</span><br><span class="line">         colum datatype</span><br><span class="line">         ......);</span><br></pre></td></tr></table></figure><ul><li><p>在员工表emp上增加一个image列，varchar类型（要求在resume后面）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp </span><br><span class="line">add image varchar(32) not null default &#x27;&#x27; </span><br><span class="line">after `resume`;</span><br></pre></td></tr></table></figure></li><li><p>修改job列，使其长度为60</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">modify job varchar(60) not null default &#x27;&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>表名改为employee</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename table emp to employee;</span><br></pre></td></tr></table></figure></li><li><p>修改表的字符集为utf8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee character set utf8;</span><br></pre></td></tr></table></figure></li><li><p>列名name修改为user_name</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee</span><br><span class="line">change name user_name varchar(50) not null default &#x27;&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MySQL数据类型-列类型"><a href="#MySQL数据类型-列类型" class="headerlink" title="MySQL数据类型(列类型)"></a>MySQL数据类型(列类型)</h2><img src="..\Java基础查漏补缺\MySQL常用数据类型.png"/><img src="..\Java基础查漏补缺\MySQL列类型1.png"/><img src="..\Java基础查漏补缺\MySQL列类型2.png"/><ul><li><p>数值型（整数）的基本使用</p><ol><li><p>说明，使用规范：在能够满足需求的情况下，尽量选择占用空间小的类型</p></li><li><p>应用实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1 (</span><br><span class="line">    id TINYINT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test1(id) VALUE(128);</span><br><span class="line"></span><br><span class="line">SELECT id FROM test1;</span><br><span class="line"># ============================</span><br><span class="line">CREATE TABLE test2 (</span><br><span class="line">    id TINYINT UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test2(id) VALUE(128);</span><br><span class="line"></span><br><span class="line">SELECT id FROM test2; </span><br></pre></td></tr></table></figure></li></ol></li><li><p>数值型（bit）的使用</p><ol><li><p>基本使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test3 (</span><br><span class="line">    num BIT(8)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test3(num) VALUE(1);</span><br><span class="line"></span><br><span class="line">SELECT num FROM test3; </span><br><span class="line"></span><br><span class="line">SELECT num FROM test3 WHERE num = 1;</span><br></pre></td></tr></table></figure></li><li><p>细节说明</p><ul><li>bit字段显示时，按照<strong>位的方式显示</strong></li><li>查询的时候仍然可以使用添加的数值</li><li>如果一个值只有0、1，可以考虑使用bit（1），可以节约空间</li><li>位类型。M指定位数，默认值1，范围1-64</li><li>使用不多</li></ul></li></ol></li><li><p>数值型（小数）的基本使用</p><ol><li><p>FLOAT/DOUBLE[UNSIGNED]</p><p>Float单精度精度，Double双精度精度</p></li><li><p>DECIMAL[M,D] [UNSIGNED]</p><ul><li>可以支持更加精确的小数位。M时小数位数（精度）的总数，D是小数点（标度）后面的位数</li><li>如果D是0，则值没有小数点或分数部分。M最大65。D最大是30。如果D被省略，默认是0，如果M被省略，默认是10。</li><li>建议：如果希望小数的精度高，推荐使用decimal</li></ul></li></ol></li><li><p>字符串的基本使用</p><p>CHAR（size）</p><p>固定长度字符串    最大255<strong>字符</strong></p><p>VARCHAR（size）    65535 - <strong>3（用于记录字段大小）</strong></p><p>可变长度字符串    最大65532<strong>字节</strong>（utf8编码最大21844【65532/3】字符    1-3字节用于记录大小）</p><p>字符串使用细节</p><ol><li><p>细节一</p><p>char（4）//这个4表示字符数（最大255），不是字节数，不管是中文还是字母都是放四个，按字符计算</p><p>varchar（4）//这个4表示字符数，不管是字母还是中文都以定义好的表的编码来存放数据</p><p>不管是中文还是英文字母，都是最多存放4个，是按照字符来存放的</p></li><li><p>char（4）是定长，就是说，即使你插入‘aa’，也会占用分配的4个字符</p><p>varchar（4）是变长，就是说，如果你插入‘aa‘，实际占用空间大小并不是4个字符，而是按照实际占用空间来分配（老汉说明：varchar本身还需要占用1-3个字节来记录存放内容长度）</p></li><li><p>什么时候使用char，什么时候使用varchar</p><ul><li>如果数据是定长，推荐使用char，比如md5的密码、邮编、手机号、身份证号码等</li><li>如果一个字段的长度是不确定的，我们使用varchar，比如留言，文章</li><li>查询速度：char &gt; varchar</li></ul></li><li><p>在存放文本时，也可以使用Text数据类型，可以将TEXT列视为VARCHAR列，注意Text不能有默认值，大小0 - 2^16字节，如果希望存放更多字符，可以选择MEDIUMTEXT(0– 2^24)或者LONGTEXT（0 – 2^32）</p></li></ol></li><li><p>日期类型的基本使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE birthday6 (</span><br><span class="line">    t1 DATE,</span><br><span class="line">    t2 DATETIME,</span><br><span class="line">    t3 TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO birthday6(t1,t2) VALUES(&#x27;2022-11-11&#x27;,&#x27;2022-11-11 10:10:11&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM birthday6;</span><br><span class="line">#############################</span><br><span class="line"># 添加时，如果没有添加时间，默认使用当前时间</span><br><span class="line"># 更新时，自动会使用当前时间对该字段进行更新</span><br><span class="line">NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br></pre></td></tr></table></figure></li><li><p>日期类型的细节说明</p><p>timestamp在insert和update时，自动更新</p><p><code>NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code></p></li></ul><h2 id="C-create-R-read-U-update-D-delete"><a href="#C-create-R-read-U-update-D-delete" class="headerlink" title="C[create]R[read]U[update]D[delete]"></a>C[create]R[read]U[update]D[delete]</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><ul><li><p>使用INSERT语句向表中插入数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name[(column [,column...])]</span><br><span class="line">VALUES (`value` [,`value`]);</span><br></pre></td></tr></table></figure></li><li><p>细节说明</p><ol><li><p>插入的数据应与字段的数据类型相同</p><p>比如把’abc‘添加到int类型会错误</p></li><li><p>数据的长度应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中</p></li><li><p>在values中列出的数据位置必须与被加入的列的排列位置相对应</p></li><li><p>字符和日期型数据应包含在单引号中</p></li><li><p>列可以插入空值【前提是该字段允许为空】</p><p>insert into table value（null）；</p></li><li><p>insert into table_name（列名…）values（）（）…形式添加多条记录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">    id INT UNSIGNED,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE UNSIGNED</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO goods(id,goods_name,price) </span><br><span class="line">VALUES(3,&#x27;可乐&#x27;,3.5),(4,&#x27;芬达&#x27;,6.5);</span><br></pre></td></tr></table></figure></li><li><p>如果是给表中的所有字段添加数据，可以不写前面的字段名称</p></li><li><p>默认值的使用，当不给某个字段值时，如果有默认值就会添加，否则报错</p><p>如果某个列没有指定not null，那么当添加数据时，没有给定值，则会默认给null</p></li></ol></li></ul><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><ul><li><p>使用update语句修改表中的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table1_name</span><br><span class="line">set col_name = expr1[,col_name2 = expr2]</span><br><span class="line">[where where_definition];</span><br></pre></td></tr></table></figure></li><li><p>基本使用</p><p>要求:在上面创建的employee表中修改表中的记录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">    id INT UNSIGNED,</span><br><span class="line">    `name` VARCHAR(20),</span><br><span class="line">    sex BIT(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATE,</span><br><span class="line">    job VARCHAR(200),</span><br><span class="line">    salary FLOAT unsigned,</span><br><span class="line">    `resume` TEXT </span><br><span class="line">) CHARSET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp </span><br><span class="line">VALUES(2,&#x27;小妖怪&#x27;,0,&#x27;1000-1-1&#x27;,&#x27;1024-1-1&#x27;,&#x27;巡山小喽啰&#x27;,1000,&#x27;银角大王的属下&#x27;),</span><br><span class="line">(3,&#x27;小妖怪&#x27;,0,&#x27;1000-1-1&#x27;,&#x27;1024-1-1&#x27;,&#x27;巡山小喽啰&#x27;,1001,&#x27;银角大王的属下&#x27;),</span><br><span class="line">(4,&#x27;小妖怪&#x27;,0,&#x27;1000-1-1&#x27;,&#x27;1024-1-1&#x27;,&#x27;巡山小喽啰&#x27;,1000,&#x27;银角大王的属下&#x27;),</span><br><span class="line">(5,&#x27;老妖怪&#x27;,1,&#x27;900-1-1&#x27;,&#x27;924-1-1&#x27;,&#x27;巡山大喽啰&#x27;,1000,&#x27;银角大王的中层干部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 将所有员工薪水修改为5000元</span><br><span class="line">UPDATE emp</span><br><span class="line">SET salary = 5000;</span><br><span class="line">-- 将所有姓名为小妖怪的员工薪水修改为3000元</span><br><span class="line">UPDATE emp</span><br><span class="line">SET salary = 3000</span><br><span class="line">WHERE `name` = &#x27;小妖怪&#x27;;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000元</span><br><span class="line">UPDATE emp</span><br><span class="line">SET salary = salary+1000</span><br><span class="line">WHERE `name` = &#x27;老妖怪&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>使用细节</p><ol><li>UPDATE语法可以用新值更新原有表行中的各列</li><li>SET子句指示要修改哪些列和要给予哪些值</li><li>WHERE子句指定应更新那些行。如没有WHERE子句，则更新所有的行</li><li>如果需要修改多个字段，可以通过set 字段1=值1，字段2=值2……</li></ol></li></ul><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><ul><li><p>使用delete语句删除表中的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from table1_name</span><br><span class="line">[where where_definition];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除表中名为老妖怪的记录</span><br><span class="line">delete from emp </span><br><span class="line">where `name` = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">delete from emp;</span><br></pre></td></tr></table></figure></li><li><p>使用细节</p><ol><li>如果不使用where子句，将删除表中的所有数据</li><li>delete语句不能删除某一列的值（可使用update设为null或者’‘）</li><li>使用delete语句仅删除记录，不删除表本身，如要删除表，使用drop table语句。drop table 表名；</li></ol></li></ul><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><ol><li><p>单表</p><ul><li><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select [distinct] *|&#123;column1,column2,column3...&#125; from table1_name;</span><br></pre></td></tr></table></figure><p>在select语句中可使用as语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column_name as 别名 from 表名;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>select指定查询哪些列的数据</li><li>column指定列名</li><li>*号代表所有列，表名 . *表示将该表所有列都显示出来</li><li>from指定查询哪张表</li><li>distinct可选，指显示结果时，是否去掉重复数据</li></ul></li><li><p>在where子句中经常使用的运算符</p><table><thead><tr><th align="center">比较运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;   &lt;   &lt;=   &gt;=   =   &lt;&gt;   !=</td><td align="center">大于、小于、大于等于、小于等于、不等于</td></tr><tr><td align="center">BTETWEEN…AND…</td><td align="center">显示在某一区间的值(闭区间)</td></tr><tr><td align="center">IN（set）</td><td align="center">显示在in列表中的值，例：in(100,20)</td></tr><tr><td align="center">LIKE ’张pattern‘       Not LIKE ’ ‘</td><td align="center">模糊查询</td></tr><tr><td align="center">is null</td><td align="center">判断是否为空</td></tr></tbody></table><table><thead><tr><th align="center">逻辑运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">多个条件同时为空</td></tr><tr><td align="center">or</td><td align="center">多个条件任意成立</td></tr><tr><td align="center">not</td><td align="center">不成立，例：where not(salary&gt;100);</td></tr></tbody></table></li><li><p>使用order by子句排序查询结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2,column3...</span><br><span class="line">from table1_name</span><br><span class="line">order by colum asc|desc;</span><br><span class="line"></span><br><span class="line">-- 1.order by指定排序的列，排序的列既可以是表中的列名，也可以是select语句后指定的列名</span><br><span class="line">-- 2.asc升序（默认）、desc降序</span><br><span class="line">-- 3.order by 子句应位于select语句的结尾</span><br></pre></td></tr></table></figure></li><li><p>使用group by子句对列进行分组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2…… from tableName</span><br><span class="line">group by column_;</span><br></pre></td></tr></table></figure></li><li><p>使用having子句对<code>分组后的结果</code>进行过滤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2…… from tableName</span><br><span class="line">group by column_ having ……;</span><br></pre></td></tr></table></figure><ul><li><p>显示<code>每个部门的</code>平均工资和最高工资</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select department_name,avg(salary),max(salary) from department group by department_name;</span><br></pre></td></tr></table></figure></li><li><p>显示<code>每个部门的</code> <code>每种岗位的</code>平均工资和最低工资</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select department_name,job,avg(salary),min(salary) from department group by department_name,job;</span><br></pre></td></tr></table></figure></li><li><p>显示<code>平均工资低于2000的</code>部门号和它的平均工资</p><ol><li><p>显示每个部门的部门号和它的平均工资</p></li><li><p>筛选出平均工资低于2000的</p></li><li><p>使用别名进行过滤</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select department_id,avg(salary) as avg_sal from department group by department_id having avg_sal &lt; 2000;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单表查询加强</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何查询2022-01-01后入职的员工</span><br><span class="line">select * from emp</span><br><span class="line">where hiredate &gt; &#x27;2022-01-01&#x27;;</span><br><span class="line">-- 如何使用like操作符</span><br><span class="line">-- %：表述0到多个任意字符</span><br><span class="line">-- _：表示单个任意字符</span><br><span class="line">-- 如何显示姓王的员工和介绍</span><br><span class="line">SELECT `name`,intro FROM edu_teacher</span><br><span class="line">WHERE `name` LIKE &#x27;王%&#x27;;</span><br><span class="line">-- 如何显示第三个字符为大写O的所有员工的姓名和工资</span><br><span class="line">SELECT `name`,intro FROM edu_teacher</span><br><span class="line">WHERE `name` LIKE &#x27;__O%&#x27;;</span><br><span class="line">-- 查询表的结构</span><br><span class="line">desc edu_teacher;</span><br><span class="line">-- 按照部门号升序而雇员的工资降序排列，显示雇员信息</span><br><span class="line">select * from emp</span><br><span class="line">order by deptno asc, sal desc;</span><br></pre></td></tr></table></figure><ul><li><p>MySQL表查询——加强(分页)</p><ol><li><p>按雇员的id号升序取出，每页显示3条记录，请分别显示第一页，第二页，第三页</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 第一页</span><br><span class="line">select * from emp </span><br><span class="line">order by id asc </span><br><span class="line">limit 0,3;</span><br><span class="line">-- 第二页</span><br><span class="line">select * from emp </span><br><span class="line">order by id asc </span><br><span class="line">limit 3,3;</span><br><span class="line">-- 第三页</span><br><span class="line">select * from emp </span><br><span class="line">order by id asc </span><br><span class="line">limit 6,3;</span><br><span class="line">-- 推导一个公式</span><br><span class="line">select * from emp</span><br><span class="line">order by id asc</span><br><span class="line">limit 每页显示记录数*（第几页-1）, 每页显示记录数;</span><br></pre></td></tr></table></figure></li><li><p>基本语法：select…… limit start， rows</p><p>表示从start+1行开始取，取出rows行，start从0开始计算</p></li><li><p>课堂练习：按雇员的empno号降序取出，每页显示5条记录，请分别显示第三页，第五页对应的sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 第三页</span><br><span class="line">select * from emp</span><br><span class="line">order by empno desc</span><br><span class="line">limit 10, 5;</span><br><span class="line">-- 第五页</span><br><span class="line">select * from emp</span><br><span class="line">order by empno desc</span><br><span class="line">limit 20, 5;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用分组函数和分组子句group by</p><ol><li><p>显示每种岗位的雇员总数、平均工资</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) as 雇员总数,avg(sal) as 平均工资 from emp group by job;</span><br></pre></td></tr></table></figure></li><li><p>显示雇员总数，以及获得补助的雇员数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) as 雇员总数,count(comm) as 获得补助的雇员数 from emp;</span><br></pre></td></tr></table></figure></li><li><p>显示管理者的总人数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct mgr) as 管理者总人数 from emp;</span><br></pre></td></tr></table></figure></li><li><p>显示雇员工资的最大差额</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(sal)-min(sal) as 最大差额 from emp;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>数据分组的总结</p><p>如果select语句同时包含group by,having,order by,limit</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column1,column2,column3... from tab_name</span><br><span class="line">group by columnn</span><br><span class="line">having conditionn</span><br><span class="line">order by columnn</span><br><span class="line">limit startn,rows;</span><br></pre></td></tr></table></figure><p>请统计各个部门的平均工资，并且是大于1000的，并且按照平均工资从高到低排序，取出前两行记录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select deptno,avg(sal) as avg_sal from emp </span><br><span class="line">group by location</span><br><span class="line">having avg_sal&gt;1000</span><br><span class="line">    order by avg_sal desc</span><br><span class="line">    limit 0,2;</span><br></pre></td></tr></table></figure></li><li><p>多表</p><p>多表查询是指基于两个和两个以上的表查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp,dept;</span><br></pre></td></tr></table></figure><p>在默认情况下：当对两个表进行查询时，规则：</p><ol><li>从第一张表中，取出一行和第二张表的每一行进行组合，返回结果【含有两张表的所有列】</li><li>一共返回的记录数：第一张表行数*第二张表的行数</li><li>这样多表查询默认处理返回的结果，称为笛卡尔集</li><li>解决这个多表的关键就是要写出正确的过滤条件where</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal,dname,emp.deptno</span><br><span class="line">from emp,dept</span><br><span class="line">where emp.deptno = dept.deptno;</span><br></pre></td></tr></table></figure><p>老汉小技巧：多表查询的条件不能少于<strong>表的个数-1</strong>，否则会出现笛卡尔积</p></li></ol><ul><li><p>自连接</p><p>自连接是指在同一张表的连接查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 显示公司员工名字和他的上级的名字</span><br><span class="line">select worker.ename as 员工名,boss.ename as 上级 </span><br><span class="line">from emp worker,emp boss</span><br><span class="line">where worker.mgr = boss.empno;</span><br></pre></td></tr></table></figure><p>自连接的特点：</p><ol><li>把同一张表当作两张表使用</li><li>需要给表取别名</li><li>列名不明确。可以指定列的别名</li></ol></li><li><p>MySQL表子查询</p><ul><li><p>什么是子查询</p><p>子查询是指嵌入在其他SQL语句中的select语句，也叫嵌套语句</p></li><li><p>单行子查询</p><p>单行子查询是指只返回一行数据的子查询语句</p><p>请思考：如何显示与SMITH同一部门的所有员工？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp </span><br><span class="line">where deptno = (select deptno from emp where ename = &#x27;SMITH&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>多行子查询</p><p>多行子查询指返回多行数据的子查询    使用关键字in</p><p>课堂练习：如何查询和部门10的工作相同的雇员的名字、岗位、工资、部门号，但是不含10号部门自己的雇员</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.查询到10号部门有那些工作</span><br><span class="line">select distinct job</span><br><span class="line">from emp</span><br><span class="line">where deptno = 10;</span><br><span class="line">-- 2.把上面查询的结果当作子查询使用</span><br><span class="line">select ename,job,sal,deptno from emp</span><br><span class="line">where job in (select distinct job from emp where deptno = 10)</span><br><span class="line">and deptno != 10;</span><br></pre></td></tr></table></figure><ul><li><p>可以把子查询当作一张临时表使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在from子句中使用子查询</span><br><span class="line">  </span><br><span class="line">  -- 查询每个部门工资高于本部门平均工资的人的资料</span><br><span class="line">  -- 部门号和每个部门的平均工资</span><br><span class="line">  SELECT deptno, AVG(sal) AS avg_sal </span><br><span class="line">  FROM emp </span><br><span class="line">GROUP BY deptno;</span><br><span class="line">  -- 查询</span><br><span class="line">SELECT ename,sal,avg_sal,emp.deptno </span><br><span class="line">  FROM emp,(</span><br><span class="line">  SELECT deptno, AVG(sal) AS avg_sal </span><br><span class="line">  FROM emp </span><br><span class="line">  GROUP BY emp.deptno) temp </span><br><span class="line">  WHERE emp.deptno = temp.deptno AND emp.`sal` &gt; temp.avg_sal;</span><br><span class="line"></span><br><span class="line">  -- 查找每个部门工资最高的人的详细资料</span><br><span class="line">-- 每个部门工资最高的人</span><br><span class="line">  SELECT MAX(sal) AS max_sal</span><br><span class="line">FROM emp</span><br><span class="line">  GROUP BY deptno;</span><br><span class="line">  -- 按要求查找</span><br><span class="line">  SELECT * </span><br><span class="line">  FROM emp,(</span><br><span class="line">  SELECT MAX(sal) AS max_sal</span><br><span class="line">  FROM emp</span><br><span class="line">  GROUP BY deptno</span><br><span class="line">  ) temp</span><br><span class="line">  WHERE emp.`sal` = max_sal;</span><br><span class="line">  </span><br><span class="line">  -- 查询每个部门的信息（包括：部门名，编号，地址）和人员数量</span><br><span class="line">  SELECT deptno,COUNT(*) AS 人数</span><br><span class="line">  FROM emp</span><br><span class="line">  GROUP BY deptno;</span><br><span class="line">  </span><br><span class="line">  SELECT temp.deptno,dname,loc,人数</span><br><span class="line">  FROM dept,(</span><br><span class="line">  SELECT deptno,COUNT(*) AS 人数</span><br><span class="line">  FROM emp</span><br><span class="line">  GROUP BY deptno) temp</span><br><span class="line">  WHERE temp.deptno = dept.`deptno`;</span><br></pre></td></tr></table></figure></li><li><p>在多行子查询中使用all操作符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号</span><br><span class="line">select ename,sal,deptno </span><br><span class="line">from emp </span><br><span class="line">where sal&gt;all(select sal </span><br><span class="line">                  from emp </span><br><span class="line">                  where deptno = 30);</span><br></pre></td></tr></table></figure></li><li><p>在多行子查询中使用any操作符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何显示工资比部门30的其中一个员工的工资高的员工的姓名、工作和部门号</span><br><span class="line">select ename,sal,deptno </span><br><span class="line">from emp</span><br><span class="line">where sal&gt;any(select sal </span><br><span class="line">                  from emp </span><br><span class="line">                  where deptno=30);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多列子查询</p><p>多列子查询则是指查询返回多个列数据的子查询语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如何查询与smith的部门和岗位完全相同的所有雇员（并且不含smith本人）</span><br><span class="line">-- （字段1，字段2……）=（select 字段1，字段2 from……）</span><br><span class="line">-- 返回smith的部门和岗位</span><br><span class="line">select deptno, job </span><br><span class="line">from emp </span><br><span class="line">where ename = &#x27;smith&#x27;;</span><br><span class="line">-- 根据要求查表</span><br><span class="line">select * </span><br><span class="line">from emp </span><br><span class="line">   where (deptno, job) = (</span><br><span class="line">        select deptno, job </span><br><span class="line">        from emp </span><br><span class="line">        where ename = &#x27;smith&#x27;) and ename != &#x27;smith&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 请查询和宋江数学、英语、语文成绩完全相同的学生(不包括宋江本人)</span><br><span class="line"></span><br><span class="line">-- 宋江成绩情况</span><br><span class="line">select math,english,chinese </span><br><span class="line">from student </span><br><span class="line">where ename =&#x27;宋江&#x27;;</span><br><span class="line">-- 查询</span><br><span class="line">select * from student </span><br><span class="line">where (math,english,chinese) = (</span><br><span class="line">select math,english,chinese </span><br><span class="line">    from student </span><br><span class="line">    where ename =&#x27;宋江&#x27;</span><br><span class="line">) and ename != &#x27;宋江&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表复制</p><ul><li><p>自我复制数据（蠕虫复制）</p><p>有时为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 建表</span><br><span class="line">CREATE TABLE emp2(</span><br><span class="line">id INT unsigned,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">job VARCHAR(20),</span><br><span class="line">deptno INT UNSIGNED</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">-- 复制旧表</span><br><span class="line">INSERT INTO emp2(id,ename,job,deptno)</span><br><span class="line">SELECT empno,ename,job,deptno FROM emp;</span><br><span class="line"></span><br><span class="line">-- 自我复制（蠕虫复制）</span><br><span class="line">insert into emp2</span><br><span class="line">select * from emp2;</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line"></span><br><span class="line">-- 如何删除一张表重复的记录</span><br><span class="line">-- （1）先创建一张临时表my_tmp，该表的结构和原表一致</span><br><span class="line">CREATE TABLE emp2 LIKE emp3;</span><br><span class="line">-- （2）通过distinct关键字处理原表，将获得的记录复制到my_tmp</span><br><span class="line">INSERT INTO emp2</span><br><span class="line">SELECT DISTINCT * FROM emp3;</span><br><span class="line">SELECT * FROM emp3;</span><br><span class="line">-- （3）清除掉原表记录</span><br><span class="line">DELETE FROM emp3;</span><br><span class="line">-- （4）把my_tmp表的记录复制到原表</span><br><span class="line">INSERT INTO emp3 </span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line">-- （5）drop掉临时表</span><br><span class="line">DROP TABLE emp2;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>合并查询</p><p>有时在实际应用中，为了合并多个select语句的结果，可以使用集合操作符号union、union all</p><ol><li><p>union all</p><p>该操作符用于取得两个结果集的并集。当使用该操作符时，不会取消重复行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal from emp where sal&gt;2500 </span><br><span class="line">union all</span><br><span class="line">select ename,sal from emp where job = &#x27;MANAGER&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>union</p><p>该操作符与union all相似，但是会自动去掉结果集中重复行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal from emp where sal&gt;2500 </span><br><span class="line">union</span><br><span class="line">select ename,sal from emp where job = &#x27;MANAGER&#x27;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><ul><li><p>count返回行的总数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*)|count(列名) from tableName</span><br><span class="line">[where where_definition];</span><br><span class="line"></span><br><span class="line">-- 解释：</span><br><span class="line">-- count(*)：返回满足条件的记录的行数</span><br><span class="line">-- count(列)：统计满足条件的某列有多少个，但是会排除 为null</span><br></pre></td></tr></table></figure></li><li><p>合计函数——sum</p><p>sum函数返回满足where条件的行的和，一般使用在数值列上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(列名) &#123;,sum(列名)……&#125; from tableName</span><br><span class="line">[where where_definition];</span><br><span class="line"></span><br><span class="line">-- 注意：sum仅对数值起作用，否则会报错</span><br><span class="line">-- 注意：对多列求和，“，”号不能少</span><br></pre></td></tr></table></figure></li><li><p>合计函数——avg</p><p>avg函数返回满足where条件的一列的平均值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select avg(列名) &#123;,avg(列名)……&#125; from tableName</span><br><span class="line">[where where_definition];</span><br></pre></td></tr></table></figure></li><li><p>合计函数——max/min</p><p>max/min函数返回满足where条件的一列的最大/最小值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(列名) from tableName</span><br><span class="line">[where where_definition];</span><br></pre></td></tr></table></figure></li></ul><h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><table><thead><tr><th align="center">时间日期相关函数</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">current_date()</td><td align="center">当前日期</td></tr><tr><td align="center">current_time()</td><td align="center">当前时间</td></tr><tr><td align="center">current_timestamp()</td><td align="center">当前时间戳</td></tr><tr><td align="center">date(datetime)</td><td align="center">返回datetime的日期部分</td></tr><tr><td align="center">date_add(date2,interval d_value d_type)</td><td align="center">在date2上加上时间或日期</td></tr><tr><td align="center">date_sub(date2,interval d_value d_type)</td><td align="center">在date2上减去一个时间</td></tr><tr><td align="center">datediff(date1,date2)</td><td align="center">两个日期差（结果是多少天）</td></tr><tr><td align="center">timediff(date1,date2)</td><td align="center">两个时间差（多少小时多少分钟多少秒）</td></tr><tr><td align="center">now()</td><td align="center">当前时间</td></tr><tr><td align="center">year|month|date(datetime)</td><td align="center">返回年、月、日</td></tr><tr><td align="center">unix_timestamp()</td><td align="center">返回的是1970-1-1到现在的秒数</td></tr><tr><td align="center">from_unixtime()</td><td align="center">把一个unix_timestamp秒数转成指定格式日期</td></tr></tbody></table><ul><li><p>细节说明</p><table><thead><tr><th align="center">时间日期相关函数</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">date(datetime)</td><td align="center">返回datetime的日期部分</td></tr><tr><td align="center">date_add(date2,interval d_value d_type)</td><td align="center">在date2上加上时间或日期</td></tr><tr><td align="center">date_sub(date2,interval d_value d_type)</td><td align="center">在date2上减去一个时间</td></tr><tr><td align="center">datediff(date1,date2)</td><td align="center">两个日期差（结果是多少天）</td></tr></tbody></table><ul><li>date_add()中的interval后面可以是year、month、day、hour、minute、second等</li><li>date_sub()中的interval后面可以是year、month、day、hour、minute、second等</li><li>datediff(date1,date2)得到的是天数，而且是date1-date2的天数，因此可以是负数</li><li>这四个函数的日期类型可以是date、datetime或者timestamp</li><li>在实际开发中，我们也常使用int来保存一个unix时间戳，然后使用from_unixtime()进行转换，还是非常有价值的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mes(</span><br><span class="line">id INT UNSIGNED,</span><br><span class="line">context VARCHAR(100),</span><br><span class="line">send_datetime DATETIME</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO mes VALUES(1,&#x27;朝闻天下&#x27;,NOW());</span><br><span class="line">INSERT INTO mes VALUES(2,&#x27;午夜新闻&#x27;,CURRENT_TIMESTAMP());</span><br><span class="line"></span><br><span class="line">SELECT * FROM mes;</span><br><span class="line">-- date()/time()</span><br><span class="line">SELECT id,content,TIME(send_datetime) FROM mes;</span><br><span class="line"></span><br><span class="line">-- 返回20分钟之内发布的信息</span><br><span class="line">-- date_sub(date1,interval d_value d_type)</span><br><span class="line">SELECT id,content,send_datetime FROM mes</span><br><span class="line">WHERE send_datetime BETWEEN DATE_SUB(NOW(),INTERVAL 20 MINUTE) AND NOW();</span><br><span class="line">-- detediff()</span><br><span class="line">SELECT DATEDIFF(&#x27;2011-11-11&#x27;,&#x27;1999-1-1&#x27;) AS 相差天数 FROM DUAL;</span><br><span class="line">SELECT DATEDIFF(&#x27;2075-5-12&#x27;,&#x27;1995-5-12&#x27;) FROM DUAL;</span><br><span class="line">-- datediff()   date_add()</span><br><span class="line">SELECT DATEDIFF(DATE_ADD(&#x27;1995-5-12&#x27;,INTERVAL 80 YEAR),NOW()) AS 存在天数 FROM DUAL;</span><br><span class="line">-- year()</span><br><span class="line">SELECT YEAR(NOW()) FROM DUAL;</span><br><span class="line">-- unix_timestamp()</span><br><span class="line">SELECT CONCAT(FORMAT(UNIX_TIMESTAMP()/60/60/24/365,2),&#x27;年&#x27;) AS 1970年至今 FROM DUAL;</span><br><span class="line">-- from_unixtime()</span><br><span class="line">SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(),&#x27;%Y--%m--%d,%H:%i:%s&#x27;) FROM DUAL;</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th align="center">字符串相关函数</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">charset(str)</td><td align="center">返回字符串字符集</td></tr><tr><td align="center">concat(string2 [, …..])</td><td align="center">连接字符串</td></tr><tr><td align="center">instr(string,substring)</td><td align="center">返回substring在string中出现的位置，没有返回0</td></tr><tr><td align="center">ucase(string)</td><td align="center">转换成大写</td></tr><tr><td align="center">lcase(string)</td><td align="center">转换成小写</td></tr><tr><td align="center">left/right(string2,length)</td><td align="center">从string2中左/右边起取length个字符</td></tr><tr><td align="center">length(string)</td><td align="center">string长度【按照字节】</td></tr><tr><td align="center">replace(str,search_str,replace_str)</td><td align="center">在str中用replace_str替换search_str</td></tr><tr><td align="center">strcmp(string1,string2)</td><td align="center">逐字符比较两字串大小</td></tr><tr><td align="center">substring(str,position [,length])</td><td align="center">从str的position开始【从1开始计算】，取length个字符</td></tr><tr><td align="center">ltrim(str)/rtrim(str)</td><td align="center">去除前端空格或后端空格</td></tr><tr><td align="center">trim（str）</td><td align="center">去除前后端空格</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- concat</span><br><span class="line">select concat(ename,&#x27;工作是&#x27;,job) from emp;</span><br><span class="line">-- instr</span><br><span class="line">-- dual：亚元表，系统表 可以作为测试表使用</span><br><span class="line">select instr(&#x27;liyouuulalal&#x27;,&#x27;la&#x27;) from dual;</span><br><span class="line">-- 以首字母小写的方式显示所有员工的昵称</span><br><span class="line">SELECT `name`,CONCAT(LCASE(SUBSTRING(`mini_name`,1,1)),SUBSTRING(`mini_name`,2)) AS &#x27;昵称&#x27; FROM emp;</span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table><thead><tr><th align="center">数学相关函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">abs(num)</td><td align="center">绝对值</td></tr><tr><td align="center">ceiling(num)</td><td align="center">向上取整，得到比num大的最小整数</td></tr><tr><td align="center">conv(number,from_base,to_base)</td><td align="center">进制转换</td></tr><tr><td align="center">floor(num)</td><td align="center">向下取整，得到比num小的最大整数</td></tr><tr><td align="center">format(num,decimal_places)</td><td align="center">保留小数位数（四舍五入）</td></tr><tr><td align="center">hex(DecimalNumber)</td><td align="center">转十六进制</td></tr><tr><td align="center">least(num,num2 [,……..])</td><td align="center">求最小值</td></tr><tr><td align="center">mod(numerator,denominator)</td><td align="center">求余</td></tr><tr><td align="center">bin(decimal_number)</td><td align="center">十进制转二进制</td></tr><tr><td align="center">rand([seed])</td><td align="center">其范围为0 &lt;= v &lt;= 1.0</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- conv</span><br><span class="line">-- 将十进制转换成二进制</span><br><span class="line">SELECT CONV(14,10,2) FROM DUAL;</span><br><span class="line">-- 输出1110</span><br><span class="line"></span><br><span class="line">-- format：保留小数位后俩位</span><br><span class="line">SELECT FORMAT(21.1111,2) FROM DUAL;</span><br><span class="line"></span><br><span class="line">-- rand()：产生一个随机数</span><br><span class="line">-- rand([seed])：固定的随机数</span><br><span class="line">SELECT RAND(2) FROM DUAL;</span><br></pre></td></tr></table></figure><h3 id="加密和系统函数"><a href="#加密和系统函数" class="headerlink" title="加密和系统函数"></a>加密和系统函数</h3><table><thead><tr><th align="center">函数名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">user()</td><td align="center">查询登录mysql的有哪些用户，以及登录的IP，返回用户@IP地址</td></tr><tr><td align="center">database()</td><td align="center">查询当前数据库名称</td></tr><tr><td align="center">md5(str)</td><td align="center">为字符串算出一个（MD5） 32位的字符串，（为用户密码）加密</td></tr><tr><td align="center">password(str)</td><td align="center">从原文密码str计算并返回密码字符串，通常用于对mysql数据库的用户密码加密</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE hsp_user(</span><br><span class="line">id INT UNSIGNED,</span><br><span class="line">`user` VARCHAR(20),</span><br><span class="line">pwd CHAR(32)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">SELECT * FROM hsp_user;</span><br><span class="line"></span><br><span class="line">INSERT INTO hsp_user VALUES(1,&#x27;小刘&#x27;,MD5(&#x27;123456&#x27;));</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><table><thead><tr><th align="center">函数名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">if（expr1，expr2，expr3）</td><td align="center">如果expr1为true，则返回expr2，否则返回expr3</td></tr><tr><td align="center">ifnull（expr1，expr2）</td><td align="center">如果expr1为空null，则expr2；否则返回它本身</td></tr><tr><td align="center">select case when expr1 then expr2 when expr3 then expr4 else expr5 end；【类似多重分支】</td><td align="center">如果expr1为true，则返回expr2；如果expr3为true，则返回expr4；否则返回expr5</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT IF(FALSE,&#x27;北京&#x27;,&#x27;上海&#x27;) FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT IFNULL(NULL,&#x27;一个字符串&#x27;) FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT CASE </span><br><span class="line">    WHEN FALSE THEN &#x27;情况一&#x27;</span><br><span class="line">    WHEN TRUE THEN &#x27;情况二&#x27;</span><br><span class="line">    ELSE &#x27;情况三&#x27; END AS 选择语句;</span><br><span class="line">    </span><br><span class="line">select ename,if(comm is null, 0.0, comm) from emp;</span><br><span class="line">select ename,ifnull(comm,0.0) from emp;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><ul><li><p>提出一个问题</p><ol><li><p>前面我们学习的查询，是利用where子句对两张表或者多张表，形成的笛卡尔积进行筛选，根据关联条件，显示所有匹配的记录，匹配不上的，不显示的</p></li><li><p>比如：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dept.dname,ename,emp.job</span><br><span class="line">from emp,dept</span><br><span class="line">where emp.deptno = dept.deptno;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>外连接</p><ol><li><p>左外连接（如果<strong>左侧的表完全显示</strong>，我们就说是左外连接）</p></li><li><p>右外连接（如果<strong>右侧的表完全显示</strong>我们就说是右外连接）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT UNSIGNED,</span><br><span class="line">`name` VARCHAR(20)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO stu </span><br><span class="line">VALUES(1,&#x27;Jack&#x27;),</span><br><span class="line">(2,&#x27;Tom&#x27;),</span><br><span class="line">(3,&#x27;Kity&#x27;),</span><br><span class="line">(4,&#x27;nono&#x27;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE exam(</span><br><span class="line">id INT UNSIGNED,</span><br><span class="line">grade INT UNSIGNED</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO exam</span><br><span class="line">VALUES(1,56),</span><br><span class="line">(2,76),</span><br><span class="line">(11,8);</span><br><span class="line">SELECT * FROM stu;</span><br><span class="line">SELECT * FROM exam;</span><br><span class="line">-- 同时显示学号、姓名和成绩</span><br><span class="line">SELECT stu.id,`name`,grade</span><br><span class="line">FROM stu,exam</span><br><span class="line">WHERE stu.`id` = exam.`id`;</span><br><span class="line"></span><br><span class="line">-- 左外连接</span><br><span class="line">SELECT stu.`id`,stu.`name`,exam.`grade`</span><br><span class="line">FROM stu LEFT JOIN exam</span><br><span class="line">ON stu.`id` = exam.`id`;</span><br><span class="line">-- 右外连接</span><br><span class="line">SELECT stu.`id`,stu.`name`,exam.`grade`</span><br><span class="line">FROM stu RIGHT JOIN exam</span><br><span class="line">ON stu.`id` = exam.`id`;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li><p>基本介绍</p><p>约束用于确保数据库的数据满足特定的商业规划</p><p>在MySQL中，约束包括：not null、unique、primary key、foreign key和check五种</p></li></ul><h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h3><ul><li><p>primary key（主键）——基本使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 primary key</span><br></pre></td></tr></table></figure><p>用于唯一的表示表行的数据，当定义主键约束后，该列不能重复</p></li><li><p>primary key（主键）——细节说明</p><ol><li><p>primary key不能重复而且不能为null</p></li><li><p>一张表最多只能有一个主键，但可以是复合主键（多个条件同时相同才违反约束）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t17(</span><br><span class="line">id INT UNSIGNED,</span><br><span class="line">`name` VARCHAR(20),</span><br><span class="line">email VARCHAR(30),</span><br><span class="line">    PRIMARY KEY (id,`name`) -- 这里就是复合主键</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br></pre></td></tr></table></figure></li><li><p>主键指定的方式有两种</p><ul><li>直接字段后指定：primary key</li><li>在表定义最后写primary key（列名）</li></ul></li><li><p>使用desc 表名，可以看到primary key的情况</p></li><li><p>在实际开发中，每个表往往都会设计一个主键</p></li></ol></li></ul><h3 id="not-null-amp-amp-unique"><a href="#not-null-amp-amp-unique" class="headerlink" title="not null &amp;&amp; unique"></a>not null &amp;&amp; unique</h3><ul><li><p>not null（非空）</p><p>如果在列上定义了not null，那么当插入数据时，必须为列提供数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 not null</span><br></pre></td></tr></table></figure></li><li><p>unique（唯一）</p><p>当定义了唯一约束后，该列是不能重复的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 unique</span><br></pre></td></tr></table></figure></li><li><p>unique细节（注意）</p><ol><li>如果没有指定not null，则unique字段可以有多个null</li><li>一张表可以有多个unique字段</li></ol></li></ul><h3 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h3><ul><li><p>foreign key（外键）</p><p>用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须具有主键约束或是unique约束，当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOREIGN KEY (本表字段名) REFERENCES 主表名（主键名或unique字段名）</span><br></pre></td></tr></table></figure><img src="..\Java基础查漏补缺\外键示意图.png"/><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE my_class(</span><br><span class="line">id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">`name` VARCHAR(32),</span><br><span class="line">addr VARCHAR(32)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE my_stu(</span><br><span class="line">id INT UNSIGNED,</span><br><span class="line">`name` VARCHAR(32),</span><br><span class="line">class_id INT UNSIGNED,</span><br><span class="line">-- 指定外键关系</span><br><span class="line">FOREIGN KEY (class_id) REFERENCES class(id)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">-- 先往主表里添加数据</span><br><span class="line">INSERT INTO my_class</span><br><span class="line">VALUES(10,&#x27;一班&#x27;,&#x27;beijing&#x27;),</span><br><span class="line">(20,&#x27;二班&#x27;,&#x27;beijing&#x27;);</span><br><span class="line"></span><br><span class="line">-- 从表进行测试</span><br><span class="line">INSERT INTO my_stu</span><br><span class="line">VALUES(1,&#x27;张三&#x27;,10),</span><br><span class="line">(2,&#x27;李四&#x27;,10),</span><br><span class="line">(3,&#x27;王朝&#x27;,20),</span><br><span class="line">(4,&#x27;马汉&#x27;,20);</span><br><span class="line">INSERT INTO stu VALUES(5,&#x27;展昭&#x27;,30); -- 失败</span><br><span class="line"></span><br><span class="line">SELECT * FROM my_class;</span><br><span class="line">SELECT * FROM my_stu; </span><br></pre></td></tr></table></figure></li><li><p>foreign key(外键)——细节说明</p><ol><li>外键指向的表的字段要求是primary key或者是unique</li><li>表的类型是innodb，这样的表才支持外键</li><li>外键字段的类型要和主键字段的类型一致（长度可以不同）</li><li>外键字段的值，必须在主键字段中出现过，或者为null【前提是外键字段允许为null】</li><li>一旦建立主外键的关系，数据就不能随意删除了</li></ol></li><li><p>练习</p><img src="..\Java基础查漏补缺\外键练习.png"/><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE shop_db;</span><br><span class="line"></span><br><span class="line">CREATE TABLE goods(</span><br><span class="line">goods_id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">goods_name VARCHAR(32),</span><br><span class="line">unitprice FLOAT CHECK(unitprice BETWEEN 1.0 AND 9999.99),</span><br><span class="line">category VARCHAR(32),</span><br><span class="line">provider VARCHAR(32)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer(</span><br><span class="line">customer_id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">`name` VARCHAR(32) NOT NULL,</span><br><span class="line">addr VARCHAR(32),</span><br><span class="line">email VARCHAR(32) UNIQUE,</span><br><span class="line">sex CHAR(1),</span><br><span class="line">card_id VARCHAR(32)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE purchase(</span><br><span class="line">order_id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">customer_id INT UNSIGNED,</span><br><span class="line">goods_id INT UNSIGNED,</span><br><span class="line">nums INT UNSIGNED,</span><br><span class="line"></span><br><span class="line">FOREIGN KEY (customer_id) REFERENCES customer(customer_id),</span><br><span class="line">FOREIGN KEY (goods_id) REFERENCES goods(goods_id)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO goods</span><br><span class="line">VALUES(101,&#x27;巧克力&#x27;,20,&#x27;休闲食品&#x27;,&#x27;德福&#x27;),</span><br><span class="line">(201,&#x27;晾衣架&#x27;,30,&#x27;生活用品&#x27;,&#x27;苏果&#x27;);</span><br><span class="line"></span><br><span class="line">DELETE FROM goods;</span><br><span class="line">SELECT * FROM goods;</span><br><span class="line">INSERT INTO customer</span><br><span class="line">VALUES(1,&#x27;张龙&#x27;,&#x27;北京&#x27;,&#x27;123@163.com&#x27;,&#x27;男&#x27;,&#x27;321084199506092111&#x27;),</span><br><span class="line">(2,&#x27;赵虎&#x27;,&#x27;北京&#x27;,&#x27;1232121@163.com&#x27;,&#x27;男&#x27;,&#x27;321084199506092111&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO purchase</span><br><span class="line">VALUES(1001,1,101,2);</span><br><span class="line">SELECT * FROM purchase;</span><br><span class="line">INSERT INTO purchase</span><br><span class="line">VALUES(1002,2,201,2);</span><br></pre></td></tr></table></figure></li></ul><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><ul><li><p>check</p><p>用于强制行数据必须满足的条件，假定在sal列上定义了check约束，并要求sal列值在1000~~2000之间就会提示错误。</p><p>Oracle和sql server均支持check，但是mysql5.7目前还不支持check，只做语法校验，但不会生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本语法：列名类型check（check的条件）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user`(</span><br><span class="line">id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">`name` VARCHAR(32),</span><br><span class="line">sex VARCHAR(32) CHECK(sex IN(&#x27;man&#x27;,&#x27;woman&#x27;)),</span><br><span class="line">sal INT UNSIGNED CHECK(sal BETWEEN 100 AND 900)</span><br><span class="line">)CHARACTER SET utf8 COLLATE utf8_general_ci ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO `user`</span><br><span class="line">VALUES(1,&#x27;炭之郎&#x27;,&#x27;man&#x27;,500);</span><br><span class="line">SELECT * FROM USER;</span><br><span class="line">INSERT INTO `user`</span><br><span class="line">VALUES(3,&#x27;炭之郎&#x27;,&#x27;mansas&#x27;,5000);</span><br></pre></td></tr></table></figure><p>在MySQL中实现check的功能，一般是在程序中控制，或者通过触发器完成</p></li></ul><h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><ul><li><p>自增长基本介绍  一个问题</p><p>在某张表中，存在一个id列（整数），我们希望在添加记录的时候，该列从1开始，自动的增长，怎么处理？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名整型primary key auto_increment</span><br></pre></td></tr></table></figure><p>添加自增长的字段方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into XXX(字段1,字段2……) values(null,&#x27;值&#x27;……);</span><br><span class="line">insert into XXX(字段2……) values(&#x27;值1&#x27;,&#x27;值2&#x27;……);</span><br><span class="line">insert into XXX values(null,&#x27;值1&#x27;……);</span><br></pre></td></tr></table></figure></li><li><p>自增长使用细节</p><ol><li><p>一般来说自增长是和primary key配合使用的</p></li><li><p>自增长也可以单独使用【但需要配合一个unique】</p></li><li><p>自增长修饰的字段为整数型的（虽然小数也可以，但是非常非常少这样使用）</p></li><li><p>自增长默认从1开始，你也可以通过如下命令修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 auto_increment = 新的起始值;</span><br></pre></td></tr></table></figure></li><li><p>如果你添加数据时，给自增长字段（列）指定的有值，则以指定的值为准，如果指定了自增长，一般来说，就按照自增长的规则来添加数据</p></li></ol></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>说起提高数据库性能，索引是最物美价廉的东西了，不用加内存，不用改程序，不用调sql，查询速度就可能提高百倍千倍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 表示在emp表的empno列创建索引</span><br><span class="line">create index empno_index on emp(empno);</span><br></pre></td></tr></table></figure><ul><li><p>索引的原理</p><p>没有索引为什么会慢？</p><p>答：当我们没有索引时，数据库管理系统会进行全表扫描，查询速度慢</p><p>使用索引为什么会快？</p><p>答：形成一个索引的数据结构，比如二叉树</p><p>索引的代价</p><ol><li>磁盘占用</li><li>对dml（update、dalete、insert）语句的效率影响</li></ol><p>韩老师告诉你：在我们的项目中，select【90%】语句要比update、delete、insert【10%】语句多得多</p></li><li><p>主键索引，主键自动的为主索引（类型Primary key）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t1(</span><br><span class="line">id int primary key, -- 主键，同时也是索引，称为主键索引</span><br><span class="line">    enanme varchar(32)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>唯一索引（UNIQUE）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">id int unique, -- id是唯一的，同时也是索引，称为unique索引</span><br><span class="line">    ename varchar(32)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>普通索引（INDEX）</p></li><li><p>全文索引（FULLTEXT）【适用于MyISAM】</p><p>一般开发不使用MySQL自带的全文索引，而是考虑使用：全文搜索Solr和ElasticSearch（ES）</p></li><li><p>索引使用</p><ol><li><p>添加索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [unique] index index_name </span><br><span class="line">on tab_name(col_name[(length)] [ASC|DESC],……);</span><br><span class="line"></span><br><span class="line">alter table tab_name</span><br><span class="line">add [unique] index[index_name](index_col_name,……);</span><br></pre></td></tr></table></figure></li><li><p>添加主键（索引）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tab_name </span><br><span class="line">add primary key (列名);</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_name on tab_name;</span><br><span class="line"></span><br><span class="line">alter table tab_name </span><br><span class="line">drop index index_name;</span><br></pre></td></tr></table></figure></li><li><p>删除主键索引 比较特别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t_b drop primary key;</span><br></pre></td></tr></table></figure></li><li><p>修改索引</p><p>先删除，再添加新的索引</p></li><li><p>查询索引</p><ul><li><p>```mysql<br>show index from tab_name;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  show indexes from tab_name;</span><br></pre></td></tr></table></figure></li><li><p>```mysql<br>show keys from tab_name;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  desc tab_name;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>小结：哪些列上适合使用索引</p><ol><li>较频繁的作为条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现再WHERE子句中的字段不该创建索引</li></ol></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p><strong>事务引入</strong></p><img src="..\Java基础查漏补缺\事务引入.png"/><ul><li><p>什么是事务</p><p>事务用于保存数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败。如：转账就要用事务来处理，用以保存数据的一致性。</p><img src="..\Java基础查漏补缺\事务操作示意图.png"/></li><li><p>事务和锁</p></li></ul><p>​       当给执行事务操作时（dml语句），MySQL会再表上加锁，防止其他用户该表的数据，这对用户来讲是非 常重要的  </p></li><li><p><strong>MySQL数据库控制台事务的几个重要操作</strong></p><ol><li><p>```mysql<br>start transaction – 开始一个事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```mysql</span><br><span class="line">   savepoint -- 保存点名，设置保存点</span><br></pre></td></tr></table></figure></li><li><p>```mysql<br>rollback to – 保存点名，回退事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```mysql</span><br><span class="line">   rollback -- 回退全部事务</span><br></pre></td></tr></table></figure></li><li><p>```mysql<br>commit – 提交事务，所有的操作生效，不能回退</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  细节：</span><br><span class="line"></span><br><span class="line">  - 没有设置保存点</span><br><span class="line">  - 多个保存点</span><br><span class="line">  - 存储引擎</span><br><span class="line">  - 开始事务方式</span><br><span class="line"></span><br><span class="line">  回退事务</span><br><span class="line"></span><br><span class="line">  在介绍回退事务前，先介绍一下保存点（savepoint），保存点是事务中的点，用于取消部分事务，当结束事务时，会自动地删除该事务所定义地所有保存点，当执行回退事务时，通过指定保存点可以回退到指定地点</span><br><span class="line"></span><br><span class="line">  提交事务</span><br><span class="line"></span><br><span class="line">  使用commit语句可以提交事务，当执行了commit语句之后，会确认事务的变化、结束事务、删除保存点、释放锁、数据生效。当使用commit语句结束事务之后，其他会话将可以查到事务变化后地新数据。</span><br><span class="line"></span><br><span class="line">  事务细节讨论</span><br><span class="line"></span><br><span class="line">  1. 如果不开始事务，默认情况下，dml操作是自动提交的，不能回退</span><br><span class="line">  2. 如果开始一个事务，你没有创建保存点，你可以执行rollback，默认就是回退到你事务开始的状态</span><br><span class="line">  3. 你也可以在事务中（还没有提交），创建多个保存点，比如savepoint aaa；执行dml，savepoint bbb；</span><br><span class="line">  4. 你也可以在这个事务没有提交前，选择回退到哪个保存点</span><br><span class="line">  5. mysql的事务机制需要innodb的存储引擎还可以使用，myisam不好使</span><br><span class="line"></span><br><span class="line">  开始一个事务:</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">start transanction, set autocommit = off;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>MySQL事务隔离级别</strong></p><ol><li><p>多个连接开启各自事务操作数据库中数据时，数据库系统负责隔离操作，以保证各个连接在获取数据时的准确性（通俗解释）</p></li><li><p>如果不考虑隔离性，可能会引发如下问题：</p><p>正常状态：一端进入事务后，能够读取的数据应该是进入事务前拥有的数据。</p><ul><li><p>脏读（dirty read）</p><p>当一个事务读取另一个事务尚未提交的修改（dml）时，产生脏读。</p></li><li><p>不可重复读（nonrepeatable read）</p><p>同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同的结果集，此时发生不可重复读。</p></li><li><p>幻读（phantom read）</p><p>同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>插入</strong>操作，每次返回不同的结果集，此时发生幻读。</p></li></ul></li></ol><ul><li><p>事务隔离级别</p><p>概念：MySQL隔离级别定义了事务与事务之间的隔离程度</p><table><thead><tr><th align="center">MySQL隔离级别（4种）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">加锁读</th></tr></thead><tbody><tr><td align="center">读未提交（Read uncommitted）</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">不加锁</td></tr><tr><td align="center">读已提交（Read commited）</td><td align="center">N</td><td align="center">Y</td><td align="center">Y</td><td align="center">不加锁</td></tr><tr><td align="center">可重复读（Repeatable Read）</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">不加锁</td></tr><tr><td align="center">可串行化（Serializable）</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">加锁</td></tr></tbody></table><p>说明：Y：可能出现</p><p>​            N：不会出现</p><p>​    可串行化（Serializable）：当隔离级别为Serializable的表正在被操作时，其他客户端无法操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.查看当前会话的隔离级别</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line">-- 2.查看系统当前的隔离级别</span><br><span class="line">SELECT @@global.tx_isolation;</span><br><span class="line">-- 3.设置当前会话的隔离级别</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">-- 4.设置系统当前隔离级别</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure></li></ul><p>​        MySQL默认的事务隔离级别是repeatable read，一般情况下，没有特殊要求，没有必要修改（因为该级别可以满足绝大部分项目需求）</p><ul><li><p>全局修改隔离级别</p><p>修改my.ini配置文件，在最后加上</p><p>可选参数有：READ-UNCOMMITTED/READ-COMMITTED/REPEATABLE-READ/SERIAILABLE</p><p>[mysqld]</p><p>transaction-isolation = REPEATABLE-READ</p></li><li><p>事务的acid特性</p><ol><li><p>原子性（Atomicity）</p><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</p></li><li><p>一致性（Consistency）</p><p>事务必须使数据库从一个一致性状态变换到另一个一致性状态</p></li><li><p>隔离性（Isolation）</p><p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离</p></li><li><p>持久性（Durability）</p><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p></li></ol></li></ul></li><li><p><strong>MySQL表类型和存储引擎</strong></p><ul><li><p>基本介绍</p><ol><li><p>MySQL的表类型由存储引擎（Storage Engines）决定，主要包括MyISAM、innodb、Memory等</p></li><li><p>MySQL数据表主要支持六种类型，分别是：CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、Innodb。</p></li><li><p>这六种又分为两类，一类是“事务安全型”（transaction-safe），比如：Innodb；其余都属于第二类，称为“非事务安全型”（non-transaction-safe）【myisam和memory】。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 显示当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>主要的存储引擎/表类型特点</p><img src="..\Java基础查漏补缺\存储引擎的特点.png"/></li><li><p>细节说明</p><p>重点介绍三种：MyISAM、InnoDB、MEMORY</p><ol><li>MyISAM不支持事务、也不支持外键，但其访问速度快，对事务完整性没有要求</li><li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保存数据和索引。</li><li>MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索引。但是一旦服务关闭，表中的数据就会丢失掉，表的结构还在。</li></ol></li><li><p>三种存储引擎表的使用案例</p><ol><li>InnoDB<ul><li>支持事务</li><li>支持外键</li><li>支持行级锁</li></ul></li><li>MyISAM<ul><li>添加速度快</li><li>不支持外键和事务</li><li>支持表级锁</li></ul></li><li>MEMORY<ul><li>数据存储在内存中【关闭了MySQL服务，数据丢失，但是表结构还在】</li><li>执行速度很快（没有I/O读写）</li><li>支持索引（Hash表）</li></ul></li></ol></li><li><p>如何选择表的存储引擎</p><ol><li>如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二之选，速度快</li><li>如果需要支持事务，选择InnoDB</li><li>Memory存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失（经典用法：用户的在线状态）</li></ol></li><li><p>修改存储引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table `表名` engine = 存储引擎;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li><p>看一个需求</p><p>emp表的列信息很多，有些信息是个人重要信息（比如：sal、comm、mgr、hiredate），如果我们希望某个用户只能查询emp表的（empno、ename、job和deptno）信息，有什么办法？</p><img src="..\Java基础查漏补缺\emp表.png"/></li><li><p>基本概念</p><ol><li><p>视图是一个虚拟表，其内容由查询定义。同真是的表一样，视图包含列，其数据来自对应的真实表（基表）</p></li><li><p>视图与基表关系的示意图</p><img src="..\Java基础查漏补缺\视图与基表的关系.png"/></li></ol></li><li><p>视图的基本使用</p><ol><li>create view 视图名 as select语句</li><li>alter view 视图名 as select 语句</li><li>show create view 视图名</li><li>drop view 视图1，视图2</li></ol></li><li><p>完成前面提出的需求</p><p>创建一个视图emp_view01，只能查询emp表（empno、ename、job和deptno）信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_view01 </span><br><span class="line">AS </span><br><span class="line">SELECT empno,ename,deptno,sal FROM emp;</span><br></pre></td></tr></table></figure></li><li><p>视图细节讨论</p><ol><li>创建视图后，到数据库去看，对应视图只有一个视图结构文件（形式：视图名.frm）</li><li>视图的数据变化会影响到基表，基表的数据变化也会影响到视图</li><li>试图中可以再使用视图</li></ol></li><li><p>视图最佳实践</p><ol><li>安全。一些数据表有着重要的信息，有些字段是保密的，不能让用户直接看到，这时就可以创建一个视图，在这张视图中只保留一部分字段，这样，用户就可以查询自己需要的字段，不能查看保密的字段</li><li>性能。关系数据库的数据常常会分表存储，使用外键建立这些表之间的关系，这时，数据库查询通常会用到连接（JOIN）。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起，就可以避免使用JOIN查询数据。</li><li>灵活。如果系统中有一张旧的表，这张表由于设计问题，即将被废弃。然而很多应用都是基于这张表，不宜修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。</li></ol></li></ul><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><ul><li><p>MySQL用户</p><p>mysql中的用户，都存储在系统数据库mysql中user中</p><img src="..\Java基础查漏补缺\表user.png"/><p>其中user表的重要字段说明：</p><ol><li><p>host</p><p>允许登录的“位置”，localhost表示该用户只允许本机登录，也可以指定ip地址，比如：192.168.1.100</p></li><li><p>user</p><p>用户名</p></li><li><p>authentication_string</p><p>密码，是通过mysql的password（）函数加密之后的密码</p></li></ol></li><li><p>创建用户</p><p>当我们做项目开发时，可以根据不同的开发人员，赋给他们相应的MySQL操作权限。</p><p>不同的数据库用户，登录到DBMS后，根据相应的权限，可以操作的数据库和数据对象（表、视图、触发器）都不一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建用户，同时指定密码</span><br><span class="line">create user &#x27;用户名&#x27; @ &#x27;允许登录位置&#x27; identified by &#x27;密码&#x27; </span><br><span class="line">create user &#x27;hsp_edu&#x27;@localhost identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27; @ &#x27;允许登陆位置&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>用户修改密码</p><p>修改自己的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set password = password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure><p>修改他人的密码（需要有修改用户密码权限）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set password for &#x27;用户名&#x27;@ &#x27;登陆位置&#x27; = password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>给用户授权</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限列表 on 库.对象名 to &#x27;用户名&#x27;@ &#x27;登陆位置&#x27; 【identified by &#x27;密码&#x27;】;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>权限列表，多个权限用逗号分开</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant select on...</span><br><span class="line">grant select,delete,create on...</span><br><span class="line">grant all [privileges] on ...     //表示赋予该用户在该对象上的所有权限 </span><br></pre></td></tr></table></figure></li><li><p>特别说明</p><p>*. *：代表本系统中的所有数据库的所有对象（表、视图、存储过程）</p><p>库.*：表示某个数据库中的所有数据对象（表、视图、存储过程）</p></li><li><p>identified by 可以省略，也可以写出</p><ul><li>如果用户存在，就是修改该用户的密码</li><li>如果该用户不存在，就是创建该用户</li></ul></li></ol></li><li><p>回收用户授权</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke 权限列表 on 库.对象名 from &#x27;用户名&#x27;@ &#x27;登陆位置&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>权限生效指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如果权限没有生效，可以执行下面命令</span><br><span class="line">-- 基本语法：</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>细节说明</p><ol><li><p>在创建用户的时候，如果不指定host，则为%，%表示所有IP都有连接权限</p><p>create user xxx;</p></li><li><p>你也可以这样指定</p><p>create user ’xxx‘@192.168.1.%;</p><p>表示xxx用户在192.168.1.*的IP可以登录MySQL</p></li><li><p>在删除用户的时候，如果host不是%，需要明确指定’用户‘@’host值‘</p></li></ol></li></ul><h1 id="jdbc和连接池"><a href="#jdbc和连接池" class="headerlink" title="jdbc和连接池"></a>jdbc和连接池</h1><h2 id="jdbc概述"><a href="#jdbc概述" class="headerlink" title="jdbc概述"></a>jdbc概述</h2><p>jdbc是什么？</p><p>jdbc是一套为不同的数据库提供了统一访问的接口。相关类和接口在java.sql和javax.sql包里。</p><p>jdbc的基本原理图：</p><p>Java厂商提供一套jdbc接口规范，不同的数据库厂商根据接口，实现具体的类，具体类会被打包成jar包，该jar包就是我们所说的驱动。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">不同的数据库厂商实现统一的接口规范，体现了一种多态的思想</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdbc</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//JdbcInterface jdbcInterface = new MysqlImpl();</span></span><br><span class="line">        JdbcInterface jdbcInterface = <span class="keyword">new</span> OracleImpl();</span><br><span class="line">        jdbcInterface.getConnection();</span><br><span class="line">        jdbcInterface.crud();</span><br><span class="line">        jdbcInterface.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一的接口规范</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JdbcInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crud</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlImpl</span> <span class="keyword">implements</span> <span class="title">JdbcInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql连接成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql进行crud操作！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql关闭资源连接！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleImpl</span> <span class="keyword">implements</span> <span class="title">JdbcInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle连接成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crud</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle进行crud操作！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle关闭资源连接！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbc快速入门"><a href="#jdbc快速入门" class="headerlink" title="jdbc快速入门"></a>jdbc快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">第一个jdbc程序，完成简单的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testjdbc</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into actor(id,name,gender,borntime,phone) values(null,&quot;</span>海绵宝宝<span class="string">&quot;,&quot;</span>男<span class="string">&quot;,&quot;</span><span class="number">1991</span>-<span class="number">1</span>-<span class="number">1</span><span class="string">&quot;,&quot;</span><span class="number">1231232</span><span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="comment">//物理删</span></span><br><span class="line">        String sql2 = <span class="string">&quot;delete from actor where id = 2&quot;</span>;</span><br><span class="line">        <span class="comment">//改（逻辑删除）</span></span><br><span class="line">        String sql3 = <span class="string">&quot;update actor set name = &#x27;派大星&#x27; where id = 1&quot;</span>;</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql);<span class="comment">//影响的行数</span></span><br><span class="line">        System.out.println(row &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">       <span class="comment">//关闭资源连接</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">五种加载驱动连接数据库的方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionWays</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionWay1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperties(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperties(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = driver.connect(url,properties);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭资源连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式2：加载驱动改为反射获得</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionWay2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Class&lt;?&gt; aclass = Class.forname(<span class="string">&quot;con.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver)aclass.newInstance();</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperties(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperties(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = driver.connect(url,properties);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭资源连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionWay3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Class&lt;?&gt; aclass = Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver)aclass.newInstance();</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">     <span class="string">&quot;&quot;</span>   </span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line">        DriverManager.getConnection(url,user,password);</span><br><span class="line">        <span class="comment">//组织并执行sql</span></span><br><span class="line">        <span class="comment">//关闭资源连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><h2 id="JDBC-Utils"><a href="#JDBC-Utils" class="headerlink" title="JDBC Utils"></a>JDBC Utils</h2><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><h3 id="Proxool"><a href="#Proxool" class="headerlink" title="Proxool"></a>Proxool</h3><h3 id="BoneCP"><a href="#BoneCP" class="headerlink" title="BoneCP"></a>BoneCP</h3><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><h2 id="Apache-DBUtils"><a href="#Apache-DBUtils" class="headerlink" title="Apache-DBUtils"></a>Apache-DBUtils</h2><h2 id="DAO的增删改查-BasicDAO"><a href="#DAO的增删改查-BasicDAO" class="headerlink" title="DAO的增删改查-BasicDAO"></a>DAO的增删改查-BasicDAO</h2><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>为什么要学习正则表达式？</p><ol><li>提取文章中的所有英文单词</li><li>提取文章中所有的数字</li><li>提取文章中所有的英文单词和数字</li><li>提起百度热榜标题</li></ol><p>结论：正则表达式是处理文本的利器</p><p>再提几个问题？</p><ol><li>给你一个字符串（或文章），找出所有四个数字连在一起的子串？</li><li>给你一个字符串（或文章），请找出所有四个数字连在一起的子串，并且这四个数字要满足：第一位与第四位相同，第二位与第三位相同，如1221，5775等</li><li>请验证输入的邮件是否符合电子邮件格式</li><li>请验证输入的手机号是否符合手机号格式</li></ol><ul><li>解决之道——正则表达式<ol><li>为了解决上述问题，Java提供了正则表达式技术，专门用于解决类似文本处理问题</li><li>简单的说：正则表达式是对字符串执行模式匹配的技术</li><li>正则表达式：regular expression =&gt; RegExp</li></ol></li></ul><h2 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h2><h3 id="正则表达式基本介绍"><a href="#正则表达式基本介绍" class="headerlink" title="正则表达式基本介绍"></a>正则表达式基本介绍</h3><ol><li>一个正则表达式，就是用某种模式去匹配字符串的一个公式，很多人因为他们看起来比较古怪而且复杂所以不敢去使用，不过，经过练习后，就觉得这些复杂的表达式写起来还是相当简单的，而且，一旦弄懂它们，就能把数小时辛苦而且易错的文本处理工作缩短在几分钟（甚至几秒钟）内完成</li><li>正则表达式不是只有Java才有，实际上很多编程语言（js、php、Java……）都支持正则表达式进行字符串操作</li></ol><h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><ul><li><p>基本介绍</p><p>如果想要灵活运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大体分为：</p><ol><li>限定符</li><li>选择匹配符</li><li>分组组合和反向引用符</li><li>特殊字符</li><li>字符匹配符</li><li>定位符</li></ol></li><li><p>元字符（Metacharacter）——转义号\\ </p><p>\\ 符号说明：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转移符号，否则检索不到结果，甚至会报错的。</p><p>案例：用$去匹配”abc$（“会怎样？用（去匹配”abc$（“会怎样？</p><p>再次提示：在Java的正则表达式中，两个\\代表其他语言中的一个\</p><p>需要用到转移符号的字符有以下：.*()$/?[]^{}</p></li><li><p>元字符——字符匹配符</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">示例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">[]</td><td align="center">可接收的字符列表</td><td align="center">[efgh]</td><td align="center">e、f、g、h中任意一个字符</td></tr><tr><td align="center">[^]</td><td align="center">不接受的字符列表</td><td align="center">[^abc]</td><td align="center">除a、b、c之外的任意一个字符，包括数字和特殊符号</td></tr><tr><td align="center">-</td><td align="center">连字符</td><td align="center">A-Z</td><td align="center">任意单个大写字母</td></tr></tbody></table><img src="..\Java基础查漏补缺\字符匹配符.png"/><p>应用实例：</p><ol><li><p>[a-z]说明：</p><p>[a-z]表示可以匹配a-z中任意一个字符，比如[a-z]、[A-Z]去匹配a11c8会得到什么结果？</p></li><li><p>Java正则表达式默认是区分字母大小写的，如何实现不区分大小写</p><ul><li><p>(?i)abc表示abc都不区分大小写</p></li><li><p>a(?i)bc表示bc不区分大小写</p></li><li><p>a((?i)b)c表示只有b不区分大小写</p></li><li><pre><code class="Java">Pattern compile = Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);</code></pre></li></ul><p>[A-Z]表示可以匹配A-Z中任意一个字符</p><p>[0-9]表示可以匹配0-9中任意一个字符</p></li><li><p>[^a-z]说明：</p><p>[^a-z]表示可以匹配不是a-z中的任意一个字符</p><p>[^A-Z]表示可以匹配不是A-Z中的任意一个字符</p><p>[^0-9]表示可以匹配不是0-9中的任意一个字符</p></li><li><p>[abcd]表示可以匹配abcd中的任意一个字符</p></li><li><p>[^abcd]表示可以匹配不是abcd中的任意一个字符</p></li><li><p>\\d表示可以匹配0-9的任意一个数字，相当于[0-9]</p></li><li><p>\\D表示可以匹配不是0-9中的任意一个字符，相当于[ ^ 0-9]</p></li><li><p>\\w匹配任意英文字符、数字和下划线，相当于[a-zA-Z0-9]</p></li><li><p>\\W相当于[ ^a-zA-Z0-9_]和\\w刚好相反</p></li><li><p>\\s匹配任意空白字符（空格、制表符等）</p></li><li><p>\\S匹配任何非空白字符，和\\s刚好相反</p></li><li><p>.（小圆点）匹配除\n之外的所有字符，如果要匹配，本身则需要使用\\</p></li></ol></li></ul><h3 id="三个常用类"><a href="#三个常用类" class="headerlink" title="三个常用类"></a>三个常用类</h3><ol><li>Pattern</li><li>Matcher</li><li>PatternSyntaxException</li></ol><h3 id="分组、捕获、反向引用"><a href="#分组、捕获、反向引用" class="headerlink" title="分组、捕获、反向引用"></a>分组、捕获、反向引用</h3><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h1 id="Java8和Java11新特性"><a href="#Java8和Java11新特性" class="headerlink" title="Java8和Java11新特性"></a>Java8和Java11新特性</h1><h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h3 id="接口静态方法"><a href="#接口静态方法" class="headerlink" title="接口静态方法"></a>接口静态方法</h3><h3 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h3><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><h3 id="stream-API"><a href="#stream-API" class="headerlink" title="stream API"></a>stream API</h3><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><h3 id="串行流"><a href="#串行流" class="headerlink" title="串行流"></a>串行流</h3><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><h3 id="新时间日期-API"><a href="#新时间日期-API" class="headerlink" title="新时间日期 API"></a>新时间日期 API</h3><h2 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h2><h3 id="代码层面新特性"><a href="#代码层面新特性" class="headerlink" title="代码层面新特性"></a>代码层面新特性</h3><ol><li>JShell</li><li>类型推断</li><li>集合增强API</li><li>Stream 加强</li><li>新增字符串处理方法</li><li>Optional加强</li><li>InputStream增强API</li><li>标准Java异步HTTP客户</li></ol><h3 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1fh411y7R8?from=search&seid=3263764915424826952&spm_id_from=333.337.0.0">【零基础 快速学Java】韩顺平 零基础30天学会Java_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> J2SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2021/08/29/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/08/29/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">引入：</span></span><br><span class="line"><span class="comment">静态语言与动态语言：静态语言即在运行时结构不能被改变的语言，如Java、C、C++，而反射使得Java成为“准动态语言”。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射：如何获得class类的几种方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liyou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-30-1:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//1、通过类名获得Class类</span></span><br><span class="line">        Class clazz1 = Person.class;</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、通过实例对象获得Class类</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Class clazz2 = person.getClass();</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、通过全类名获得Class类</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;com.atguigu.eduservice.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">哪些类型可以获得class对象呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//类的class</span></span><br><span class="line">        Class clazz1 = Test.class;</span><br><span class="line">        <span class="comment">//接口</span></span><br><span class="line">        Class clazz2 = Serializable.class;</span><br><span class="line">        <span class="comment">//注解</span></span><br><span class="line">        Class clazz3 = Target.class;</span><br><span class="line">        <span class="comment">//枚举</span></span><br><span class="line">        Class clazz4 = ElementType.class;</span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        Class clazz5 = <span class="keyword">int</span>[].class;</span><br><span class="line">        <span class="comment">//基本数据类型</span></span><br><span class="line">        Class clazz6 = <span class="keyword">int</span>.class;</span><br><span class="line">        <span class="comment">//void</span></span><br><span class="line">        Class clazz7 = <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1);</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line">        System.out.println(clazz4);</span><br><span class="line">        System.out.println(clazz5);</span><br><span class="line">        System.out.println(clazz6);</span><br><span class="line">        System.out.println(clazz7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">class com.atguigu.eduservice.Test</span></span><br><span class="line"><span class="comment">interface java.io.Serializable</span></span><br><span class="line"><span class="comment">interface java.lang.annotation.Target</span></span><br><span class="line"><span class="comment">class java.lang.annotation.ElementType</span></span><br><span class="line"><span class="comment">class [I</span></span><br><span class="line"><span class="comment">int</span></span><br><span class="line"><span class="comment">void</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> J2SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解</title>
      <link href="/2021/08/28/Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/08/28/Java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首先什么是注解?</span></span><br><span class="line"><span class="comment">Java的注解是Java1.5之后推出的新功能，注解的作用：其一可以和注释一样，对代码进行解释说明，其二，也是较为重要的一点，可以被其他代码读取。注解的使用：@+注解名，并可以添加参数。</span></span><br><span class="line"><span class="comment">四个元注解：</span></span><br><span class="line"><span class="comment">1&gt;<span class="doctag">@Target</span>：规定被注解代码的作用目标，types、成员变量、成员方法、形参等</span></span><br><span class="line"><span class="comment">2&gt;<span class="doctag">@Retention</span>：保留范围：SOURCE/CLASS/RUNTIME，一般RUNTIME即可</span></span><br><span class="line"><span class="comment">3&gt;<span class="doctag">@Documented</span>：生成Javadoc文档</span></span><br><span class="line"><span class="comment">4&gt;<span class="doctag">@Inherited</span>：子类可以被父类继承</span></span><br><span class="line"><span class="comment">一些内置注解：</span></span><br><span class="line"><span class="comment"><span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment"><span class="doctag">@Surpresswarnings</span></span></span><br><span class="line"><span class="comment">自定义注解的创建：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//自定义注解的创建</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Student&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> J2SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot项目实战</title>
      <link href="/2021/08/22/springboot%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
      <url>/2021/08/22/springboot%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大神们直接写业务逻辑，作为newfish还是得先从熟悉代码开始呀！</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">springboot一站式整合！！！</span></span><br><span class="line"><span class="comment">idea编写，一个项目中有多个模块，每个项目中又会有很多的子模块</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="D:\developer_tools\blog\imgs\pic1.PNG" alt="项目结构"></p><h3 id="二、代码生成器"><a href="#二、代码生成器" class="headerlink" title="二、代码生成器"></a>二、代码生成器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">利用代码生成器快速建成controller、service、mapper、entity,代码生成器不参与打包。可直接放在test下</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="D:\developer_tools\blog\imgs\pic2.PNG"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*代码生成器*/</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建代码生成器</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        <span class="comment">//String projectPath = System.getProperty(&quot;user.dir&quot;);</span></span><br><span class="line">        gc.setOutputDir(<span class="string">&quot;C:\\Users\\Liyou\\IdeaProjects\\guli_parent\\service\\service_edu&quot;</span> + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">&quot;testjava&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>); <span class="comment">//生成后是否打开资源管理器</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>); <span class="comment">//重新生成时文件是否覆盖</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);<span class="comment">//去掉Service接口的首字母I</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER_STR); <span class="comment">//主键策略</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);<span class="comment">//定义生成的实体类中日期类型</span></span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);<span class="comment">//开启Swagger2模式</span></span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、包配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.atguigu&quot;</span>);</span><br><span class="line">        pc.setModuleName(<span class="string">&quot;eduservice&quot;</span>); <span class="comment">//模块名</span></span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">&quot;edu_teacher&quot;</span>);</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="comment">//数据库表映射到实体的命名策略</span></span><br><span class="line">        strategy.setTablePrefix(pc.getModuleName() + <span class="string">&quot;_&quot;</span>); <span class="comment">//生成实体时去掉表前缀</span></span><br><span class="line"></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="comment">//数据库表字段映射到实体的命名策略</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span></span><br><span class="line"></span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>); <span class="comment">//restful api风格控制器</span></span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>); <span class="comment">//url中驼峰转连字符</span></span><br><span class="line"></span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、执行</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、后台讲师模块的讲师列表和删除"><a href="#三、后台讲师模块的讲师列表和删除" class="headerlink" title="三、后台讲师模块的讲师列表和删除"></a>三、后台讲师模块的讲师列表和删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在controller层进行注入和调用*/</span></span><br><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduTeacherController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问地址：http://localhost:8001/eduservice/edu-teacher/findAll</span></span><br><span class="line">    <span class="comment">//把service注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EduTeacherService teacherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询讲师模块所有数据</span></span><br><span class="line">    <span class="comment">//rest风格</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;所有讲师列表&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;EduTeacher&gt; <span class="title">findAllTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用service的方法实现查询所有的操作</span></span><br><span class="line">        List&lt;EduTeacher&gt; list = teacherService.list(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id逻辑删除讲师&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeTeacher</span><span class="params">(<span class="meta">@ApiParam(name = &quot;id&quot;,value = &quot;讲师ID&quot;,required = true)</span> <span class="meta">@PathVariable</span> String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = teacherService.removeById(id);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service</span></span><br><span class="line"><span class="keyword">import</span> com.atguigu.eduservice.entity.EduTeacher;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.eduservice.mapper.EduTeacherMapper;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.eduservice.service.EduTeacherService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduTeacherServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">EduTeacherMapper</span>, <span class="title">EduTeacher</span>&gt; <span class="keyword">implements</span> <span class="title">EduTeacherService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mapper</span></span><br><span class="line"><span class="keyword">import</span> com.atguigu.eduservice.entity.EduTeacher;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EduTeacherMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">EduTeacher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//entity略</span></span><br><span class="line"><span class="comment">//myconfig</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.injector.ISqlInjector;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liyou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-22-15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑删除插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、整合swagger"><a href="#四、整合swagger" class="headerlink" title="四、整合swagger"></a>四、整合swagger</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">另开一个模块用于写公用的工具，如用于测试接口和生成文档的swagger</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.servicebase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Predicates;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liyou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-22-22:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/admin/.*&quot;</span>)))</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;网站-课程中心API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了课程中心微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;Helen&quot;</span>, <span class="string">&quot;http://atguigu.com&quot;</span>, <span class="string">&quot;55317332@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2021/08/19/Maven/"/>
      <url>/2021/08/19/Maven/</url>
      
        <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Maven一些知识点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cloud-alibaba.version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">cloud-alibaba.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--坐标gav--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$&#123;&#125;引用properties里的版本--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--type默认是jar，可以改成war，这两种比较常用；这里我们说下pom，当需要引入很多依赖的时候，pom.xml文件会过大，我们可以通过依赖一个父项目来解决这个问题，但也可能导致父项目pom.xml文件过大，所以最终的方法是type改成pom方式，即把很多jar包打包到一个pom中，我们依赖了pom，就可以下载所有的jar包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--scope标签的详细介绍如下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>   </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web依赖：集成tomcat，完成dispatcherServlet,xml...--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打jar包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上所示，主要有四个部分：</p><ul><li>项目元数据信息：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等</li><li>parent：继承spring-boot-starter-parent的依赖管理，控制版本与打包等内容</li><li>dependencies：项目具体依赖，这里包含了spring-boot-starter-web用于实现HTTP接口（该以来中包含Spring MVC），官网对它的描述是：使用Spring MVC构建Web（包括RESTful）应用程序的入门者，使用Tomcat作为默认嵌入式容器。spring-boot-starter-test用于编写单元测试的依赖包。</li><li>build：构建配置部分。默认使用了spring-boot-maven-plugin，配合spring-boot-starter-parent就可以把Spring Boot应用打成jar包直接运行。</li></ul><p>用于运行junit4引擎测试<br>                    @Test这个注解<br>                    如果spring-boot-starter-test 没有 排除 junit-vintage-engine依赖，那么会导致<br>                    org.junit.jupiter.api.Test 和 org.junit.Test 同时存在，<br>                    如果不小心引入了org.junit.Test ，<br>                    那么就会发生这个spring 属性注入为null的情况<br>                    1、Spring Boot项目推荐编写JUnit 5测试用例，所以不需要JUnit 4引擎。<br>                    2、开发者在引入包时，有两个选择，<br>                    不小心导错包导致出现MockMvc和WebApplicationContext无法加载，<br>                    间接导致出现属性为null的情况</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--compile(默认)</span></span><br><span class="line"><span class="comment">如果没有指定scope,那么该元素的默认值为compile。被依赖项目需要参与到项目的编译、测试、打包、运行等阶段，打包时通常会包含被依赖项目，是比较强的依赖。</span></span><br><span class="line"><span class="comment">provided</span></span><br><span class="line"><span class="comment">被依赖项目理论上可以参与到项目的编译、测试、运行等阶段，当时在打包时进行了exclude动作。</span></span><br><span class="line"><span class="comment">应用场景：例如我们在开发一个web项目，在编译的时候我们需要依赖servlet-api.jar,但在运行时我们不需要这个jar，因为它已由应用服务器提供，这是我们就需要用provided来修饰这个依赖包。</span></span><br><span class="line"><span class="comment">runtime</span></span><br><span class="line"><span class="comment">顾名思义，表示该依赖项目无需参与到项目的编译，但会参与到测试与运行阶段。</span></span><br><span class="line"><span class="comment">应用场景：例如在编译时我们不需要JDBC API的jar，但在运行时才需要JDBC的驱动包。</span></span><br><span class="line"><span class="comment">test</span></span><br><span class="line"><span class="comment">表示该依赖项目仅会参与到项目的测试阶段。</span></span><br><span class="line"><span class="comment">应用场景：例如，Junit 测试。</span></span><br><span class="line"><span class="comment">system</span></span><br><span class="line"><span class="comment">与provided类似，但是被依赖项不会从maven仓库查找依赖，而是从本地系统中获取，systemPath元素用于指定依赖在系统中jar的路径。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cjf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>auth-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;/MyContent/WEB-INF/lib/auth-center.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--import</span></span><br><span class="line"><span class="comment">它只使用在dependencyManagement中，我们知道maven和java只能单继承，作用是管理依赖包的版本，一般用来保持当前项目的所有依赖版本统一。</span></span><br><span class="line"><span class="comment">例如：项目中有很多的子项目，并且都需要保持依赖版本的统一，以前的做法是创建一个父类来管理依赖的版本，所有的子类继承自父类，这样就会导致父项目的pom.xml非常大，而且子项目不能再继承其他项目。</span></span><br><span class="line"><span class="comment">import为我们解决了这个问题，可以把dependencyManagement放到一个专门用来管理依赖版本的pom中，然后在需要用到该依赖配置的pom中使用scope import就可以引用配置。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot(1)</title>
      <link href="/2021/08/17/springboot-1/"/>
      <url>/2021/08/17/springboot-1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">关于一个最基础的springboot项目，我们第一个想到是该是什么呢？</span></span><br><span class="line"><span class="comment">1、导入依赖（pom.xml）</span></span><br><span class="line"><span class="comment">2、文件配置（.property .yml）</span></span><br><span class="line"><span class="comment">链接mysql数据库</span></span><br><span class="line"><span class="comment">3、模块编写(从上到下)</span></span><br><span class="line"><span class="comment">1&gt;view层：与controller层协同工作，以js为主，动态展示前端</span></span><br><span class="line"><span class="comment">2&gt;controller层：业务模块的流程控制，调用service层的个个接口，控制具体的业务流程</span></span><br><span class="line"><span class="comment">3&gt;service层：业务模块的逻辑应用设计，先设计接口，再实现接口方法</span></span><br><span class="line"><span class="comment">4&gt;dao层：（mapper）Data Access Object 持久化层，有效管理数据</span></span><br><span class="line"><span class="comment">mp的crud:</span></span><br><span class="line"><span class="comment">增：insert </span></span><br><span class="line"><span class="comment">删：物理删除：deleteById 批量删除：deleteBatchIds 逻辑删除：增加<span class="doctag">@Version</span>注解，handler内添加语句</span></span><br><span class="line"><span class="comment">改：updateById</span></span><br><span class="line"><span class="comment">查：selectById、selectBatchIds、selectPage(分页查询)、selectList、复杂查询</span></span><br><span class="line"><span class="comment">mp的其他技术点：主键自动添加、属性自动填充、乐观锁</span></span><br><span class="line"><span class="comment">5&gt;entity层：根据mysql中各表情况，实体化各个属性，添加注解便于功能实现</span></span><br><span class="line"><span class="comment">如：以mybatis_plus为例，</span></span><br><span class="line"><span class="comment">lombok的<span class="doctag">@Data</span>，免除get/set/toString等方法的编写，爽的飞起</span></span><br><span class="line"><span class="comment">以何种方式自动添加主键的<span class="doctag">@TableId</span>(type=IdType.ID_WORKER)</span></span><br><span class="line"><span class="comment">某些属性的自动填充<span class="doctag">@TableField</span>(fill=FieldFill.INSERT_UPDATE)//添加和更新加该条注解的属性皆会自动填充</span></span><br><span class="line"><span class="comment">实现乐观锁中的版本号<span class="doctag">@Version</span>，需添加Version字段，以及乐观锁插件</span></span><br><span class="line"><span class="comment">做逻辑删除的<span class="doctag">@TableLogic</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//entity</span></span><br><span class="line"><span class="comment">//一律使用基本数据类型的包装类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@TableId(type=IdType.ID_WORKER)</span><span class="comment">//AUTO/INPUT/NONE/UUID/ID_WORKER_STR</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对应属性create_time</span></span><br><span class="line">    <span class="meta">@TableField(fill=FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">//对应属性update_time</span></span><br><span class="line">    <span class="meta">@TableField(fill=FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mapper</span></span><br><span class="line"><span class="comment">//引入mybatisplus中的BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span><span class="comment">//交给springboot实现接口实体化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乐观锁插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OptimisticLockerIntercepter <span class="title">optimisticLockerIntercepter</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerIntercepter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github公匙登录</title>
      <link href="/2021/08/15/github%E5%85%AC%E5%8C%99%E7%99%BB%E5%BD%95/"/>
      <url>/2021/08/15/github%E5%85%AC%E5%8C%99%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">8月13日登录gitHub失败解决办法（window10）：ssh登录</span></span><br><span class="line"><span class="comment">tips:</span></span><br><span class="line"><span class="comment">在cmd窗口窗口复制公匙到github窗口时，注意去除空格。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参考文章:</p><p><a href="https://xie.infoq.cn/article/fc28268dc4972d2aef45c7def">GitHub不再支持密码验证解决方案：SSH免密与Token登录配置 - InfoQ 写作平台</a>)</p><p><a href="%5B(8%E6%9D%A1%E6%B6%88%E6%81%AF">github 配置 SSH 免密登录</a> github配置SSH免密登录_从小吃外卖的博客-CSDN博客_github ssh免密登录](<a href="https://blog.csdn.net/qq_38163309/article/details/105335097">https://blog.csdn.net/qq_38163309/article/details/105335097</a>))</p><p><a href="%5B(8%E6%9D%A1%E6%B6%88%E6%81%AF">什么时ssh以及常见的ssh功能</a> 什么是SSH 以及常见的ssh 功能_dingxie1963的博客-CSDN博客](<a href="https://blog.csdn.net/dingxie1963/article/details/101259529?ops_request_misc=%7B%22request_id%22:%22162899117016780262554419%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=162899117016780262554419&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-101259529.first_rank_v2_pc_rank_v29&amp;utm_term=ssh&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/dingxie1963/article/details/101259529?ops_request_misc=%7B%22request%5Fid%22%3A%22162899117016780262554419%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=162899117016780262554419&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-101259529.first_rank_v2_pc_rank_v29&amp;utm_term=ssh&amp;spm=1018.2226.3001.4187</a>))</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis_plus</title>
      <link href="/2021/08/12/mybatis-plus-1/"/>
      <url>/2021/08/12/mybatis-plus-1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">新的闯关小游戏Mybatis_plus</span></span><br><span class="line"><span class="comment">让我们看看这个关于数据库框架的小游戏又有多少关卡呢！！！</span></span><br><span class="line"><span class="comment">1、第一个问题当然是什么是Mybatis_plus以及她的特点是什么？（不痛不痒的扯两句就行）</span></span><br><span class="line"><span class="comment">是mybatis的加强版，略略略</span></span><br><span class="line"><span class="comment">2、使用：在springboot一站式整合框架下，加入相关依赖</span></span><br><span class="line"><span class="comment">3、管中窥豹的技术点</span></span><br><span class="line"><span class="comment">1&gt;添加操作，主键生成策略</span></span><br><span class="line"><span class="comment">        添加操作：</span></span><br><span class="line"><span class="comment">        <span class="doctag">@Test</span></span></span><br><span class="line"><span class="comment">        public void addUser()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            User user = new User();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            user.setName(&quot;地狱的龙卷&quot;);</span></span><br><span class="line"><span class="comment">            user.setAge(18);</span></span><br><span class="line"><span class="comment">            user.setEmail(&quot;QiYu.@163.com&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int insert = userMapper.insert(user);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;insert:&quot;+insert);//影响的行数</span></span><br><span class="line"><span class="comment">            System.out.println(user);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        主键生成策略：</span></span><br><span class="line"><span class="comment">        <span class="doctag">@Data</span></span></span><br><span class="line"><span class="comment">        public class User &#123;</span></span><br><span class="line"><span class="comment">            //AUTO：自动增长（注意表中主键设auto_increment）</span></span><br><span class="line"><span class="comment">            //INPUT：设置id值</span></span><br><span class="line"><span class="comment">            //NONE：输入</span></span><br><span class="line"><span class="comment">            //UUID：随机唯一值</span></span><br><span class="line"><span class="comment">            //ID_WORKER：mp自带策略，生成19位值，数字类型使用这种策略，比如Long</span></span><br><span class="line"><span class="comment">            //ID_WORKER_STR：mp自带策略，生成19位值，字符串类型使用这种策略</span></span><br><span class="line"><span class="comment">            <span class="doctag">@TableId</span>(type = IdType.ID_WORKER)</span></span><br><span class="line"><span class="comment">            private Long id;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            private String name;</span></span><br><span class="line"><span class="comment">            private Integer age;</span></span><br><span class="line"><span class="comment">            private String email;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            <span class="doctag">@TableField</span>(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="comment">            private Date createTime;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            <span class="doctag">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="comment">            private Date updateTime;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">2&gt;修改操作，自动填充</span></span><br><span class="line"><span class="comment">        修改操作：</span></span><br><span class="line"><span class="comment">        <span class="doctag">@Test</span></span></span><br><span class="line"><span class="comment">        public void updateById()&#123;</span></span><br><span class="line"><span class="comment">            User user = new User();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            user.setId(1421442752316321793L);</span></span><br><span class="line"><span class="comment">            user.setAge(28);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int row = userMapper.updateById(user);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;row:&quot;+row);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        自动填充：</span></span><br><span class="line"><span class="comment">        <span class="doctag">@Data</span></span></span><br><span class="line"><span class="comment">        public class User &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            <span class="doctag">@TableId</span>(type = IdType.ID_WORKER)</span></span><br><span class="line"><span class="comment">            private Long id;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            private String name;</span></span><br><span class="line"><span class="comment">            private Integer age;</span></span><br><span class="line"><span class="comment">            private String email;</span></span><br><span class="line"><span class="comment">            //添加两个字段</span></span><br><span class="line"><span class="comment">            <span class="doctag">@TableField</span>(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="comment">            private Date createTime;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            <span class="doctag">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="comment">            private Date updateTime;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        元对象：</span></span><br><span class="line"><span class="comment">        <span class="doctag">@Component</span>//表示将其交给spring去管理</span></span><br><span class="line"><span class="comment">        public class MyMetaObjectHandler implements MetaObjectHandler&#123;</span></span><br><span class="line"><span class="comment">            //使用mp实现   添加   操作，这个方法执行</span></span><br><span class="line"><span class="comment">            <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">            public void insertFill(MetaObject metaObject) &#123;</span></span><br><span class="line"><span class="comment">                this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject);</span></span><br><span class="line"><span class="comment">                this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //使用mp实现   修改   操作，这个方法执行</span></span><br><span class="line"><span class="comment">            <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">            public void updateFill(MetaObject metaObject) &#123;</span></span><br><span class="line"><span class="comment">                this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        当调用添加或修改方法时，spring会根据注解和元对象对相关字段进行填充。</span></span><br><span class="line"><span class="comment">3&gt;乐观锁</span></span><br><span class="line"><span class="comment">4&gt;简单查询和分页查询</span></span><br><span class="line"><span class="comment">5&gt;逻辑删除功能</span></span><br><span class="line"><span class="comment">6&gt;复杂查询</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">tips:</span></span><br><span class="line"><span class="comment">再次遇到同一个关于数据库启动失败的问题，显示如下，</span></span><br><span class="line"><span class="comment">悔当时没有好好总结一下解决办法，嘤嘤嘤！！！</span></span><br><span class="line"><span class="comment">解决办法：</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="D:\developer_tools\blog\source\images\mysql启动异常.PNG"></p><p><img src="D:\developer_tools\blog\source\images\2.PNG"></p>]]></content>
      
      
      <categories>
          
          <category> mybatis_plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis_plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*字符串：</span></span><br><span class="line"><span class="comment">    谈到字符串该想到什么呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//1、创建字符串</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">String str11 = </span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li><p>数组介绍</p><p>数组可以存放多个同一类型的数据，数组也是一种数据类型，是引用类型，即：数组就是一组数据</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**数组：</span></span><br><span class="line"><span class="comment">稀疏数组的压缩与恢复</span></span><br><span class="line"><span class="comment">压缩规则：压缩后矩阵</span></span><br><span class="line"><span class="comment">[0,0]位置：原数组行数</span></span><br><span class="line"><span class="comment">[0,1]位置：原数组列数</span></span><br><span class="line"><span class="comment">[0,2]位置：原数组非0元素个数</span></span><br><span class="line"><span class="comment">第0行往下（不含第0行）：记录每个非0元素的行数、列数、实际值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSparseArr</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">21</span>];</span><br><span class="line">        arr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        arr1[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//原数组</span></span><br><span class="line">        print(arr1);</span><br><span class="line">        <span class="comment">//压缩后</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr2 = sparseArrToResArr(arr);</span><br><span class="line">        print(arr2);</span><br><span class="line">        <span class="comment">//恢复</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr3 = resArrToSparseArr(arr2);</span><br><span class="line">        print(arr3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseArrToResArr(<span class="keyword">int</span>[][] arr)&#123;</span><br><span class="line">        <span class="comment">//提取原数组非0元素个数，建立压缩后的数组</span></span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;<span class="comment">//记录非0元素的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[count1+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        resArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">        resArr[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>].length;</span><br><span class="line">        resArr[<span class="number">0</span>][<span class="number">2</span>] = count1;</span><br><span class="line">        <span class="comment">//存储非0元素</span></span><br><span class="line">        <span class="keyword">int</span> count2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    resArr[count2][<span class="number">0</span>] = i;</span><br><span class="line">                    resArr[count2][<span class="number">1</span>] = j;</span><br><span class="line">                    resArr[count2][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">                    count2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resArr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] resArrToSparseArr(<span class="keyword">int</span>[][] resArr)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[resArr[<span class="number">0</span>][<span class="number">0</span>]][resArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=resArr[<span class="number">0</span>][<span class="number">2</span>];i++)&#123;</span><br><span class="line">            arr[resArr[i][<span class="number">0</span>]][resArr[i][<span class="number">1</span>]] = resArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链表：单链表、双链表、约瑟夫问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆栈：前缀、中缀、后缀表达式，逆波兰计算器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队列：数组模拟队列、数组模拟环形队列</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">哈希表（链表数组）</span></span><br><span class="line"><span class="comment">延伸：二叉树数组等各种混合结构有兴趣都可以尝试着写一写</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">图：创建和遍历（深度优先遍历和广度优先遍历）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查找：顺序、二分、插值、斐波那契</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归思想：八皇后问题、迷宫问题</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KMP和暴力匹配的比较</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分治思想：汉诺塔问题</span></span><br><span class="line"><span class="comment">问题描述：有A、B、C三个小柱子，在A上存在由上到下半径依次增加的n个圆盘，问：在保持柱子上的圆盘小在上大在下的状态的前提下，如何将A柱上的圆盘全部移动到C盘上？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHanoiTower</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(nums+<span class="string">&quot;:&quot;</span>+A+<span class="string">&quot;-&gt;&quot;</span>+C);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hanoiTower(nums-<span class="number">1</span>,A,C,B);</span><br><span class="line">            System.out.println(nums+<span class="string">&quot;:&quot;</span>+A+<span class="string">&quot;-&gt;&quot;</span>+C);</span><br><span class="line">            hanoiTower(nums-<span class="number">1</span>,B,A,C);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划：背包问题（01背包和完全背包）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">贪心：覆盖问题</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h1 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h1><h1 id="Kusikara"><a href="#Kusikara" class="headerlink" title="Kusikara"></a>Kusikara</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>semantic UI(1)</title>
      <link href="/2021/08/07/semantic-UI-1/"/>
      <url>/2021/08/07/semantic-UI-1/</url>
      
        <content type="html"><![CDATA[<h3 id="首页展示及代码解析"><a href="#首页展示及代码解析" class="headerlink" title="首页展示及代码解析"></a>首页展示及代码解析</h3><h3 id="首页效果"><a href="#首页效果" class="headerlink" title="首页效果"></a>首页效果</h3><p>![本地图片](C:\Users\Liyou\Pictures\Camera Roll\blog\首页1.PNG)</p><p>![本地图片](C:\Users\Liyou\Pictures\Camera Roll\blog\首页2.PNG)</p><h4 id="一、导航"><a href="#一、导航" class="headerlink" title="一、导航"></a>一、导航</h4><ol><li><p>展示</p><p>![本地图片](C:\Users\Liyou\Pictures\Camera Roll\blog\导航.PNG)</p></li><li><p>代码与解析</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导航--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nav:定义导航链接的部分 ui:一个特殊的类名，用来区分组件的各个部分 inverted:反色--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--m-padded-tb-mini,--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted attached segment m-padded-tb-mini&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--container:更好的适应移动端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui container&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--stackable屏幕小的时候可堆叠，适应手机端--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted secondary stackable menu&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;ui teal header item&quot;</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--home idea tags clone info :Semantic UI可用图标--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-item item m-mobile-hide&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;home icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-item item m-mobile-hide&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;idea icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>分类<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-item item m-mobile-hide&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;tags icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-item item m-mobile-hide&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;clone icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>归档<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-item item m-mobile-hide&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;info icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>关于我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right m-item item m-mobile-hide&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui icon transparent inverted input&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;search link icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui menu toggle black icon button m-right-top m-mobile-show&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;sidebar icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="二、中间内容（context）"><a href="#二、中间内容（context）" class="headerlink" title="二、中间内容（context）"></a>二、中间内容（context）</h4><ol><li><p>展示</p><p>![](C:\Users\Liyou\Pictures\Camera Roll\blog\context.PNG)</p></li><li><p>代码与解析</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--中间内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;m-padded-tb-large&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui m-container container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui stackable grid&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--左边博客内容--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;eleven wide column&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--header--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui top attached segment&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui middle aligned two column grid&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;ui teal header&quot;</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right aligned column&quot;</span>&gt;</span></span><br><span class="line">                                共 <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;ui orange header m-inline-block m-text-thin&quot;</span>&gt;</span> 14 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span>篇</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--content--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui attached segment&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui padded vertical segment m-padded-tb-big&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui padded vertical segment m-padded-tb-large&quot;</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--mobile reversed:手机端反转--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui mobile reversed grid&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;eleven wide column&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;ui header&quot;</span>&gt;</span>你真正理解什么是派大星的自由吗？<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;m-text&quot;</span>&gt;</span>啊啦啦啦啦啦啦啊大量的几位偶的我带你去爱到底机房内为非法我觉得佛奥电脑阿松大<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui grid&quot;</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;eleven wide column&quot;</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui mini horizontal link list&quot;</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://picsum.photos/seed/picsum/100/100&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui avatar image&quot;</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>Liyou<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;calendar icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 2021-08-07</span><br><span class="line">                                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;eye icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 231</span><br><span class="line">                                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right aligned five wide column&quot;</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-padded-tiny m-text-thin&quot;</span>&gt;</span>认知升级<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;five wide column&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://picsum.photos/seed/picsum/800/450&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui rounded image&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!--footer--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui bottom attached segment&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui middle aligned two column grid&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui button mini teal basic&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right aligned column&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui button mini teal basic&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--右边的top--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;five wide column&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!--分类--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segments m-margin-tb-large&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui secondary segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui two column grid&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;idea icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>分类</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right aligned column&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>more<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;angle double right icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui fluid vertical menu&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                    学习日志</span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic left pointing label&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                    学习日志</span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic left pointing label&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                    学习日志</span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic left pointing label&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                    学习日志</span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic left pointing label&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                    学习日志</span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic left pointing label&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                                    学习日志</span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic left pointing label&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--标签--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segments m-margin-tb-large&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui secondary segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui two column grid&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;tags icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>标签</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right aligned column&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>more<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;angle double right icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui teal segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;ui teal basic label m-margin-tb-tiny&quot;</span>&gt;</span></span><br><span class="line">                                方法论 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!--最新推荐--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segments m-margin-tb-large&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui secondary segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bookmark icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>最新推荐</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-black m-text-thin&quot;</span>&gt;</span>用户故事(User Story)<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-black m-text-thin&quot;</span>&gt;</span>用户故事（User Story）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-black m-text-thin&quot;</span>&gt;</span>用户故事（User Story）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-black m-text-thin&quot;</span>&gt;</span>用户故事（User Story）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-black m-text-thin&quot;</span>&gt;</span>用户故事（User Story）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui segment&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-black m-text-thin&quot;</span>&gt;</span>用户故事（User Story）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--二维码--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;ui horizontal divider header m-margin-tb-large&quot;</span>&gt;</span>扫码关注我<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui centered card&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 11em&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./static/images/wechat.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui rounded image&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="三、底部（footer）"><a href="#三、底部（footer）" class="headerlink" title="三、底部（footer）"></a>三、底部（footer）</h4><ol><li><p>展示</p><p>![](C:\Users\Liyou\Pictures\Camera Roll\blog\底部.PNG)</p></li><li><p>代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted segment vertical m-padded-tb-massive&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui center aligned container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui stackable grid divided inverted&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three wide column&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted link list&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./static/images/wechat.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ui rounded image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three wide column&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted header m-opacity-mini&quot;</span>&gt;</span>最新博客<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted link list&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>用户故事（User Story）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>关于刻意练习的清单<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>失败要趁早<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three wide column&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted header m-opacity-mini&quot;</span>&gt;</span>联系我<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted link list&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>QQ：1458396499<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>email：hualala-2@aliyun.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--&lt;a href=&quot;#&quot; class=&quot;item&quot;&gt;用户故事（User Story）&lt;/a&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;seven wide column&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted header m-opacity-mini&quot;</span>&gt;</span>Liyou<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;m-opacity-mini m-text-spaced m-text-thin&quot;</span>&gt;</span>这是我的个人博客，会分享关于写作、思考内容的相关问题，希望对来这边的小伙伴有所帮助！！！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui inverted section divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;m-text-thin m-text-spaced m-opacity-tiny&quot;</span>&gt;</span>Copyright @ 2021 hualala-2 Designed by Liyou<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>附me.css</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css定义背景*/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../images/bg.gif&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-mini</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.m-padded-tiny</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.m-padded-tb-mini</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0.2em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">0.2em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb-tiny</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0.3em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">0.3em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb-small</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0.5em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">0.5em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb-large</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">2em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">2em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb-big</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">3em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">3em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb-huge</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">4em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">4em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-padded-tb-massive</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">5em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">5em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----text----*/</span></span><br><span class="line"><span class="selector-class">.m-text</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">300</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">1px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.m-text-thin</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">300</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-text-spaced</span> &#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">1px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-text-lined</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------margin(边缘)---------------*/</span></span><br><span class="line"><span class="selector-class">.m-margin-tb-tiny</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0.3em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0.3em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-margin-tb-small</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0.5em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-margin-tb</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.m-margin-tb-large</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---------opacity（透明程度）-----------*/</span></span><br><span class="line"><span class="selector-class">.m-opacity-mini</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.m-opacity-tiny</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------position---------------*/</span></span><br><span class="line"><span class="selector-class">.m-right-top</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---------display----------*/</span></span><br><span class="line"><span class="selector-class">.m-inline-block</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------container----------------*/</span></span><br><span class="line"><span class="selector-class">.m-container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">72em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------color-------------*/</span></span><br><span class="line"><span class="selector-class">.m-black</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.m-mobile-show</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------当像素小于768时（手机），隐藏---------------*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)&#123;</span><br><span class="line">    <span class="selector-class">.m-mobile-hide</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.m-mobile-show</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: block <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h3><p><a href="%5BSpringBoot%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1nE411r7TF?p=8&spm_id_from=pageDriver)">springboot开发一个小而美的个人博客</a></p><p>[html参考手册](<a href="https://www.runoob.com/tags/html-reference.html">HTML 标签列表(字母排序) | 菜鸟教程 (runoob.com)</a>)</p><p>[Semantic UI文档](<a href="https://zijieke.com/semantic-ui/elements/button.php">按钮 - Semantic UI - 字节课 (zijieke.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Semantic_UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Semantic_UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown(Typora)</title>
      <link href="/2021/08/02/markdown-Typora/"/>
      <url>/2021/08/02/markdown-Typora/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p><strong>文件——&gt;偏好设置——&gt;Markdown——&gt;取消严格模式，勾选上标、下标、高亮，重启Typora即可生效</strong></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li><p>Java代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld Java~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示方式：```java</span></span><br><span class="line"><span class="comment">// `键是Tab键上1键左边的键位</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">linux下springboot项目的启动命令</span></span><br><span class="line">java -jar blog start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示方式：```shell</span></span><br></pre></td></tr></table></figure></li><li><p>行内代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示方式：` 加上 行内代码块内容 加上 `</span></span><br></pre></td></tr></table></figure><p><code>java</code></p></li></ul><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标题语法：一个或多个#键+空格+内容</span></span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1、斜体--&gt;</span></span><br><span class="line"> *被斜体化内容*</span><br><span class="line"><span class="comment">&lt;!--2、加粗--&gt;</span></span><br><span class="line"> **加粗内容**</span><br><span class="line"><span class="comment">&lt;!--3、斜体加粗--&gt;</span></span><br><span class="line">***斜体加粗内容***</span><br><span class="line"><span class="comment">&lt;!--4、下划线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>带有下划线内容<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--4、代码高亮显示(需勾选高亮语法)--&gt;</span></span><br><span class="line"> ==reoreoreo==</span><br><span class="line"><span class="comment">&lt;!--5、下标(需勾选下标语法)--&gt;</span></span><br><span class="line">H~2~O~2~</span><br><span class="line"><span class="comment">&lt;!--6、上标(需勾选上标语法)--&gt;</span></span><br><span class="line">m^2^</span><br><span class="line"><span class="comment">&lt;!--5、删除线--&gt;</span></span><br><span class="line"> ~~被删除内容~~</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>被斜体化的内容</em></p><p><strong>加粗内容</strong></p><p><em><strong>斜体加粗内容</strong></em></p><p><u>带有下划线内容</u></p><p>==高亮内容==</p><p>H<del>2</del>O<del>2</del></p><p>m^2^</p><p><del>被删除的内容</del></p><h2 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：:加上smile  会出现相关表情</span></span><br><span class="line"><span class="comment">// :加上100，进行点选</span></span><br><span class="line"><span class="comment">//Win10：使用win键加上.  弹出win10自带表情包</span></span><br><span class="line"><span class="comment">//mac：control+command+space点选</span></span><br></pre></td></tr></table></figure><p>:smile:</p><p>:100:</p><p>:radioactive:</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用语法</span></span><br><span class="line">&gt;一级引用</span><br><span class="line">&gt;&gt;二级引用</span><br><span class="line">&gt;&gt;&gt;三级引用</span><br></pre></td></tr></table></figure><blockquote><p>一级引用</p><p>的撒大大大大大</p></blockquote><blockquote><blockquote><p>二级引用</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分割线1</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//分割线2</span></span><br><span class="line">***</span><br></pre></td></tr></table></figure><hr><hr><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地图片、在线图片</span></span><br><span class="line">![图片名称](图片路径)</span><br></pre></td></tr></table></figure><p><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0824ab18972bd40714ed5f2c7c899e510fb3093c.jpg" alt="三笠"></p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>使用CTRL+click可在文件内跳转</p><ul><li><p>外部跳转——超链接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超链接语法</span></span><br><span class="line">[我的链接名](链接地址)</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/">哔哩哔哩网站</a></p></li><li><p>内部跳转——本文件内跳（Typora支持）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部链接语法</span></span><br><span class="line">[我的链接名](#链接地址)</span><br></pre></td></tr></table></figure><p><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97">回到代码块</a></p></li><li><p>自动链接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动链接语法</span></span><br><span class="line"><span class="comment">//使用&lt;&gt;包括的URL或邮箱地址，会被自动转为超链接</span></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><p><a href="mailto:&#x31;&#x32;&#x33;&#x40;&#101;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#x31;&#x32;&#x33;&#x40;&#101;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a></p></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、无序列表</span></span><br><span class="line">-（空一格）加上  目录</span><br><span class="line"><span class="comment">//2、有序列表</span></span><br><span class="line">编号加上 . （空一格）加上  目录</span><br></pre></td></tr></table></figure><ul><li>目录1</li><li>目录2</li></ul><ol><li>目录1</li><li>目录2</li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右键直接插入即可</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>嗡嗡嗡</th><th>事实上</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>#画图篇</p><p>利用Markdown画图（需勾选扩展语法）</p><h2 id="流程图（graph）"><a href="#流程图（graph）" class="headerlink" title="流程图（graph）"></a>流程图（graph）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">操作流程：</span></span><br><span class="line"><span class="comment">1、如同代码块一样，输入```mermaid</span></span><br><span class="line"><span class="comment">2、在代码块中输入流程图的描述：</span></span><br><span class="line"><span class="comment">    graph TD;</span></span><br><span class="line"><span class="comment">A(开始j=0)--&gt;B&#123;arrj&gt;arrj+1&#125;;</span></span><br><span class="line"><span class="comment">B--是--&gt;C[交换位置];</span></span><br><span class="line"><span class="comment">B--否--&gt;D;</span></span><br><span class="line"><span class="comment">C--&gt;D[j+1];</span></span><br><span class="line"><span class="comment">D--&gt;B;</span></span><br><span class="line"><span class="comment">如下所示。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>冒泡算法：1、开始：输入一个整型数组arr；2、拿到数组0位置上的数arr[0]；3、与相邻位置的数进行比较if</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序(从小到大)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBubble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历了arr.length-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//1、从0位置开始遍历数组，相邻位置的值进行比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A1(开始)--&gt;A2;</span><br><span class="line">A2(j=0)--&gt;B&#123;j小于arr.length-1&#125;;</span><br><span class="line">B--是--&gt;C&#123;arrj小于arrj+1&#125;;</span><br><span class="line">B--否--&gt;F(结束);</span><br><span class="line">C--是--&gt;D[交换位置];</span><br><span class="line">D--&gt;E;</span><br><span class="line">C--否--&gt;E[j=j+1];</span><br><span class="line">E--&gt;B;</span><br></pre></td></tr></table></figure><p>方向描述：</p><table><thead><tr><th align="center">用词</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">TB（top、bottom）、TD（down）</td><td align="center">从上到下</td></tr><tr><td align="center">BT</td><td align="center">从下到上</td></tr><tr><td align="center">RL（right、left）</td><td align="center">从右到左</td></tr><tr><td align="center">LR</td><td align="center">从左到右</td></tr></tbody></table><p>节点形状：</p><table><thead><tr><th align="center">表述</th><th align="center">说明</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">id[文字]</td><td align="center">矩形节点</td><td align="center">表示过程，也就是整个流程中的一个环节</td></tr><tr><td align="center">id(文字)</td><td align="center">圆角矩形节点</td><td align="center">表示开始和结束</td></tr><tr><td align="center">id((文字))</td><td align="center">圆形节点</td><td align="center">表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr><td align="center">id{文字}</td><td align="center">菱形节点</td><td align="center">表示判断、决策</td></tr><tr><td align="center">id&gt;文字]</td><td align="center">右向旗帜状节点</td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">graph LR;</span></span><br><span class="line"><span class="comment">A(表过程)--&gt;B(开始与结束节点);</span></span><br><span class="line"><span class="comment">B--&gt;C((表连接));</span></span><br><span class="line"><span class="comment">C--&gt;D&#123;表判断&#125;;</span></span><br><span class="line"><span class="comment">D--&gt;F&gt;旗帜节点];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A(表过程)--&gt;B(开始与结束节点);</span><br><span class="line">B--&gt;C((表连接));</span><br><span class="line">C--&gt;D&#123;表判断&#125;;</span><br><span class="line">D--&gt;F&gt;旗帜节点];</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">Markdown保姆级教程之基础篇（Typora使用教程）_哔哩哔哩_bilibili</a></p><p><a href="https://typora.io/">Typora — a markdown editor, markdown reader.</a></p><p><a href="http://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/#e6a682e8bfb0_1">小书匠语法说明之mermaid | 小书匠 (xiaoshujiang.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建与优化</title>
      <link href="/2021/08/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2021/08/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    该博客网站使用的是Hexo框架+Butterfly主题。</p><p>​    首先，Hexo是什么呢？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>​    简而言之，Hexo就是一款专门用于搭建博客的模板，类比我们写简历时本已提供的简历模板，我们获得一个简历模板后，则可以填写一些相关的信息。而我们获得一个博客模板之后，则是对博客模板进行主题配置等操作，让其个性化。</p><p>​    那我们怎样获得一个博客模板呢？如下操作：</p><p>​    操作系统：window10 </p><p>​    在cmd或git bash窗口执行命令</p><h1 id="博客搭建与部署"><a href="#博客搭建与部署" class="headerlink" title="博客搭建与部署"></a>博客搭建与部署</h1><h2 id="安装nodejs和git"><a href="#安装nodejs和git" class="headerlink" title="安装nodejs和git"></a>安装nodejs和git</h2><p>由于Hexo需要nodejs和git做支持，所以前置步骤即安装nodejs和git。</p><p>nodejs下载地址：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p><p>git下载地址：<a href="https://git-scm.com/">Git (git-scm.com)</a></p><p>下载长期维护的对应版本即可。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">node</span> <span class="string">--version</span> <span class="comment">#查看nodejs版本，确认安装成功</span></span><br><span class="line"><span class="string">npm</span> <span class="string">-v</span> <span class="comment">#查看包管理器版本</span></span><br><span class="line"><span class="comment">#由于镜像源的速度很慢，所以先利用npm安装一个cnpm</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">cnpm</span> <span class="string">--registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="string">cnpm</span> <span class="comment">#确认cnpm安装成功 </span></span><br><span class="line"><span class="string">cnpm</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure><h2 id="安装Hexo博客框架"><a href="#安装Hexo博客框架" class="headerlink" title="安装Hexo博客框架"></a>安装Hexo博客框架</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#利用cnpm全局安装Hexo博客框架</span></span><br><span class="line"><span class="string">cnpm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"><span class="comment">#显示版本号，确认Hexo安装完成</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure><h2 id="使用Hexo博客框架生成博客"><a href="#使用Hexo博客框架生成博客" class="headerlink" title="使用Hexo博客框架生成博客"></a>使用Hexo博客框架生成博客</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立一个名为blog的空文件夹</span></span><br><span class="line"><span class="comment">#在名为blog的文件夹下进行hexo的初始化，即执行hexo init命令</span></span><br><span class="line"><span class="comment">#之后博客的一切活动都在blog文件夹下进行，出问题，干掉重开即可</span></span><br><span class="line"><span class="comment">#显示INFO Start blogging with Hexo！即安装完成！</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动博客(s:start)</span></span><br><span class="line"><span class="comment">#Hexo is running at http://localhost:4000 . </span></span><br><span class="line"><span class="comment">#本地通过4000端口即可访问</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写一篇博客（n：new）</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">n</span> <span class="string">&quot;我的第一篇博客文章&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清除缓存文件（db.json）和已生成的静态文件（public），在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生产静态文件(generate)</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重新启动，便可以在本地4000端口获得新写的博客内容啦！！!</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">s</span> </span><br></pre></td></tr></table></figure><h2 id="部署博客到远端"><a href="#部署博客到远端" class="headerlink" title="部署博客到远端"></a>部署博客到远端</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将博客部署在GitHub上</span></span><br><span class="line"><span class="comment">#1、打开github，新建一个空仓库</span></span><br><span class="line"><span class="comment">#仓库名必须符合特定要求，即 昵称.github.io，如我的昵称是hualala-2,则仓库名为hualala-2.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#回到命令行进行操作</span></span><br><span class="line"><span class="comment">#2、在blog目录下安装一个部署的插件</span></span><br><span class="line"><span class="string">cnpm</span> <span class="string">install</span> <span class="string">--save</span> <span class="string">hexo-deployer-git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、设置blog文件夹下的名为_config.yml的文件</span></span><br><span class="line"><span class="comment">#进入文件，扫描到末尾Deployment（填写时，注意空格）</span></span><br><span class="line"><span class="comment">#deploy:</span></span><br><span class="line"><span class="comment">#type: git</span></span><br><span class="line"><span class="comment">#repo: http://github.com/hualala-2/hualala-2.github.io.git</span></span><br><span class="line"><span class="comment">#branch: master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、部署博客到远端</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d(deploy)</span></span><br></pre></td></tr></table></figure><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、clone Butterfly主题，将其放置在themes/Butterfly的位置</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/jerryc127/hexo-theme-butterfly.git</span> <span class="string">themes/Butterfly</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、在_config.yml下更改theme，启用主题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、执行hexo d推送到远端</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><h1 id="Butterfly主题优化"><a href="#Butterfly主题优化" class="headerlink" title="Butterfly主题优化"></a>Butterfly主题优化</h1><h2 id="blog文件夹介绍"><a href="#blog文件夹介绍" class="headerlink" title="blog文件夹介绍"></a>blog文件夹介绍</h2><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.yml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scaffolds</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_drafts</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">_posts</span></span><br><span class="line"><span class="string">└──</span> <span class="string">themes</span></span><br></pre></td></tr></table></figure><p>_config.yml：网站的配置信息，您可以在此配置大部分的参数。</p><p>package.json：应用程序的信息，EJS, Stylus和 Markdown renderer 已默认安装，您可以自由移除。</p><p>scaffolds：模板文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><p>source：资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><p>themes：主题文件夹。Hexo 会根据主题来生成静态页面。</p><p>更多关于blog文件夹下的_config.yml的配置，前往<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>查看即可，写的很详细。</p><h2 id="Butterfly美化"><a href="#Butterfly美化" class="headerlink" title="Butterfly美化"></a>Butterfly美化</h2><h3 id="导航栏修改"><a href="#导航栏修改" class="headerlink" title="导航栏修改"></a>导航栏修改</h3><p>导航栏展示：</p><img src="..\博客搭建与优化\导航栏.PNG"/><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章||fas</span> <span class="attr">fa-feather-alt:</span></span><br><span class="line">      <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">娱乐||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">      <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">      <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/messageboard/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-paper-plane</span></span><br><span class="line">  <span class="string">优链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于我:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>如：fas fa-home或者fas fa-folder-open这样的图标，可以参看<a href="https://www.runoob.com/font-awesome/fontawesome-icons-hand.html">Font Awesome 手势图标 | 菜鸟教程 (runoob.com)</a>和<a href="https://getkit.cn/resources/font-awesome/">Font Awesome 字体图标对照表 (getkit.cn)</a>或其他相关网站。</p><p>美化实在是个深坑坑，挖坑挖坑（滑稽）</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><p>Markdown图片无法显示的问题</p><p>采用HTML的图片引入标签。（MD支持html）</p><p>图片放在blog&gt;source&gt;_post&gt;文件夹（根据具体文章名新建相同名称的文件夹）&gt;具体图片</p><p>执行hexo d部署到远端后，在本地查看 ：public&gt;具体时间文件夹</p><p>使用图片的相对路径即可</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片路径&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>1、<a href="https://hexo.io/zh-cn/">Hexo</a></p><p>2、<a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=7177332002560852852&spm_id_from=333.337.0.0">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p><p>3、<a href="https://www.little-demon.cn/post/f9e71d59.html">Butterfly基础美化 | Little-Demon’s Blog</a></p><p>4、<a href="https://www.runoob.com/">菜鸟教程</a></p><p>5、<a href="https://getkit.cn/resources/">鸽听网|在线工具 (getkit.cn)</a></p><p>6、<a href="https://www.antmoe.com/posts/75a6347a/">Hexo安装并使用Butterfly主题 | 小康博客 (antmoe.com)</a></p><p>7、<a href="https://snow.js.org/">小林书架blog </a></p><p>8、<a href="https://butterfly.lete114.top/">Lete乐特 ‘s Blog - Lete乐特个人博客 (lete114.top)</a></p><p>9、<a href="https://www.cnblogs.com/big0range/p/14229322.html">手摸手带你用Hexo撸博客(三)之添加评论系统 - big0range - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2021/08/01/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/08/01/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一条或多条sql语句的独立运行单元</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="事务的四大属性（acid）"><a href="#事务的四大属性（acid）" class="headerlink" title="事务的四大属性（acid）"></a>事务的四大属性（acid）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原子性（auto）：</span></span><br><span class="line"><span class="comment">一致性（consistence）:</span></span><br><span class="line"><span class="comment">隔离性（isolution）：</span></span><br><span class="line"><span class="comment">持久性（druable）:</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="隔离的级别"><a href="#隔离的级别" class="headerlink" title="隔离的级别"></a>隔离的级别</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（事务T1和事务T2读取同一张表的数据）</span></span><br><span class="line"><span class="comment">脏读：T1读取T2更新但未提交的数据</span></span><br><span class="line"><span class="comment">不可重复读：T1读取T2已提交的数据，导致同一条数据，前后访问不一致</span></span><br><span class="line"><span class="comment">幻读：T1读取到T2新插入的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="事务的书写"><a href="#事务的书写" class="headerlink" title="事务的书写"></a>事务的书写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">start transaction;</span><br><span class="line">update user set name=&#x27;JoJo&#x27; where id = 1;</span><br><span class="line">update user set name=&#x27;Dio&#x27; where id = 2;</span><br><span class="line">commit;(rollback;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
